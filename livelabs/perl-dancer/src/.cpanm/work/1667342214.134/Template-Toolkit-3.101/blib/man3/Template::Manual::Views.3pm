.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Template::Manual::Views 3"
.TH Template::Manual::Views 3 "2022-07-26" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Manual::Views \- Template Toolkit views (experimental)
.SH "Overview"
.IX Header "Overview"
A view is effectively a collection of templates and/or variable
definitions which can be passed around as a self-contained unit.  This
then represents a particular interface or presentation style for other
objects or items of data.
.PP
You can use views to implement custom \*(L"skins\*(R" for an application or
content set.  You can use them to help simplify the presentation of
common objects or data types.  You can even use then to automate the
presentation of complex data structures such as that generated in an
\&\f(CW\*(C`XML::DOM\*(C'\fR tree or similar.  You let an iterator do the walking, and the
view does the talking (or in this case, the presenting).  Voila \- you
have view independent, structure shy traversal using templates.
.PP
In general, views can be used in a number of different ways to achieve
several different things.  They elegantly solve some problems which
were otherwise difficult or complicated, and make easy some things
that were previously hard.
.PP
At the moment, they're still very experimental.  The directive syntax
and underlying \s-1API\s0 are likely to change quite considerably over the
next version or two.  Please be very wary about building your
multi-million dollar e\-commerce solutions based around this feature.
.SH "Views as Template Collectors/Providers"
.IX Header "Views as Template Collectors/Providers"
The \f(CW\*(C`VIEW\*(C'\fR directive starts a view definition and includes a name by
which the view can be referenced.  The view definition continues up to
the matching \f(CW\*(C`END\*(C'\fR directive.
.PP
.Vb 3
\&    [% VIEW myview %]
\&       ...
\&    [% END %]
.Ve
.PP
The first role of a view is to act as a collector and provider of templates.
The \f(CW\*(C`include()\*(C'\fR method can be called on a view to effectively do the same
thing as the \f(CW\*(C`INCLUDE\*(C'\fR directive.  The template name is passed as the first
argument, followed by any local variable definitions for the template.
.PP
.Vb 1
\&    [% myview.include(\*(Aqheader\*(Aq, title=\*(AqThe Title\*(Aq) %]
\&
\&    # equivalent to
\&    [% INCLUDE header  title=\*(AqThe Title\*(Aq %]
.Ve
.PP
Views accept a number of configuration options which can be used to control
different aspects of their behaviour.  The '\f(CW\*(C`prefix\*(C'\fR' and '\f(CW\*(C`suffix\*(C'\fR' options
can be specified to add a fixed prefix and/or suffix to the name of each template.
.PP
.Vb 5
\&    [% VIEW myview
\&         prefix = \*(Aqmy/\*(Aq
\&         suffix = \*(Aq.tt2\*(Aq ;
\&       END
\&    %]
.Ve
.PP
Now the call
.PP
.Vb 1
\&    [% myview.include(\*(Aqheader\*(Aq, title=\*(AqThe Title\*(Aq) %]
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&    [% INCLUDE my/header.tt2  title=\*(AqThe Title\*(Aq %]
.Ve
.PP
Views provide an \f(CW\*(C`AUTOLOAD\*(C'\fR method which maps method names to the
\&\f(CW\*(C`include()\*(C'\fR method.  Thus, the following are all equivalent:
.PP
.Vb 3
\&    [% myview.include(\*(Aqheader\*(Aq, title=\*(AqHello World\*(Aq) %]
\&    [% myview.include_header(title=\*(AqHello World\*(Aq) %]
\&    [% myview.header(title=\*(AqHello World\*(Aq) %]
.Ve
.SH "Local BLOCK Definitions"
.IX Header "Local BLOCK Definitions"
A \f(CW\*(C`VIEW\*(C'\fR definition can include \f(CW\*(C`BLOCK\*(C'\fR definitions which remain local to
the view.   A request for a particular template will return a \f(CW\*(C`BLOCK\*(C'\fR,
if defined, in preference to any other template of the same name.
.PP
.Vb 3
\&    [% BLOCK foo %]
\&       public foo block
\&    [% END %]
\&
\&    [% VIEW plain %]
\&       [% BLOCK foo %]
\&       plain foo block
\&       [% END %]
\&    [% END %]
\&
\&    [% VIEW fancy %]
\&       [% BLOCK foo %]
\&       fancy foo block
\&       [% END %]
\&    [% END %]
\&
\&    [% INCLUDE foo %]       # public foo block
\&    [% plain.foo %]         # plain foo block
\&    [% fancy.foo %]         # fancy foo block
.Ve
.PP
In addition to \f(CW\*(C`BLOCK\*(C'\fR definitions, a \f(CW\*(C`VIEW\*(C'\fR can contain any other
template directives.  The entire \f(CW\*(C`VIEW\*(C'\fR definition block is processed to
initialise the view but no output is generated (this may change \s-1RSN\s0 \-
and get stored as '\f(CW\*(C`output\*(C'\fR' item, subsequently accessible as \f(CW\*(C`[%
view.output %]\*(C'\fR).  However, directives that have side-effects, such as
those that update a variable, will have noticeable consequences.
.SH "Preserving Variable State within Views"
.IX Header "Preserving Variable State within Views"
Views can also be used to save the values of any existing variables,
or to create new ones at the point at which the view is defined.
Unlike simple template metadata (\f(CW\*(C`META\*(C'\fR) which can only contain static
string values, the view initialisation block can contain any template
directives and generate any kind of dynamic output and/or data items.
.PP
.Vb 5
\&    [% VIEW my_web_site %]
\&       [% view.title   = title or \*(AqMy Cool Web Site\*(Aq %]
\&       [% view.author  = "$abw.name, $abw.email" %]
\&       [% view.sidebar = INCLUDE my/sidebar.tt2 %]
\&    [% END %]
.Ve
.PP
Note that additional data items can be specified as arguments to the \f(CW\*(C`VIEW\*(C'\fR
directive.  Anything that doesn't look like a configuration parameter is
assumed to be a data item.  This can be a little hazardous, of course, because
you never know when a new configuration item might get added which interferes
with your data.
.PP
.Vb 10
\&    [% VIEW my_web_site
\&            # config options
\&            prefix = \*(Aqmy/\*(Aq
\&            # misc data
\&            title   = title or \*(AqMy Cool Web Site\*(Aq
\&            author  = "$abw.name, $abw.email"
\&            sidebar = INCLUDE my/sidebar.tt2
\&    %]
\&       ...
\&    [% END %]
.Ve
.PP
Outside of the view definition you can access the view variables as, for
example:
.PP
.Vb 1
\&    [% my_web_site.title %]
.Ve
.PP
One important feature is the equivalence of simple variables and templates.
You can implement the view item '\f(CW\*(C`title\*(C'\fR' as a simple variable, a template
defined in an external file, possibly with a prefix/suffix automatically
appended, or as a local \f(CW\*(C`BLOCK\*(C'\fR definition within the \f(CW\*(C`[% VIEW %] ... [% END %]\*(C'\fR
definition.  If you use the syntax above then the view will Do The Right
Thing to return the appropriate output.
.PP
At the \f(CW\*(C`END\*(C'\fR of the \f(CW\*(C`VIEW\*(C'\fR definition the view is \*(L"sealed\*(R" to prevent you
from accidentally updating any variable values.  If you attempt to change
the value of a variable after the \f(CW\*(C`END\*(C'\fR of the \f(CW\*(C`VIEW\*(C'\fR definition block then
a \f(CW\*(C`view\*(C'\fR error will be thrown.
.PP
.Vb 6
\&    [% TRY;
\&         my_web_site.title = \*(AqNew Title\*(Aq;
\&       CATCH;
\&         error;
\&       END
\&    %]
.Ve
.PP
The error above will be reported as:
.PP
.Vb 1
\&    view error \- cannot update item in sealed view: title
.Ve
.PP
The same is true if you pass a parameter to a view variable.  This is
interpreted as an attempt to update the variable and will raise the same
warning.
.PP
.Vb 1
\&    [% my_web_site.title(\*(AqNew Title\*(Aq) %]    # view error!
.Ve
.PP
You can set the \f(CW\*(C`silent\*(C'\fR parameter to have the view ignore these
parameters and simply return the variable value.
.PP
.Vb 6
\&    [% VIEW my_web_site
\&            silent = 1
\&            title  = title or \*(AqMy Cool Web Site\*(Aq
\&            # ... ;
\&       END
\&    %]
\&
\&    [% my_web_site.title(\*(AqBlah Blah\*(Aq) %]   # My Cool Web Site
.Ve
.PP
Alternately, you can specify that a view is unsealed allowing existing
variables to be updated and new variables defined.
.PP
.Vb 6
\&    [% VIEW my_web_site
\&            sealed = 0
\&            title  = title or \*(AqMy Cool Web Site\*(Aq
\&            # ... ;
\&       END
\&    %]
\&
\&    [% my_web_site.title(\*(AqBlah Blah\*(Aq) %]   # Blah Blah
\&    [% my_web_site.title %]                # Blah Blah
.Ve
.SS "Inheritance, Delegation and Reuse"
.IX Subsection "Inheritance, Delegation and Reuse"
Views can be inherited from previously defined views by use of the \f(CW\*(C`base\*(C'\fR
parameter.  This example shows how a base class view is defined which
applies a \f(CW\*(C`view/default/\*(C'\fR prefix to all template names.
.PP
.Vb 4
\&    [% VIEW my.view.default
\&            prefix = \*(Aqview/default/\*(Aq;
\&       END
\&    %]
.Ve
.PP
Thus the directive:
.PP
.Vb 1
\&    [% my.view.default.header(title=\*(AqHello World\*(Aq) %]
.Ve
.PP
is now equivalent to:
.PP
.Vb 1
\&    [% INCLUDE view/default/header title=\*(AqHello World\*(Aq %]
.Ve
.PP
A second view can be defined which specifies the default view as a
base.
.PP
.Vb 5
\&    [% VIEW my.view.fancy
\&            base   = my.view.default
\&            prefix = \*(Aqview/fancy/\*(Aq;
\&       END
\&    %]
.Ve
.PP
Now the directive:
.PP
.Vb 1
\&    [% my.view.fancy.header(title=\*(AqHello World\*(Aq) %]
.Ve
.PP
will resolve to:
.PP
.Vb 1
\&    [% INCLUDE view/fancy/header title=\*(AqHello World\*(Aq %]
.Ve
.PP
or if that doesn't exist, it will be handled by the base view as:
.PP
.Vb 1
\&    [% INCLUDE view/default/header title=\*(AqHello World\*(Aq %]
.Ve
.PP
When a parent view is specified via the \f(CW\*(C`base\*(C'\fR parameter, the
delegation of a view to its parent for fetching templates and accessing
user defined variables is automatic.  You can also implement your own
inheritance, delegation or other reuse patterns by explicitly
delegating to other views.
.PP
.Vb 3
\&    [% BLOCK foo %]
\&       public foo block
\&    [% END %]
\&
\&    [% VIEW plain %]
\&       [% BLOCK foo %]
\&       <plain>[% PROCESS foo %]</plain>
\&       [% END %]
\&    [% END %]
\&
\&    [% VIEW fancy %]
\&       [% BLOCK foo %]
\&       [% plain.foo | replace(\*(Aqplain\*(Aq, \*(Aqfancy\*(Aq) %]
\&       [% END %]
\&    [% END %]
\&
\&    [% plain.foo %]     # <plain>public foo block</plain>
\&    [% fancy.foo %]     # <fancy>public foo block</fancy>
.Ve
.PP
Note that the regular \f(CW\*(C`INCLUDE/PROCESS/WRAPPER\*(C'\fR directives work entirely
independently of views and will always get the original, unaltered
template name rather than any local per-view definition.
.SS "Self-Reference"
.IX Subsection "Self-Reference"
A reference to the view object under definition is available with the
\&\f(CW\*(C`VIEW ... END\*(C'\fR block by its specified name and also by the special name
\&'\f(CW\*(C`view\*(C'\fR' (similar to the \f(CW\*(C`my $self = shift;\*(C'\fR in a Perl method or the
\&'\f(CW\*(C`this\*(C'\fR' pointer in \*(C+, etc).  The view is initially unsealed allowing
any data items to be defined and updated within the \f(CW\*(C`VIEW ... END\*(C'\fR
block.  The view is automatically sealed at the end of the definition
block, preventing any view data from being subsequently changed.
.PP
(\s-1NOTE:\s0 sealing should be optional.  As well as sealing a view to prevent
updates (\f(CW\*(C`SEALED\*(C'\fR), it should be possible to set an option in the view to
allow external contexts to update existing variables (\f(CW\*(C`UPDATE\*(C'\fR) or even
create totally new view variables (\f(CW\*(C`CREATE\*(C'\fR)).
.PP
.Vb 5
\&    [% VIEW fancy %]
\&       [% fancy.title  = \*(AqMy Fancy Title\*(Aq %]
\&       [% fancy.author = \*(AqFrank Open\*(Aq %]
\&       [% fancy.col    = { bg => \*(Aq#ffffff\*(Aq, bar => \*(Aq#a0a0ff\*(Aq } %]
\&    [% END %]
.Ve
.PP
or
.PP
.Vb 5
\&    [% VIEW fancy %]
\&       [% view.title  = \*(AqMy Fancy Title\*(Aq %]
\&       [% view.author = \*(AqFrank Open\*(Aq %]
\&       [% view.col    = { bg => \*(Aq#ffffff\*(Aq, bar => \*(Aq#a0a0ff\*(Aq } %]
\&    [% END %]
.Ve
.PP
It makes no real difference in this case if you refer to the view by
its name, '\f(CW\*(C`fancy\*(C'\fR', or by the general name, '\f(CW\*(C`view\*(C'\fR'.  Outside of the
view block, however, you should always use the given name, '\f(CW\*(C`fancy\*(C'\fR':
.PP
.Vb 3
\&    [% fancy.title  %]
\&    [% fancy.author %]
\&    [% fancy.col.bg %]
.Ve
.PP
The choice of given name or '\f(CW\*(C`view\*(C'\fR' is much more important when it
comes to \f(CW\*(C`BLOCK\*(C'\fR definitions within a \f(CW\*(C`VIEW\*(C'\fR.  It is generally recommended
that you use '\f(CW\*(C`view\*(C'\fR' inside a \f(CW\*(C`VIEW\*(C'\fR definition because this is guaranteed
to be correctly defined at any point in the future when the block gets
called.  The original name of the view might have long since been changed
or reused but the self-reference via '\f(CW\*(C`view\*(C'\fR' should always be intact and
valid.
.PP
Take the following \s-1VIEW\s0 as an example:
.PP
.Vb 6
\&    [% VIEW foo %]
\&       [% view.title = \*(AqHello World\*(Aq %]
\&       [% BLOCK header %]
\&       Title: [% view.title %]
\&       [% END %]
\&    [% END %]
.Ve
.PP
Even if we rename the view, or create a new \f(CW\*(C`foo\*(C'\fR variable, the header
block still correctly accesses the \f(CW\*(C`title\*(C'\fR attribute of the view to
which it belongs.  Whenever a view \f(CW\*(C`BLOCK\*(C'\fR is processed, the \f(CW\*(C`view\*(C'\fR
variable is always updated to contain the correct reference to the
view object to which it belongs.
.PP
.Vb 3
\&    [% bar = foo %]
\&    [% foo = { title => "New Foo" } %]  # no problem
\&    [% bar.header %]                    # => Title: Hello World
.Ve
.SS "Saving References to External Views"
.IX Subsection "Saving References to External Views"
When it comes to view inheritance, it's always a good idea to take a
local copy of a parent or delegate view and store it as an attribute
within the view for later use.  This ensures that the correct view
reference is always available, even if the external name of a view
has been changed.
.PP
.Vb 3
\&    [% VIEW plain %]
\&       ...
\&    [% END %]
\&
\&    [% VIEW fancy %]
\&       [% view.plain = plain %]
\&       [% BLOCK foo %]
\&       [% view.plain.foo | replace(\*(Aqplain\*(Aq, \*(Aqfancy\*(Aq) %]
\&       [% END %]
\&    [% END %]
\&
\&    [% plain.foo %]         # => <plain>public foo block</plain>
\&    [% plain = \*(Aqblah\*(Aq %]    # no problem
\&    [% fancy.foo %]         # => <fancy>public foo block</fancy>
.Ve
.SS "Views as Data Presenters"
.IX Subsection "Views as Data Presenters"
Another key role of a view is to act as a dispatcher to automatically
apply the correct template to present a particular object or data
item.  This is handled via the \f(CW\*(C`print()\*(C'\fR method.
.PP
Here's an example:
.PP
.Vb 1
\&    [% VIEW foo %]
\&
\&       [% BLOCK text %]
\&          Some text: [% item %]
\&       [% END %]
\&
\&       [% BLOCK hash %]
\&          a hash:
\&          [% FOREACH key = item.keys.sort \-%]
\&             [% key %] => [% item.$key %]
\&          [% END \-%]
\&       [% END %]
\&
\&       [% BLOCK list %]
\&          a list: [% item.sort.join(\*(Aq, \*(Aq) %]
\&       [% END %]
\&
\&    [% END %]
.Ve
.PP
We can now use the view to print text, hashes or lists.  The \f(CW\*(C`print()\*(C'\fR
method includes the right template depending on the typing of the
argument (or arguments) passed.
.PP
.Vb 3
\&    [% some_text = \*(AqI read the news today, oh boy.\*(Aq %]
\&    [% a_hash    = { house => \*(AqLords\*(Aq, hall => \*(AqAlbert\*(Aq } %]
\&    [% a_list    = [ \*(Aqsure\*(Aq, \*(AqNobody\*(Aq, \*(Aqreally\*(Aq ] %]
\&
\&    [% view.print(some_text) %]
\&                        # Some text: I read the news today, oh boy.
\&
\&    [% view.print(a_hash) %]
\&                        # a hash:
\&                             hall => Albert
\&                             house => Lords
\&    [% view.print(a_list) %]
\&                        # a list: Nobody, really, sure
.Ve
.PP
You can also provide templates to print objects of any other class.
The class name is mapped to a template name with all non-word
character sequences such as '\f(CW\*(C`::\*(C'\fR' converted to a single '\f(CW\*(C`_\*(C'\fR'.
.PP
.Vb 7
\&    [% VIEW foo %]
\&       [% BLOCK Foo_Bar %]
\&          a Foo::Bar object:
\&              thingies: [% view.print(item.thingies) %]
\&               doodahs: [% view.print(item.doodahs)  %]
\&       [% END %]
\&    [% END %]
\&
\&    [% USE fubar = Foo::Bar(...) %]
\&
\&    [% foo.print(fubar) %]
.Ve
.PP
Note how we use the view object to display various items within the
objects ('\f(CW\*(C`thingies\*(C'\fR' and '\f(CW\*(C`doodahs\*(C'\fR').  We don't need to worry what
kind of data these represent (text, list, hash, etc) because we can
let the view worry about it, automatically mapping the data type to
the correct template.
.PP
Views may define their own type => template map.
.PP
.Vb 11
\&    [% VIEW foo
\&         map = { TEXT  => \*(Aqplain_text\*(Aq,
\&                 ARRAY => \*(Aqshow_list\*(Aq,
\&                 HASH  => \*(Aqshow_hash\*(Aq,
\&                 My::Module => \*(Aqtemplate_name\*(Aq
\&                 default    => \*(Aqany_old_data\*(Aq
\&               }
\&    %]
\&        [% BLOCK plain_text %]
\&           ...
\&        [% END %]
\&
\&        ...
\&    [% END %]
.Ve
.PP
They can also provide a \f(CW\*(C`default\*(C'\fR map entry, specified as part of the \f(CW\*(C`map\*(C'\fR
hash or as a parameter by itself.
.PP
.Vb 6
\&    [% VIEW foo
\&         map     = { ... },
\&         default = \*(Aqwhatever\*(Aq
\&    %]
\&       ...
\&    [% END %]
.Ve
.PP
or
.PP
.Vb 6
\&    [% VIEW foo %]
\&       [% view.map     = { ... }
\&          view.default = \*(Aqwhatever\*(Aq
\&       %]
\&       ...
\&    [% END %]
.Ve
.PP
The \f(CW\*(C`print()\*(C'\fR method provides one more piece of magic. If you pass it a
reference to an object which provides a \f(CW\*(C`present()\*(C'\fR method, then the method
will be called passing the view as an argument. This then gives any object a
chance to determine how it should be presented via the view.
.PP
.Vb 8
\&    package Foo::Bar;
\&    ...
\&    sub present {
\&        my ($self, $view) = @_;
\&        return "a Foo::Bar object:\en"
\&             . "thingies: " . $view\->print($self\->{ _THINGIES }) . "\en"
\&             . "doodahs: " . $view\->print($self\->{ _DOODAHS }) . "\en";
\&    }
.Ve
.PP
The object is free to delve deeply into its innards and mess around with
its own private data, before presenting the relevant data via the view.
In a more complex example, a \f(CW\*(C`present()\*(C'\fR method might walk part of a tree
making calls back against the view to present different nodes within the
tree.  We may not want to expose the internal structure of the tree
(because that would break encapsulation and make our presentation code
dependant on it) but we want to have some way of walking the tree and
presenting items found in a particular manner.
.PP
This is known as \fIStructure Shy Traversal\fR.  Our view object doesn't require
prior knowledge about the internal structure of any data set to be able
to traverse it and present the data contained therein.  The data items
themselves, via the \f(CW\*(C`present()\*(C'\fR method, can implement the internal iterators
to guide the view along the right path to presentation happiness.
.PP
The upshot is that you can use views to greatly simplify the display
of data structures like \f(CW\*(C`XML::DOM\*(C'\fR trees.  The documentation for the
\&\f(CW\*(C`Template::Plugin::XML::DOM\*(C'\fR module contains an example of this.  In
essence, it looks something like this:
.PP
\&\s-1XML\s0 source:
.PP
.Vb 4
\&    <user name="Andy Wardley">
\&        <project id="iCan" title="iCan, but theyCan\*(Aqt"/>
\&        <project id="p45"  title="iDid, but theyDidn\*(Aqt"/>
\&    </user>
.Ve
.PP
\&\s-1TT\s0 View:
.PP
.Vb 5
\&    [% VIEW fancy %]
\&       [% BLOCK user %]
\&          User: [% item.name %]
\&                [% item.content(myview) %]
\&       [% END %]
\&
\&       [% BLOCK project %]
\&            Project: [% project.id %] \- [% project.name %]
\&       [% END %]
\&    [% END %]
.Ve
.PP
Generate view:
.PP
.Vb 2
\&    [% USE dom = XML.DOM %]
\&    [% fancy.print(dom.parse(xml_source)) %]
.Ve
.PP
Output:
.PP
.Vb 3
\&          User: Andy Wardley
\&            Project: iCan \- iCan, but theyCan\*(Aqt
\&            Project: p45 \- iDid, but theyDidn\*(Aqt
.Ve
.PP
The same approach can be applied to many other areas.  Here's an example from
the \f(CW\*(C`File\*(C'\fR/\f(CW\*(C`Directory\*(C'\fR plugins.
.PP
.Vb 4
\&    [% VIEW myview %]
\&       [% BLOCK file %]
\&          \- [% item.name %]
\&       [% END %]
\&
\&       [% BLOCK directory %]
\&          * [% item.name %]
\&            [% item.content(myview) FILTER indent %]
\&       [% END %]
\&    [% END %]
\&
\&    [% USE dir = Directory(dirpath) %]
\&    [% myview.print(dir) %]
.Ve
.PP
And here's the same approach use to convert \s-1POD\s0 documentation to any
other format via template.
.PP
.Vb 3
\&    [%  # load Pod plugin and parse source file into Pod Object Model
\&        USE Pod;
\&        pom = Pod.parse_file(my_pod_file);
\&
\&        # define view to map all Pod elements to "pod/html/xxx" templates
\&        VIEW pod2html
\&            prefix=\*(Aqpod/html\*(Aq;
\&        END;
\&
\&        # now print document via view (i.e. as HTML)
\&        pod2html.print(pom)
\&    %]
.Ve
.PP
Here we simply define a template prefix for the view which causes the
view to look for \f(CW\*(C`pod/html/head1\*(C'\fR, \f(CW\*(C`pod/html/head2\*(C'\fR, \f(CW\*(C`pod/html/over\*(C'\fR
as templates to present the different sections of the parsed Pod document.
.PP
There are some examples in the Template Toolkit test suite: \fIt/pod.t\fR and
\&\fIt/view.t\fR which may shed some more light on this.  See the distribution
sub-directory \fIexamples/pod/html\fR for examples of Pod \-> \s-1HTML\s0 templates.
