.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Template::Context 3"
.TH Template::Context 3 "2022-07-26" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Context \- Runtime context in which templates are processed
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Template::Context;
\&
\&    # constructor
\&    $context = Template::Context\->new(\e%config)
\&        || die $Template::Context::ERROR;
\&
\&    # fetch (load and compile) a template
\&    $template = $context\->template($template_name);
\&
\&    # fetch (load and instantiate) a plugin object
\&    $plugin = $context\->plugin($name, \e@args);
\&
\&    # fetch (return or create) a filter subroutine
\&    $filter = $context\->filter($name, \e@args, $alias);
\&
\&    # process/include a template, errors are thrown via die()
\&    $output = $context\->process($template, \e%vars);
\&    $output = $context\->include($template, \e%vars);
\&
\&    # raise an exception via die()
\&    $context\->throw($error_type, $error_message, \e$output_buffer);
\&
\&    # catch an exception, clean it up and fix output buffer
\&    $exception = $context\->catch($exception, \e$output_buffer);
\&
\&    # save/restore the stash to effect variable localisation
\&    $new_stash = $context\->localise(\e%vars);
\&    $old_stash = $context\->delocalise();
\&
\&    # add new BLOCK or FILTER definitions
\&    $context\->define_block($name, $block);
\&    $context\->define_filter($name, \e&filtersub, $is_dynamic);
\&
\&    # reset context, clearing any imported BLOCK definitions
\&    $context\->reset();
\&
\&    # methods for accessing internal items
\&    $stash     = $context\->stash();
\&    $tflag     = $context\->trim();
\&    $epflag    = $context\->eval_perl();
\&    $providers = $context\->templates();
\&    $providers = $context\->plugins();
\&    $providers = $context\->filters();
\&    ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Template::Context\*(C'\fR module defines an object class for representing
a runtime context in which templates are processed.  It provides an
interface to the fundamental operations of the Template Toolkit
processing engine through which compiled templates (i.e. Perl code
constructed from the template source) can process templates, load
plugins and filters, raise exceptions and so on.
.PP
A default \f(CW\*(C`Template::Context\*(C'\fR object is created by the Template module.
Any \f(CW\*(C`Template::Context\*(C'\fR options may be passed to the Template
\&\fBnew()\fR constructor method and will be forwarded to the
\&\f(CW\*(C`Template::Context\*(C'\fR constructor.
.PP
.Vb 1
\&    use Template;
\&
\&    my $template = Template\->new({
\&        TRIM      => 1,
\&        EVAL_PERL => 1,
\&        BLOCKS    => {
\&            header => \*(AqThis is the header\*(Aq,
\&            footer => \*(AqThis is the footer\*(Aq,
\&        },
\&    });
.Ve
.PP
Similarly, the \f(CW\*(C`Template::Context\*(C'\fR constructor will forward all configuration
parameters onto other default objects (e.g. Template::Provider,
Template::Plugins, Template::Filters, etc.) that it may need to
instantiate.
.PP
.Vb 4
\&    $context = Template::Context\->new({
\&        INCLUDE_PATH => \*(Aq/home/abw/templates\*(Aq, # provider option
\&        TAG_STYLE    => \*(Aqhtml\*(Aq,                # parser option
\&    });
.Ve
.PP
A \f(CW\*(C`Template::Context\*(C'\fR object (or subclass) can be explicitly instantiated and
passed to the Template \fBnew()\fR constructor method as the
\&\f(CW\*(C`CONTEXT\*(C'\fR configuration item.
.PP
.Vb 2
\&    use Template;
\&    use Template::Context;
\&
\&    my $context  = Template::Context\->new({ TRIM => 1 });
\&    my $template = Template\->new({ CONTEXT => $context });
.Ve
.PP
The Template module uses the Template::Config
\&\fBcontext()\fR factory method to create a default
context object when required. The \f(CW$Template::Config::CONTEXT\fR package
variable may be set to specify an alternate context module. This will be
loaded automatically and its \fBnew()\fR constructor method called by the
\&\fBcontext()\fR factory method when a default context
object is required.
.PP
.Vb 1
\&    use Template;
\&
\&    $Template::Config::CONTEXT = \*(AqMyOrg::Template::Context\*(Aq;
\&
\&    my $template = Template\->new({
\&        EVAL_PERL   => 1,
\&        EXTRA_MAGIC => \*(Aqred hot\*(Aq,  # your extra config items
\&        ...
\&    });
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new(\e%params)"
.IX Subsection "new(%params)"
The \f(CW\*(C`new()\*(C'\fR constructor method is called to instantiate a
\&\f(CW\*(C`Template::Context\*(C'\fR object. Configuration parameters may be specified as a
\&\s-1HASH\s0 reference or as a list of \f(CW\*(C`name => value\*(C'\fR pairs.
.PP
.Vb 4
\&    my $context = Template::Context\->new({
\&        INCLUDE_PATH => \*(Aqheader\*(Aq,
\&        POST_PROCESS => \*(Aqfooter\*(Aq,
\&    });
\&
\&    my $context = Template::Context\->new( EVAL_PERL => 1 );
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method returns a \f(CW\*(C`Template::Context\*(C'\fR object or \f(CW\*(C`undef\*(C'\fR on
error. In the latter case, a relevant error message can be retrieved by the
\&\fBerror()\fR class method or directly from the
\&\f(CW$Template::Context::ERROR\fR package variable.
.PP
.Vb 2
\&    my $context = Template::Context\->new(\e%config)
\&        || die Template::Context\->error();
\&
\&    my $context = Template::Context\->new(\e%config)
\&        || die $Template::Context::ERROR;
.Ve
.PP
The following configuration items may be specified.  Please see
Template::Manual::Config for further details.
.PP
\fI\s-1VARIABLES\s0\fR
.IX Subsection "VARIABLES"
.PP
The \s-1VARIABLES\s0 option can be used to
specify a hash array of template variables.
.PP
.Vb 7
\&    my $context = Template::Context\->new({
\&        VARIABLES => {
\&            title   => \*(AqA Demo Page\*(Aq,
\&            author  => \*(AqJoe Random Hacker\*(Aq,
\&            version => 3.14,
\&        },
\&    };
.Ve
.PP
\fI\s-1BLOCKS\s0\fR
.IX Subsection "BLOCKS"
.PP
The \s-1BLOCKS\s0 option can be used to pre-define
a default set of template blocks.
.PP
.Vb 7
\&    my $context = Template::Context\->new({
\&        BLOCKS => {
\&            header  => \*(AqThe Header.  [% title %]\*(Aq,
\&            footer  => sub { return $some_output_text },
\&            another => Template::Document\->new({ ... }),
\&        },
\&    });
.Ve
.PP
\fI\s-1VIEWS\s0\fR
.IX Subsection "VIEWS"
.PP
The \s-1VIEWS\s0 option can be used to pre-define
one or more Template::View objects.
.PP
.Vb 7
\&    my $context = Template::Context\->new({
\&        VIEWS => [
\&            bottom => { prefix => \*(Aqbottom/\*(Aq },
\&            middle => { prefix => \*(Aqmiddle/\*(Aq, base => \*(Aqbottom\*(Aq },
\&            top    => { prefix => \*(Aqtop/\*(Aq,    base => \*(Aqmiddle\*(Aq },
\&        ],
\&    });
.Ve
.PP
\fI\s-1TRIM\s0\fR
.IX Subsection "TRIM"
.PP
The \s-1TRIM\s0 option can be set to have any
leading and trailing whitespace automatically removed from the output of all
template files and \f(CW\*(C`BLOCK\*(C'\fRs.
.PP
example:
.PP
.Vb 1
\&    [% BLOCK foo %]
\&
\&    Line 1 of foo
\&
\&    [% END %]
\&
\&    before
\&    [% INCLUDE foo %]
\&    after
.Ve
.PP
output:
.PP
.Vb 3
\&    before
\&    Line 1 of foo
\&    after
.Ve
.PP
\fI\s-1EVAL_PERL\s0\fR
.IX Subsection "EVAL_PERL"
.PP
The \s-1EVAL_PERL\s0 is used to indicate if
\&\f(CW\*(C`PERL\*(C'\fR and/or \f(CW\*(C`RAWPERL\*(C'\fR blocks should be evaluated. It is disabled by
default.
.PP
\fI\s-1RECURSION\s0\fR
.IX Subsection "RECURSION"
.PP
The \s-1RECURSION\s0 can be set to
allow templates to recursively process themselves, either directly
(e.g. template \f(CW\*(C`foo\*(C'\fR calls \f(CW\*(C`INCLUDE foo\*(C'\fR) or indirectly (e.g.
\&\f(CW\*(C`foo\*(C'\fR calls \f(CW\*(C`INCLUDE bar\*(C'\fR which calls \f(CW\*(C`INCLUDE foo\*(C'\fR).
.PP
\fI\s-1LOAD_TEMPLATES\s0\fR
.IX Subsection "LOAD_TEMPLATES"
.PP
The \s-1LOAD_TEMPLATES\s0 option can be
used to provide a reference to a list of Template::Provider objects or
sub-classes thereof which will take responsibility for loading and compiling
templates.
.PP
.Vb 6
\&    my $context = Template::Context\->new({
\&        LOAD_TEMPLATES => [
\&            MyOrg::Template::Provider\->new({ ... }),
\&            Template::Provider\->new({ ... }),
\&        ],
\&    });
.Ve
.PP
\fI\s-1LOAD_PLUGINS\s0\fR
.IX Subsection "LOAD_PLUGINS"
.PP
The \s-1LOAD_PLUGINS\s0 options can be used
to specify a list of provider objects responsible for loading and
instantiating template plugin objects.
.PP
.Vb 6
\&    my $context = Template::Context\->new({
\&        LOAD_PLUGINS => [
\&            MyOrg::Template::Plugins\->new({ ... }),
\&            Template::Plugins\->new({ ... }),
\&        ],
\&    });
.Ve
.PP
\fI\s-1LOAD_FILTERS\s0\fR
.IX Subsection "LOAD_FILTERS"
.PP
The \s-1LOAD_FILTERS\s0 option can be used
to specify a list of provider objects for returning and/or creating filter
subroutines.
.PP
.Vb 6
\&    my $context = Template::Context\->new({
\&        LOAD_FILTERS => [
\&            MyTemplate::Filters\->new(),
\&            Template::Filters\->new(),
\&        ],
\&    });
.Ve
.PP
\fI\s-1STASH\s0\fR
.IX Subsection "STASH"
.PP
The \s-1STASH\s0 option can be used to
specify a Template::Stash object or sub-class which will take
responsibility for managing template variables.
.PP
.Vb 4
\&    my $stash = MyOrg::Template::Stash\->new({ ... });
\&    my $context = Template::Context\->new({
\&        STASH => $stash,
\&    });
.Ve
.PP
\fI\s-1DEBUG\s0\fR
.IX Subsection "DEBUG"
.PP
The \s-1DEBUG\s0 option can be used to enable
various debugging features of the Template::Context module.
.PP
.Vb 1
\&    use Template::Constants qw( :debug );
\&
\&    my $template = Template\->new({
\&        DEBUG => DEBUG_CONTEXT | DEBUG_DIRS,
\&    });
.Ve
.SS "template($name)"
.IX Subsection "template($name)"
Returns a compiled template by querying each of the \s-1LOAD_TEMPLATES\s0 providers
(instances of Template::Provider, or sub-class) in turn.
.PP
.Vb 1
\&    $template = $context\->template(\*(Aqheader\*(Aq);
.Ve
.PP
On error, a Template::Exception object of type '\f(CW\*(C`file\*(C'\fR' is thrown via
\&\f(CW\*(C`die()\*(C'\fR.  This can be caught by enclosing the call to \f(CW\*(C`template()\*(C'\fR in an
\&\f(CW\*(C`eval\*(C'\fR block and examining \f(CW$@\fR.
.PP
.Vb 4
\&    eval { $template = $context\->template(\*(Aqheader\*(Aq) };
\&    if ($@) {
\&        print "failed to fetch template: $@\en";
\&    }
.Ve
.SS "plugin($name, \e@args)"
.IX Subsection "plugin($name, @args)"
Instantiates a plugin object by querying each of the \s-1LOAD_PLUGINS\s0
providers. The default \s-1LOAD_PLUGINS\s0 provider is a Template::Plugins
object which attempts to load plugin modules, according the various
configuration items such as \s-1PLUGIN_BASE\s0,
\&\s-1LOAD_PERL\s0, etc., and then instantiate an object
via \fBnew()\fR. A reference to a list of constructor
arguments may be passed as the second parameter. These are forwarded to the
plugin constructor.
.PP
Returns a reference to a plugin (which is generally an object, but
doesn't have to be).  Errors are thrown as Template::Exception objects
with the type set to '\f(CW\*(C`plugin\*(C'\fR'.
.PP
.Vb 1
\&    $plugin = $context\->plugin(\*(AqDBI\*(Aq, \*(Aqdbi:msql:mydbname\*(Aq);
.Ve
.ie n .SS "filter($name, \e@args, $alias)"
.el .SS "filter($name, \e@args, \f(CW$alias\fP)"
.IX Subsection "filter($name, @args, $alias)"
Instantiates a filter subroutine by querying the \s-1LOAD_FILTERS\s0 providers.
The default \s-1LOAD_FILTERS\s0 provider is a Template::Filters object.
.PP
Additional arguments may be passed by list reference along with an optional
alias under which the filter will be cached for subsequent use. The filter is
cached under its own \f(CW$name\fR if \f(CW$alias\fR is undefined. Subsequent calls to
\&\f(CW\*(C`filter($name)\*(C'\fR will return the cached entry, if defined. Specifying arguments
bypasses the caching mechanism and always creates a new filter. Errors are
thrown as Template::Exception objects with the type set to '\f(CW\*(C`filter\*(C'\fR'.
.PP
.Vb 2
\&    # static filter (no args)
\&    $filter = $context\->filter(\*(Aqhtml\*(Aq);
\&
\&    # dynamic filter (args) aliased to \*(Aqpadright\*(Aq
\&    $filter = $context\->filter(\*(Aqformat\*(Aq, \*(Aq%60s\*(Aq, \*(Aqpadright\*(Aq);
\&
\&    # retrieve previous filter via \*(Aqpadright\*(Aq alias
\&    $filter = $context\->filter(\*(Aqpadright\*(Aq);
.Ve
.SS "process($template, \e%vars)"
.IX Subsection "process($template, %vars)"
Processes a template named or referenced by the first parameter and returns
the output generated.  An optional reference to a hash array may be passed
as the second parameter, containing variable definitions which will be set
before the template is processed.  The template is processed in the current
context, with no localisation of variables performed.   Errors are thrown
as Template::Exception objects via \f(CW\*(C`die()\*(C'\fR.
.PP
.Vb 1
\&    $output = $context\->process(\*(Aqheader\*(Aq, { title => \*(AqHello World\*(Aq });
.Ve
.SS "include($template, \e%vars)"
.IX Subsection "include($template, %vars)"
Similar to \fBprocess()\fR, but using localised variables.  Changes made to
any variables will only persist until the \f(CW\*(C`include()\*(C'\fR method completes.
.PP
.Vb 1
\&    $output = $context\->include(\*(Aqheader\*(Aq, { title => \*(AqHello World\*(Aq });
.Ve
.SS "insert($template)"
.IX Subsection "insert($template)"
This method returns the source content of a template file without performing
any evaluation.  It is used to implement the \f(CW\*(C`INSERT\*(C'\fR directive.
.ie n .SS "throw($error_type, $error_message, \e$output)"
.el .SS "throw($error_type, \f(CW$error_message\fP, \e$output)"
.IX Subsection "throw($error_type, $error_message, $output)"
Raises an exception in the form of a Template::Exception object by calling
\&\f(CW\*(C`die()\*(C'\fR. This method may be passed a reference to an existing
Template::Exception object; a single value containing an error message
which is used to instantiate a Template::Exception of type '\f(CW\*(C`undef\*(C'\fR'; or a
pair of values representing the exception \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`info\*(C'\fR from which a
Template::Exception object is instantiated. e.g.
.PP
.Vb 3
\&    $context\->throw($exception);
\&    $context\->throw("I\*(Aqm sorry Dave, I can\*(Aqt do that");
\&    $context\->throw(\*(Aqdenied\*(Aq, "I\*(Aqm sorry Dave, I can\*(Aqt do that");
.Ve
.PP
The optional third parameter may be a reference to the current output
buffer.  This is then stored in the exception object when created,
allowing the catcher to examine and use the output up to the point at
which the exception was raised.
.PP
.Vb 3
\&    $output .= \*(Aqblah blah blah\*(Aq;
\&    $output .= \*(Aqmore rhubarb\*(Aq;
\&    $context\->throw(\*(Aqyack\*(Aq, \*(AqToo much yacking\*(Aq, \e$output);
.Ve
.SS "catch($exception, \e$output)"
.IX Subsection "catch($exception, $output)"
Catches an exception thrown, either as a reference to a Template::Exception
object or some other value. In the latter case, the error string is promoted
to a Template::Exception object of '\f(CW\*(C`undef\*(C'\fR' type. This method also
accepts a reference to the current output buffer which is passed to the
Template::Exception constructor, or is appended to the output buffer stored
in an existing Template::Exception object, if unique (i.e. not the same
reference). By this process, the correct state of the output buffer can be
reconstructed for simple or nested throws.
.ie n .SS "define_block($name, $block)"
.el .SS "define_block($name, \f(CW$block\fP)"
.IX Subsection "define_block($name, $block)"
Adds a new block definition to the internal \s-1BLOCKS\s0 cache.  The first
argument should contain the name of the block and the second a reference
to a Template::Document object or template sub-routine, or template text
which is automatically compiled into a template sub-routine.
.PP
Returns a true value (the sub-routine or Template::Document reference) on
success or undef on failure. The relevant error message can be retrieved by
calling the \fBerror()\fR method.
.ie n .SS "define_filter($name, \e&filter, $is_dynamic)"
.el .SS "define_filter($name, \e&filter, \f(CW$is_dynamic\fP)"
.IX Subsection "define_filter($name, &filter, $is_dynamic)"
Adds a new filter definition by calling the
\&\fBstore()\fR method on each of the \s-1LOAD_FILTERS\s0
providers until accepted (in the usual case, this is accepted straight away by
the one and only Template::Filters provider). The first argument should
contain the name of the filter and the second a reference to a filter
subroutine. The optional third argument can be set to any true value to
indicate that the subroutine is a dynamic filter factory.
.PP
Returns a true value or throws a '\f(CW\*(C`filter\*(C'\fR' exception on error.
.ie n .SS "define_vmethod($type, $name, $code)"
.el .SS "define_vmethod($type, \f(CW$name\fP, \f(CW$code\fP)"
.IX Subsection "define_vmethod($type, $name, $code)"
This method is a wrapper around the Template::Stash
\&\fBdefine_vmethod()\fR method.  It can be used
to define new virtual methods.
.PP
.Vb 7
\&    # define a new scalar (item) virtual method
\&    $context\->define_vmethod(
\&        item => ucfirst => sub {
\&            my $text = shift;
\&            return ucfirst $text;
\&        }
\&    )
.Ve
.SS "define_view($name, \e%params)"
.IX Subsection "define_view($name, %params)"
This method allows you to define a named view.
.PP
.Vb 5
\&    $context\->define_view(
\&        my_view => {
\&            prefix => \*(Aqmy_templates/\*(Aq
\&        }
\&    );
.Ve
.PP
The view is then accessible as a template variable.
.PP
.Vb 1
\&    [% my_view.print(some_data) %]
.Ve
.SS "define_views($views)"
.IX Subsection "define_views($views)"
This method allows you to define multiple named views.
A reference to a hash array or list reference should be passed as an argument.
.PP
.Vb 8
\&    $context\->define_view({     # hash reference
\&        my_view_one => {
\&            prefix => \*(Aqmy_templates_one/\*(Aq
\&        },
\&        my_view_two => {
\&            prefix => \*(Aqmy_templates_two/\*(Aq
\&        }
\&    });
.Ve
.PP
If you're defining multiple views of which one or more are based on other
views in the same definition then you should pass them as a list reference.
This ensures that they get created in the right order (Perl does not preserve
the order of items defined in a hash reference so you can't guarantee that
your base class view will be defined before your subclass view).
.PP
.Vb 9
\&    $context\->define_view([     # list referenence
\&        my_view_one => {
\&            prefix => \*(Aqmy_templates_one/\*(Aq
\&        },
\&        my_view_two => {
\&            prefix => \*(Aqmy_templates_two/\*(Aq ,
\&            base   => \*(Aqmy_view_one\*(Aq,
\&        }
\&    ]);
.Ve
.PP
The views are then accessible as template variables.
.PP
.Vb 2
\&    [% my_view_one.print(some_data) %]
\&    [% my_view_two.print(some_data) %]
.Ve
.PP
See also the \s-1VIEWS\s0 option.
.SS "\fBstash()\fP"
.IX Subsection "stash()"
This method returns the Template::Stash object used internally to manage
template variables.
.SS "localise(\e%vars)"
.IX Subsection "localise(%vars)"
Clones the stash to create a context with localised variables.  Returns a
reference to the newly cloned stash object which is also stored
internally.
.PP
.Vb 1
\&    $stash = $context\->localise();
.Ve
.SS "\fBdelocalise()\fP"
.IX Subsection "delocalise()"
Restore the stash to its state prior to localisation.
.PP
.Vb 1
\&    $stash = $context\->delocalise();
.Ve
.SS "visit(\e%blocks)"
.IX Subsection "visit(%blocks)"
This method is called by Template::Document objects immediately before
they process their content.  It is called to register any local \f(CW\*(C`BLOCK\*(C'\fR
definitions with the context object so that they may be subsequently
delivered on request.
.SS "\fBleave()\fP"
.IX Subsection "leave()"
Compliment to the \fBvisit()\fR method. Called by Template::Document objects
immediately after they process their content.
.SS "\fBview()\fP"
.IX Subsection "view()"
This method creates a Template::View object bound to the context.
.SS "\fBreset()\fP"
.IX Subsection "reset()"
Clears the local \s-1BLOCKS\s0 cache of any \f(CW\*(C`BLOCK\*(C'\fR definitions.  Any initial set of
\&\s-1BLOCKS\s0 specified as a configuration item to the constructor will be reinstated.
.ie n .SS "debugging($flag, @args)"
.el .SS "debugging($flag, \f(CW@args\fP)"
.IX Subsection "debugging($flag, @args)"
This method is used to control debugging output.  It is used to implement
the \s-1DEBUG\s0 directive.
.PP
The first argument can be \f(CW\*(C`on\*(C'\fR or \f(CW\*(C`off\*(C'\fR to enable or disable debugging
respectively.  The numerical values \f(CW0\fR and \f(CW1\fR can also be used if you
prefer.
.PP
.Vb 1
\&    $context\->debugging(\*(Aqon\*(Aq);
.Ve
.PP
Alternately, the first argument can be \f(CW\*(C`format\*(C'\fR to define a new debug message
format.  The second argument should be the format string which can contain
any of the \f(CW$file\fR, \f(CW$line\fR or \f(CW$text\fR symbols to indicate where the
relevant values should be inserted.
.PP
.Vb 2
\&    # note single quotes to prevent interpolated of variables
\&    $context\->debugging( format => \*(Aq## $file line $line: $text\*(Aq );
.Ve
.PP
The final use of this method is to generate debugging messages themselves.
The first argument should be \f(CW\*(C`msg\*(C'\fR, followed by a reference to a hash array
of value to insert into the debugging format string.
.PP
.Vb 7
\&    $context\->debugging(
\&        msg => {
\&            line => 20,
\&            file => \*(Aqexample.tt\*(Aq,
\&            text => \*(AqTrampoline! Trampoline!\*(Aq,
\&        }
\&    );
.Ve
.SS "\s-1AUTOLOAD\s0"
.IX Subsection "AUTOLOAD"
An \f(CW\*(C`AUTOLOAD\*(C'\fR method provides access to context configuration items.
.PP
.Vb 4
\&    $stash     = $context\->stash();
\&    $tflag     = $context\->trim();
\&    $epflag    = $context\->eval_perl();
\&    ...
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org> <http://wardley.org/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1996\-2022 Andy Wardley.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Document, Template::Exception,
Template::Filters, Template::Plugins, Template::Provider,
Template::Service, Template::Stash
