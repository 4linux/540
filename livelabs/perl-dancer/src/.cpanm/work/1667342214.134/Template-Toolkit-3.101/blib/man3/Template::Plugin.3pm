.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Template::Plugin 3"
.TH Template::Plugin 3 "2022-07-26" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Plugin \- Base class for Template Toolkit plugins
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    package MyOrg::Template::Plugin::MyPlugin;
\&    use base qw( Template::Plugin );
\&    use Template::Plugin;
\&    use MyModule;
\&
\&    sub new {
\&        my $class   = shift;
\&        my $context = shift;
\&        bless {
\&            ...
\&        }, $class;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \*(L"plugin\*(R" for the Template Toolkit is simply a Perl module which
exists in a known package location (e.g. \f(CW\*(C`Template::Plugin::*\*(C'\fR) and
conforms to a regular standard, allowing it to be loaded and used
automatically.
.PP
The \f(CW\*(C`Template::Plugin\*(C'\fR module defines a base class from which other
plugin modules can be derived.  A plugin does not have to be derived
from Template::Plugin but should at least conform to its object-oriented
interface.
.PP
It is recommended that you create plugins in your own package namespace
to avoid conflict with toolkit plugins.  e.g.
.PP
.Vb 1
\&    package MyOrg::Template::Plugin::FooBar;
.Ve
.PP
Use the \s-1PLUGIN_BASE\s0 option to specify
the namespace that you use. e.g.
.PP
.Vb 4
\&    use Template;
\&    my $template = Template\->new({
\&        PLUGIN_BASE => \*(AqMyOrg::Template::Plugin\*(Aq,
\&    });
.Ve
.SH "METHODS"
.IX Header "METHODS"
The following methods form the basic interface between the Template
Toolkit and plugin modules.
.SS "load($context)"
.IX Subsection "load($context)"
This method is called by the Template Toolkit when the plugin module
is first loaded.  It is called as a package method and thus implicitly
receives the package name as the first parameter.  A reference to the
Template::Context object loading the plugin is also passed.  The
default behaviour for the \f(CW\*(C`load()\*(C'\fR method is to simply return the class
name.  The calling context then uses this class name to call the \f(CW\*(C`new()\*(C'\fR
package method.
.PP
.Vb 1
\&    package MyPlugin;
\&
\&    sub load {               # called as MyPlugin\->load($context)
\&        my ($class, $context) = @_;
\&        return $class;       # returns \*(AqMyPlugin\*(Aq
\&    }
.Ve
.ie n .SS "new($context, @params)"
.el .SS "new($context, \f(CW@params\fP)"
.IX Subsection "new($context, @params)"
This method is called to instantiate a new plugin object for the \f(CW\*(C`USE\*(C'\fR
directive. It is called as a package method against the class name returned by
\&\fBload()\fR. A reference to the Template::Context object creating the plugin
is passed, along with any additional parameters specified in the \f(CW\*(C`USE\*(C'\fR
directive.
.PP
.Vb 6
\&    sub new {                # called as MyPlugin\->new($context)
\&        my ($class, $context, @params) = @_;
\&        bless {
\&            _CONTEXT => $context,
\&        }, $class;           # returns blessed MyPlugin object
\&    }
.Ve
.SS "error($error)"
.IX Subsection "error($error)"
This method, inherited from the Template::Base module, is used for
reporting and returning errors.   It can be called as a package method
to set/return the \f(CW$ERROR\fR package variable, or as an object method to
set/return the object \f(CW\*(C`_ERROR\*(C'\fR member.  When called with an argument, it
sets the relevant variable and returns \f(CW\*(C`undef.\*(C'\fR  When called without an
argument, it returns the value of the variable.
.PP
.Vb 2
\&    package MyPlugin;
\&    use base \*(AqTemplate::Plugin\*(Aq;
\&
\&    sub new {
\&        my ($class, $context, $dsn) = @_;
\&
\&        return $class\->error(\*(AqNo data source specified\*(Aq)
\&            unless $dsn;
\&
\&        bless {
\&            _DSN => $dsn,
\&        }, $class;
\&    }
\&
\&    package main;
\&
\&    my $something = MyPlugin\->new()
\&        || die MyPlugin\->error(), "\en";
\&
\&    $something\->do_something()
\&        || die $something\->error(), "\en";
.Ve
.SH "DEEPER MAGIC"
.IX Header "DEEPER MAGIC"
The Template::Context object that handles the loading and use of plugins
calls the \fBnew()\fR and \fBerror()\fR methods against the package name returned by
the \fBload()\fR method. In pseudo-code terms looks something like this:
.PP
.Vb 1
\&    $class  = MyPlugin\->load($context);       # returns \*(AqMyPlugin\*(Aq
\&
\&    $object = $class\->new($context, @params)  # MyPlugin\->new(...)
\&        || die $class\->error();               # MyPlugin\->error()
.Ve
.PP
The \fBload()\fR method may alternately return a blessed reference to an
object instance.  In this case, \fBnew()\fR and \fBerror()\fR are then called as
\&\fIobject\fR methods against that prototype instance.
.PP
.Vb 1
\&    package YourPlugin;
\&
\&    sub load {
\&        my ($class, $context) = @_;
\&        bless {
\&            _CONTEXT => $context,
\&        }, $class;
\&    }
\&
\&    sub new {
\&        my ($self, $context, @params) = @_;
\&        return $self;
\&    }
.Ve
.PP
In this example, we have implemented a 'Singleton' plugin.  One object
gets created when \fBload()\fR is called and this simply returns itself for
each call to \fBnew()\fR.
.PP
Another implementation might require individual objects to be created
for every call to \fBnew()\fR, but with each object sharing a reference to
some other object to maintain cached data, database handles, etc.
This pseudo-code example demonstrates the principle.
.PP
.Vb 1
\&    package MyServer;
\&
\&    sub load {
\&        my ($class, $context) = @_;
\&        bless {
\&            _CONTEXT => $context,
\&            _CACHE   => { },
\&        }, $class;
\&    }
\&
\&    sub new {
\&        my ($self, $context, @params) = @_;
\&        MyClient\->new($self, @params);
\&    }
\&
\&    sub add_to_cache   { ... }
\&
\&    sub get_from_cache { ... }
\&
\&    package MyClient;
\&
\&    sub new {
\&        my ($class, $server, $blah) = @_;
\&        bless {
\&            _SERVER => $server,
\&            _BLAH   => $blah,
\&        }, $class;
\&    }
\&
\&    sub get {
\&        my $self = shift;
\&        $self\->{ _SERVER }\->get_from_cache(@_);
\&    }
\&
\&    sub put {
\&        my $self = shift;
\&        $self\->{ _SERVER }\->add_to_cache(@_);
\&    }
.Ve
.PP
When the plugin is loaded, a \f(CW\*(C`MyServer\*(C'\fR instance is created. The \fBnew()\fR
method is called against this object which instantiates and returns a \f(CW\*(C`MyClient\*(C'\fR
object, primed to communicate with the creating \f(CW\*(C`MyServer\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org> <http://wardley.org/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1996\-2022 Andy Wardley.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Plugins, Template::Context
