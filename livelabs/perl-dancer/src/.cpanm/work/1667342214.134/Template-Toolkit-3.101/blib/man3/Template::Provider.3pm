.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Template::Provider 3"
.TH Template::Provider 3 "2022-07-26" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Provider \- Provider module for loading/compiling templates
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    $provider = Template::Provider\->new(\e%options);
\&
\&    ($template, $error) = $provider\->fetch($name);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Template::Provider is used to load, parse, compile and cache template
documents. This object may be sub-classed to provide more specific facilities
for loading, or otherwise providing access to templates.
.PP
The Template::Context objects maintain a list of Template::Provider
objects which are polled in turn (via \fBfetch()\fR) to
return a requested template. Each may return a compiled template, raise an
error, or decline to serve the request, giving subsequent providers a chance
to do so.
.PP
The Template::Provider can also be subclassed to provide templates from
a different source, e.g. a database. See \s-1SUBCLASSING\s0 below.
.PP
This documentation needs work.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.SS "new(\e%options)"
.IX Subsection "new(%options)"
Constructor method which instantiates and returns a new \f(CW\*(C`Template::Provider\*(C'\fR
object.  A reference to a hash array of configuration options may be passed.
.PP
See \*(L"\s-1CONFIGURATION OPTIONS\*(R"\s0 below for a summary of configuration options
and Template::Manual::Config for full details.
.SS "fetch($name)"
.IX Subsection "fetch($name)"
Returns a compiled template for the name specified. If the template cannot be
found then \f(CW\*(C`(undef, STATUS_DECLINED)\*(C'\fR is returned. If an error occurs (e.g.
read error, parse error) then \f(CW\*(C`($error, STATUS_ERROR)\*(C'\fR is returned, where
\&\f(CW$error\fR is the error message generated. If the \s-1TOLERANT\s0 option is set the
the method returns \f(CW\*(C`(undef, STATUS_DECLINED)\*(C'\fR instead of returning an error.
.SS "load($name)"
.IX Subsection "load($name)"
Loads a template without parsing or compiling it.  This is used by the
the \s-1INSERT\s0 directive.
.ie n .SS "store($name, $template)"
.el .SS "store($name, \f(CW$template\fP)"
.IX Subsection "store($name, $template)"
Stores the compiled template, \f(CW$template\fR, in the cache under the name,
\&\f(CW$name\fR.  Susbequent calls to \f(CW\*(C`fetch($name)\*(C'\fR will return this template in
preference to any disk-based file.
.SS "include_path(\e@newpath)"
.IX Subsection "include_path(@newpath)"
Accessor method for the \f(CW\*(C`INCLUDE_PATH\*(C'\fR setting.  If called with an
argument, this method will replace the existing \f(CW\*(C`INCLUDE_PATH\*(C'\fR with
the new value.
.SS "\fBpaths()\fP"
.IX Subsection "paths()"
This method generates a copy of the \f(CW\*(C`INCLUDE_PATH\*(C'\fR list.  Any elements in the
list which are dynamic generators (e.g. references to subroutines or objects
implementing a \f(CW\*(C`paths()\*(C'\fR method) will be called and the list of directories
returned merged into the output list.
.PP
It is possible to provide a generator which returns itself, thus sending
this method into an infinite loop.  To detect and prevent this from happening,
the \f(CW$MAX_DIRS\fR package variable, set to \f(CW64\fR by default, limits the maximum
number of paths that can be added to, or generated for the output list.  If
this number is exceeded then the method will immediately return an error
reporting as much.
.SH "CONFIGURATION OPTIONS"
.IX Header "CONFIGURATION OPTIONS"
The following list summarises the configuration options that can be provided
to the \f(CW\*(C`Template::Provider\*(C'\fR \fBnew()\fR constructor. Please consult
Template::Manual::Config for further details and examples of each
configuration option in use.
.SS "\s-1INCLUDE_PATH\s0"
.IX Subsection "INCLUDE_PATH"
The \s-1INCLUDE_PATH\s0 option is used to
specify one or more directories in which template files are located.
.PP
.Vb 4
\&    # single path
\&    my $provider = Template::Provider\->new({
\&        INCLUDE_PATH => \*(Aq/usr/local/templates\*(Aq,
\&    });
\&
\&    # multiple paths
\&    my $provider = Template::Provider\->new({
\&        INCLUDE_PATH => [ \*(Aq/usr/local/templates\*(Aq,
\&                          \*(Aq/tmp/my/templates\*(Aq ],
\&    });
.Ve
.SS "\s-1ABSOLUTE\s0"
.IX Subsection "ABSOLUTE"
The \s-1ABSOLUTE\s0 flag is used to indicate if
templates specified with absolute filenames (e.g. '\f(CW\*(C`/foo/bar\*(C'\fR') should be
processed. It is disabled by default and any attempt to load a template by
such a name will cause a '\f(CW\*(C`file\*(C'\fR' exception to be raised.
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        ABSOLUTE => 1,
\&    });
.Ve
.SS "\s-1RELATIVE\s0"
.IX Subsection "RELATIVE"
The \s-1RELATIVE\s0 flag is used to indicate if
templates specified with filenames relative to the current directory (e.g.
\&\f(CW\*(C`./foo/bar\*(C'\fR or \f(CW\*(C`../../some/where/else\*(C'\fR) should be loaded. It is also disabled
by default, and will raise a \f(CW\*(C`file\*(C'\fR error if such template names are
encountered.
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        RELATIVE => 1,
\&    });
.Ve
.SS "\s-1DEFAULT\s0"
.IX Subsection "DEFAULT"
The \s-1DEFAULT\s0 option can be used to specify
a default template which should be used whenever a specified template can't be
found in the \s-1INCLUDE_PATH\s0.
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        DEFAULT => \*(Aqnotfound.html\*(Aq,
\&    });
.Ve
.PP
If a non-existant template is requested through the Template
\&\fBprocess()\fR method, or by an \f(CW\*(C`INCLUDE\*(C'\fR, \f(CW\*(C`PROCESS\*(C'\fR or
\&\f(CW\*(C`WRAPPER\*(C'\fR directive, then the \f(CW\*(C`DEFAULT\*(C'\fR template will instead be processed, if
defined. Note that the \f(CW\*(C`DEFAULT\*(C'\fR template is not used when templates are
specified with absolute or relative filenames, or as a reference to a input
file handle or text string.
.SS "\s-1ENCODING\s0"
.IX Subsection "ENCODING"
The Template Toolkit will automatically decode Unicode templates that
have a Byte Order Marker (\s-1BOM\s0) at the start of the file.  This option
can be used to set the default encoding for templates that don't define
a \s-1BOM.\s0
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        ENCODING => \*(Aqutf8\*(Aq,
\&    });
.Ve
.PP
See Encode for further information.
.SS "\s-1CACHE_SIZE\s0"
.IX Subsection "CACHE_SIZE"
The \s-1CACHE_SIZE\s0 option can be used to
limit the number of compiled templates that the module should cache. By
default, the \s-1CACHE_SIZE\s0 is undefined
and all compiled templates are cached.
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        CACHE_SIZE => 64,   # only cache 64 compiled templates
\&    });
.Ve
.SS "\s-1STAT_TTL\s0"
.IX Subsection "STAT_TTL"
The \s-1STAT_TTL\s0 value can be set to control
how long the \f(CW\*(C`Template::Provider\*(C'\fR will keep a template cached in memory
before checking to see if the source template has changed.
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        STAT_TTL => 60,  # one minute
\&    });
.Ve
.SS "\s-1COMPILE_EXT\s0"
.IX Subsection "COMPILE_EXT"
The \s-1COMPILE_EXT\s0 option can be
provided to specify a filename extension for compiled template files.
It is undefined by default and no attempt will be made to read or write
any compiled template files.
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        COMPILE_EXT => \*(Aq.ttc\*(Aq,
\&    });
.Ve
.SS "\s-1COMPILE_DIR\s0"
.IX Subsection "COMPILE_DIR"
The \s-1COMPILE_DIR\s0 option is used to
specify an alternate directory root under which compiled template files should
be saved.
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        COMPILE_DIR => \*(Aq/tmp/ttc\*(Aq,
\&    });
.Ve
.SS "\s-1TOLERANT\s0"
.IX Subsection "TOLERANT"
The \s-1TOLERANT\s0 flag can be set to indicate
that the \f(CW\*(C`Template::Provider\*(C'\fR module should ignore any errors encountered while
loading a template and instead return \f(CW\*(C`STATUS_DECLINED\*(C'\fR.
.SS "\s-1PARSER\s0"
.IX Subsection "PARSER"
The \s-1PARSER\s0 option can be used to define
a parser module other than the default of Template::Parser.
.PP
.Vb 3
\&    my $provider = Template::Provider\->new({
\&        PARSER => MyOrg::Template::Parser\->new({ ... }),
\&    });
.Ve
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
The \s-1DEBUG\s0 option can be used to enable
debugging messages from the Template::Provider module by setting it to include
the \f(CW\*(C`DEBUG_PROVIDER\*(C'\fR value.
.PP
.Vb 1
\&    use Template::Constants qw( :debug );
\&
\&    my $template = Template\->new({
\&        DEBUG => DEBUG_PROVIDER,
\&    });
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
The \f(CW\*(C`Template::Provider\*(C'\fR module can be subclassed to provide templates from a
different source (e.g. a database).  In most cases you'll just need to provide
custom implementations of the \f(CW\*(C`_template_modified()\*(C'\fR and \f(CW\*(C`_template_content()\*(C'\fR
methods.  If your provider requires and custom initialisation then you'll also
need to implement a new \f(CW\*(C`_init()\*(C'\fR method.
.PP
Caching in memory and on disk will still be applied (if enabled)
when overriding these methods.
.SS "_template_modified($path)"
.IX Subsection "_template_modified($path)"
Returns a timestamp of the \f(CW$path\fR passed in by calling \f(CW\*(C`stat()\*(C'\fR.
This can be overridden, for example, to return a last modified value from
a database.  The value returned should be a timestamp value (as returned by \f(CW\*(C`time()\*(C'\fR,
although a sequence number should work as well.
.SS "_template_content($path)"
.IX Subsection "_template_content($path)"
This method returns the content of the template for all \f(CW\*(C`INCLUDE\*(C'\fR, \f(CW\*(C`PROCESS\*(C'\fR,
and \f(CW\*(C`INSERT\*(C'\fR directives.
.PP
When called in scalar context, the method returns the content of the template
located at \f(CW$path\fR, or \f(CW\*(C`undef\*(C'\fR if \f(CW$path\fR is not found.
.PP
When called in list context it returns \f(CW\*(C`($content, $error, $mtime)\*(C'\fR,
where \f(CW$content\fR is the template content, \f(CW$error\fR is an error string
(e.g. "\f(CW\*(C`$path: File not found\*(C'\fR"), and \f(CW$mtime\fR is the template modification
time.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org> <http://wardley.org/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1996\-2022 Andy Wardley.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Parser, Template::Context
