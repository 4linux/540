.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dancer2::Manual::Migration 3"
.TH Dancer2::Manual::Migration 3 "2022-03-14" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer2::Manual::Migration \- Migrating from Dancer to Dancer2
.SH "VERSION"
.IX Header "VERSION"
version 0.400000
.SH "Migration from Dancer 1 to Dancer2"
.IX Header "Migration from Dancer 1 to Dancer2"
This document covers some changes that users will need to be aware of
while upgrading from Dancer (version 1) to Dancer2.
.SS "Launcher script"
.IX Subsection "Launcher script"
The default launcher script \fIbin/app.pl\fR in Dancer looked like this:
.PP
.Vb 4
\&    #!/usr/bin/env perl
\&    use Dancer;
\&    use MyApp;
\&    dance;
.Ve
.PP
In Dancer2 it is available as \fIbin/app.psgi\fR and looks like this:
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use strict;
\&    use warnings;
\&    use FindBin;
\&    use lib "$FindBin::Bin/../lib";
\&
\&    use MyApp;
\&    MyApp\->to_app;
.Ve
.PP
So you need to remove the \f(CW\*(C`use Dancer;\*(C'\fR part, replace the \f(CW\*(C`dance;\*(C'\fR command
by \f(CW\*(C`MyApp\->to_app;\*(C'\fR (where MyApp is the name of your application), and
add the following lines:
.PP
.Vb 4
\&    use strict;
\&    use warnings;
\&    use FindBin;
\&    use lib "$FindBin::Bin/../lib";
.Ve
.PP
There is a Dancer Advent Calendar <http://advent.perldancer.org> article
covering the \f(CW\*(C`to_app\*(C'\fR keyword <http://advent.perldancer.org/2014/9>
and its usage.
.SS "Configuration"
.IX Subsection "Configuration"
You specify a different location to the directory used for serving static (public)
content by setting the \f(CW\*(C`public_dir\*(C'\fR option. In that case, you have to set
\&\f(CW\*(C`static_handler\*(C'\fR option also.
.SS "Apps"
.IX Subsection "Apps"
1. In Dancer2, each module is a \fBseparate application\fR with its own
namespace and variables. You can set the application name in each of your
Dancer2 application modules. Different modules can be tied into the same
app by setting the application name to the same value.
.PP
For example, to set the appname directive explicitly:
.PP
\&\f(CW\*(C`MyApp\*(C'\fR:
.PP
.Vb 3
\&    package MyApp;
\&    use Dancer2;
\&    use MyApp::Admin
\&
\&    hook before => sub {
\&        var db => \*(AqUsers\*(Aq;
\&    };
\&
\&    get \*(Aq/\*(Aq => sub {...};
\&
\&    1;
.Ve
.PP
\&\f(CW\*(C`MyApp::Admin\*(C'\fR:
.PP
.Vb 2
\&    package MyApp::Admin;
\&    use Dancer2 appname => \*(AqMyApp\*(Aq;
\&
\&    # use a lexical prefix so we don\*(Aqt override it globally
\&    prefix \*(Aq/admin\*(Aq => sub {
\&        get \*(Aq/\*(Aq => sub {...};
\&    };
\&
\&    1;
.Ve
.PP
Without the appname directive, \f(CW\*(C`MyApp::Admin\*(C'\fR would not have access
to variable \f(CW\*(C`db\*(C'\fR. In fact, when accessing \f(CW\*(C`/admin\*(C'\fR, the before hook would
not be executed.
.PP
See Dancer2::Cookbook <https://metacpan.org/pod/Dancer2::Cookbook#Using-the-prefix-feature-to-split-your-application>
for details.
.PP
2. To speed up an app in Dancer2, install the recommended modules listed in the
\&\*(L"Performance Improvements\*(R" in Dancer2::Manual::Deployment section.
.SS "Request"
.IX Subsection "Request"
The request object (Dancer2::Core::Request) is now deferring much of
its code to Plack::Request to be consistent with the known interface
to \s-1PSGI\s0 requests.
.PP
Currently the following attributes pass directly to Plack::Request:
.PP
\&\f(CW\*(C`address\*(C'\fR, \f(CW\*(C`remote_host\*(C'\fR, \f(CW\*(C`protocol\*(C'\fR, \f(CW\*(C`port\*(C'\fR, \f(CW\*(C`method\*(C'\fR, \f(CW\*(C`user\*(C'\fR,
\&\f(CW\*(C`request_uri\*(C'\fR, \f(CW\*(C`script_name\*(C'\fR, \f(CW\*(C`content_length\*(C'\fR, \f(CW\*(C`content_type\*(C'\fR,
\&\f(CW\*(C`content_encoding\*(C'\fR, \f(CW\*(C`referer\*(C'\fR, and \f(CW\*(C`user_agent\*(C'\fR.
.PP
If previous attributes returned \fIundef\fR for no value beforehand, they
will return whatever Plack::Request defines now, which just might be
an empty list.
.PP
For example:
.PP
.Vb 4
\&    my %data = (
\&        referer    => request\->referer,
\&        user_agent => request\->user_agent,
\&    );
.Ve
.PP
should be replaced by:
.PP
.Vb 4
\&    my %data = (
\&        referer    => request\->referer    || \*(Aq\*(Aq,
\&        user_agent => request\->user_agent || \*(Aq\*(Aq,
\&    );
.Ve
.SS "Plugins: plugin_setting"
.IX Subsection "Plugins: plugin_setting"
\&\f(CW\*(C`plugin_setting\*(C'\fR returns the configuration of the plugin. It can only be
called in \f(CW\*(C`register\*(C'\fR or \f(CW\*(C`on_plugin_import\*(C'\fR.
.SS "Routes"
.IX Subsection "Routes"
Dancer2 requires all routes defined via a string to begin with a leading
slash \f(CW\*(C`/\*(C'\fR.
.PP
For example:
.PP
.Vb 3
\&    get \*(Aq0\*(Aq => sub {
\&        return "not gonna fly";
\&    };
.Ve
.PP
would return an error. The correct way to write this would be to use
\&\f(CW\*(C`get \*(Aq/0\*(Aq\*(C'\fR
.SS "Route parameters"
.IX Subsection "Route parameters"
The \f(CW\*(C`params\*(C'\fR keyword which provides merged parameters used to allow body
parameters to override route parameters. Now route parameters take
precedence over query parameters and body parameters.
.PP
We have introduced \f(CW\*(C`route_parameters\*(C'\fR to retrieve parameter values from
the route matching. Please refer to Dancer2::Manual for more
information.
.SS "Tests"
.IX Subsection "Tests"
Dancer2 recommends the use of Plack::Test.
.PP
For example:
.PP
.Vb 5
\&    use strict;
\&    use warnings;
\&    use Test::More tests => 2;
\&    use Plack::Test;
\&    use HTTP::Request::Common;
\&
\&    {
\&        package App::Test; # or whatever you want to call it
\&        get \*(Aq/\*(Aq => sub { template \*(Aqindex\*(Aq };
\&    }
\&
\&    my $test = Plack::Test\->create( App::Test\->to_app );
\&    my $res  = $test\->request( GET \*(Aq/\*(Aq );
\&
\&    ok( $res\->is_success, \*(Aq[GET /] Successful\*(Aq );
\&    like( $res\->content, qr{<title>Test2</title>}, \*(AqCorrect title\*(Aq );
.Ve
.PP
Other modules that could be used for testing are:
.IP "\(bu" 4
Test::TCP
.IP "\(bu" 4
Test::WWW::Mechanize::PSGI
.PP
\fILogs\fR
.IX Subsection "Logs"
.PP
The \f(CW\*(C`logger_format\*(C'\fR in the Logger role (Dancer2::Core::Role::Logger)
is now \f(CW\*(C`log_format\*(C'\fR.
.PP
\&\f(CW\*(C`read_logs\*(C'\fR can no longer be used, as with Dancer2::Test. Instead,
Dancer2::Logger::Capture could be used for testing, to capture all
logs to an object.
.PP
For example:
.PP
.Vb 6
\&    use strict;
\&    use warnings;
\&    use Test::More import => [\*(Aq!pass\*(Aq];
\&    use Plack::Test;
\&    use HTTP::Request::Common;
\&    use Ref::Util qw<is_coderef>;
\&
\&    {
\&        package App;
\&        use Dancer2;
\&
\&        set log       => \*(Aqdebug\*(Aq;
\&        set logger    => \*(Aqcapture\*(Aq;
\&
\&        get \*(Aq/\*(Aq => sub {
\&            debug \*(Aqthis is my debug message\*(Aq;
\&            return 1;
\&        };
\&    }
\&
\&    my $app = Dancer2\->psgi_app;
\&    ok( is_coderef($app), \*(AqGot app\*(Aq );
\&
\&    test_psgi $app, sub {
\&        my $cb = shift;
\&
\&        my $res = $cb\->( GET \*(Aq/\*(Aq );
\&        is $res\->code, 200;
\&
\&        my $trap = App\->dancer_app\->logger_engine\->trapper;
\&
\&        is_deeply $trap\->read, [
\&            { level => \*(Aqdebug\*(Aq, message => \*(Aqthis is my debug message\*(Aq }
\&        ];
\&    };
.Ve
.SS "Exports: Tags"
.IX Subsection "Exports: Tags"
The following tags are not needed in Dancer2:
.PP
.Vb 3
\& use Dancer2 qw(:syntax);
\& use Dancer2 qw(:tests);
\& use Dancer2 qw(:script);
.Ve
.PP
The \f(CW\*(C`plackup\*(C'\fR command should be used instead. It provides a development
server and reads the configuration options in your command line utilities.
.SS "Engines"
.IX Subsection "Engines"
.IP "\(bu" 4
Engines receive a logging callback
.Sp
Engines now receive a logging callback named \f(CW\*(C`log_cb\*(C'\fR. Engines can use it
to log anything in run-time, without having to worry about what logging
engine is used.
.Sp
This is provided as a callback because the logger might be changed in
run-time and we want engines to be able to always reach the current one
without having a reference back to the core application object.
.Sp
The logger engine doesn't have the attribute since it is the logger itself.
.IP "\(bu" 4
Engines handle encoding consistently
.Sp
All engines are now expected to handle encoding on their own. User code
is expected to be in internal Perl representation.
.Sp
Therefore, all serializers, for example, should deserialize to the Perl
representation. Templates, in turn, encode to \s-1UTF\-8\s0 if requested by the
user, or by default.
.Sp
One side-effect of this is that \f(CW\*(C`from_yaml\*(C'\fR will call \s-1YAML\s0's \f(CW\*(C`Load\*(C'\fR
function with decoded input.
.PP
\fITemplating engine changes\fR
.IX Subsection "Templating engine changes"
.PP
Whereas in Dancer1, the following were equivalent for Template::Toolkit:
.PP
.Vb 2
\&    template \*(Aqfoo/bar\*(Aq
\&    template \*(Aq/foo/bar\*(Aq
.Ve
.PP
In Dancer2, when using Dancer2::Template::TemplateToolkit, the version with
the leading slash will try to locate \f(CW\*(C`/foo/bar\*(C'\fR relative to your filesystem
root, not relative to your Dancer application directory.
.PP
The Dancer2::Template::Simple engine is unchanged in this respect.
.PP
Whereas in Dancer1, template engines have the methods:
.PP
.Vb 2
\&    $template_engine\->view(\*(Aqfoo.tt\*(Aq)
\&    $template_engine\->view_exists(\*(Aqfoo.tt\*(Aq)
.Ve
.PP
In Dancer2, you should instead write:
.PP
.Vb 2
\&    $template_engine\->view_pathname(\*(Aqfoo.tt\*(Aq)
\&    $template_engine\->pathname_exists($full_path)
.Ve
.PP
You may not need these unless you are writing a templating engine.
.PP
\fISerializers\fR
.IX Subsection "Serializers"
.PP
You no longer need to implement the \f(CW\*(C`loaded\*(C'\fR method. It is simply
unnecessary.
.PP
\fISessions\fR
.IX Subsection "Sessions"
.PP
Now the Simple session engine is turned on
by default, unless you specify a different one.
.SS "Configuration"
.IX Subsection "Configuration"
\fI\f(CI\*(C`public_dir\*(C'\fI\fR
.IX Subsection "public_dir"
.PP
You cannot set the public directory with \f(CW\*(C`setting\*(C'\fR now. Instead you
will need to call \f(CW\*(C`config\*(C'\fR:
.PP
.Vb 2
\&    # before
\&    setting( \*(Aqpublic_dir\*(Aq, \*(Aqnew_path/\*(Aq );
\&
\&    # after
\&    config\->{\*(Aqpublic_dir\*(Aq} = \*(Aqnew_path\*(Aq;
.Ve
.PP
\fIwarnings\fR
.IX Subsection "warnings"
.PP
The \f(CW\*(C`warnings\*(C'\fR configuration option, along with the environment variable
\&\f(CW\*(C`DANCER_WARNINGS\*(C'\fR, have been removed and have no effect whatsoever.
.PP
They were added when someone requested to be able to load Dancer without
the warnings pragma, which it adds, just like Moose, Moo, and
other modules provide.
.PP
If you want this to happen now (which you probably shouldn't be doing),
you can always control it lexically:
.PP
.Vb 2
\&    use Dancer2;
\&    no warnings;
.Ve
.PP
You can also use Dancer2 within a narrower scope:
.PP
.Vb 3
\&    { use Dancer2 }
\&    use strict;
\&    # warnings are not turned on
.Ve
.PP
However, having warnings turned it is very recommended.
.PP
\fIserver_tokens\fR
.IX Subsection "server_tokens"
.PP
The configuration \f(CW\*(C`server_tokens\*(C'\fR has been introduced in the reverse (but
more sensible, and Plack-compatible) form as \f(CW\*(C`no_server_tokens\*(C'\fR.
.PP
\&\f(CW\*(C`DANCER_SERVER_TOKENS\*(C'\fR changed to \f(CW\*(C`DANCER_NO_SERVER_TOKENS\*(C'\fR.
.PP
\fIengines\fR
.IX Subsection "engines"
.PP
If you want to use Template::Toolkit instead of the built-in simple templating
engine you used to enable the following line in the config.yml file.
.PP
.Vb 1
\&    template: "template_toolkit"
.Ve
.PP
That was enough to get started. The start_tag and end_tag it used were the same as in
the simple template <% and %> respectively.
.PP
If you wanted to further customize the Template::Toolkit you could also enable or add
the following:
.PP
.Vb 5
\&    engines:
\&      template_toolkit:
\&         encoding:  \*(Aqutf8\*(Aq
\&         start_tag: \*(Aq[%\*(Aq
\&         end_tag:   \*(Aq%]\*(Aq
.Ve
.PP
In Dancer 2 you can also enable Template::Toolkit with the same configuration option:
.PP
.Vb 1
\&    template: "template_toolkit"
.Ve
.PP
But the default start_tag and end_tag are now [% and %], so if you used the default in Dancer 1
now you will have to explicitly change the start_tag and end_tag values.
The configuration also got an extra level of depth. Under the \f(CW\*(C`engine\*(C'\fR key there is a \f(CW\*(C`template\*(C'\fR
key and the \f(CW\*(C`template_toolkit\*(C'\fR key comes below that. As in this example:
.PP
.Vb 5
\&    engines:
\&      template:
\&        template_toolkit:
\&          start_tag: \*(Aq<%\*(Aq
\&          end_tag:   \*(Aq%>\*(Aq
.Ve
.PP
In a nutshell, if you used to have
.PP
.Vb 1
\&    template: "template_toolkit"
.Ve
.PP
You need to replace it with
.PP
.Vb 6
\&    template: "template_toolkit"
\&    engines:
\&      template:
\&        template_toolkit:
\&          start_tag: \*(Aq<%\*(Aq
\&          end_tag:   \*(Aq%>\*(Aq
.Ve
.PP
Session engine
.IX Subsection "Session engine"
.PP
The session engine is configured in the \f(CW\*(C`engine\*(C'\fR section.
.IP "\(bu" 4
\&\f(CW\*(C`session_name\*(C'\fR changed to \f(CW\*(C`cookie_name\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`session_domain\*(C'\fR changed to \f(CW\*(C`cookie_domain\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`session_expires\*(C'\fR changed to \f(CW\*(C`cookie_duration\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`session_secure\*(C'\fR changed to \f(CW\*(C`is_secure\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`session_is_http_only\*(C'\fR changed to \f(CW\*(C`is_http_only\*(C'\fR.
.PP
Dancer2 also adds two attributes for session:
.IP "\(bu" 4
\&\f(CW\*(C`cookie_path\*(C'\fR
The path of the cookie to create for storing the session key. Defaults to \*(L"/\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`session_duration\*(C'\fR
Duration in seconds before sessions should expire, regardless of cookie
expiration. If set, then SessionFactories should use this to enforce a limit on
session validity.
.PP
See Dancer2::Core::Role::SessionFactory for more detailed documentation
for these options, or the particular session engine for other supported options.
.PP
.Vb 1
\&  session: Simple
\&
\&  engines:
\&    session:
\&      Simple:
\&        cookie_name: dance.set
\&        cookie_duration: \*(Aq24 hours\*(Aq
\&        is_secure: 1
\&        is_http_only: 1
.Ve
.PP
\fIPlack Middleware\fR
.IX Subsection "Plack Middleware"
.PP
In Dancer1 you could set up Plack Middleware using a \f(CW\*(C`plack_middlewares\*(C'\fR key
in your \f(CW\*(C`config.yml\*(C'\fR file. Under Dancer2 you will instead need to invoke
middleware using Plack::Builder, as demonstrated in
Dancer2::Manual::Deployment.
.SS "Keywords"
.IX Subsection "Keywords"
\fICalling Keywords Explicitly\fR
.IX Subsection "Calling Keywords Explicitly"
.PP
In Dancer1, keywords could be imported individually into a package:
.PP
.Vb 2
\&    package MyApp;
\&    use Dancer qw< get post params session >;
\&
\&    get \*(Aq/foo\*(Aq { ... };
.Ve
.PP
Any keywords you did't export could be called explicitly:
.PP
.Vb 3
\&    package MyApp;
\&    use Dancer qw< get post params session >;
\&    use List::Util qw< any >;
\&
\&    Dancer::any sub { ... };
.Ve
.PP
Dancer2's \s-1DSL\s0 is implemented differently. Keywords only exist in the namespace
of the package which \f(CW\*(C`use\*(C'\fRs Dancer2, i.e. there is no \f(CW\*(C`Dancer2::any\*(C'\fR, only
e.g. \f(CW\*(C`MyApp::any\*(C'\fR.
.PP
If you only want individual keywords, you can write a shim as follows:
.PP
.Vb 2
\&    package MyApp::DSL;
\&    use Dancer2 appname => \*(AqMyApp\*(Aq;
\&
\&    use Exporter qw< import >;
\&
\&    our @EXPORT = qw< get post ... >
.Ve
.PP
Then in other packages:
.PP
.Vb 1
\&    package MyApp;
\&
\&    use MyApp::DSL qw< get post >;
\&
\&    MyApp::DSL::any sub { ... };
.Ve
.PP
\fIappdir\fR
.IX Subsection "appdir"
.PP
This keyword does not exist in Dancer2. However, the same information can be
found in \f(CW\*(C`config\->{\*(Aqappdir\*(Aq}\*(C'\fR.
.PP
\fIload\fR
.IX Subsection "load"
.PP
This keyword is no longer required. Dancer2 loads the environment
automatically and will not reload any other environment when called with
load. (It's a good thing.)
.PP
\fIparam_array\fR
.IX Subsection "param_array"
.PP
This keyword doesn't exist in Dancer2.
.PP
\fIsession\fR
.IX Subsection "session"
.PP
In Dancer a session was created and a cookie was sent just by rendering a page
using the \f(CW\*(C`template\*(C'\fR function. In Dancer2 one needs to actually set a value in
a session object using the \f(CW\*(C`session\*(C'\fR function in order to create the session
and send the cookie.
.PP
The session keyword has multiple states:
.IP "\(bu" 4
No arguments
.Sp
Without any arguments, the session keyword returns a Dancer2::Core::Session
object, which has methods for read, 
write, and delete.
.Sp
.Vb 4
\&    my $session = session;
\&    $session\->read($key);
\&    $session\->write( $key => $value );
\&    $session\->delete($key);
.Ve
.IP "\(bu" 4
Single argument (key)
.Sp
If a single argument is provided, it is treated as the key, and it will retrieve
the value for it.
.Sp
.Vb 1
\&    my $value = session $key;
.Ve
.IP "\(bu" 4
Two arguments (key, value)
.Sp
If two arguments are provided, they are treated as a key and a value, in which
case the session will assign the value to the key.
.Sp
.Vb 1
\&    session $key => $value;
.Ve
.IP "\(bu" 4
Two arguments (key, undef)
.Sp
If two arguments are provided, but the second is \fBundef\fR, the key will be
deleted from the session.
.Sp
.Vb 1
\&    session $key => undef;
.Ve
.PP
In Dancer 1 it wasn't possible to delete a key, but in Dancer2 we can finally
delete:
.PP
.Vb 2
\&    # these two are equivalent
\&    session $key => undef;
\&
\&    my $session = session;
\&    $session\->delete($key);
.Ve
.PP
You can retrieve the whole session hash with the \f(CW\*(C`data\*(C'\fR method:
.PP
.Vb 1
\&    $session\->data;
.Ve
.PP
To destroy a session, instead of writing:
.PP
.Vb 1
\&    session\->destroy
.Ve
.PP
In Dancer2, we write:
.PP
.Vb 1
\&    app\->destroy_session if app\->has_session
.Ve
.PP
If you make changes to the session in an \f(CW\*(C`after\*(C'\fR hook, your changes will
not be written to storage, because writing sessions to storage also takes
place in an (earlier) \f(CW\*(C`after\*(C'\fR hook.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dancer Core Developers
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2022 by Alexis Sukrieh.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
