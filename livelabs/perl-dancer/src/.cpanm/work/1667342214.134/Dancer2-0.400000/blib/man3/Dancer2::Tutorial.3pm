.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dancer2::Tutorial 3"
.TH Dancer2::Tutorial 3 "2022-03-14" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer2::Tutorial \- An example to get you dancing
.SH "VERSION"
.IX Header "VERSION"
version 0.400000
.SH "Tutorial Overview"
.IX Header "Tutorial Overview"
This tutorial is has three parts. Since they build on one another, each part is
meant to be gone through in sequential order.
.PP
\&\fBPart I\fR, the longest part of this tutorial, will focus on the basics of Dancer2
development by building a simple yet functional blog app, called \f(CW\*(C`dancr\*(C'\fR, that
you can use to impress your friends, mates, and family.
.PP
In \fBPart \s-1II\s0\fR, you'll learn about the preferred way to get your own web apps up
and running by using the \f(CW\*(C`dancer2\*(C'\fR utility. We will take the script written in
Part I and convert it into a proper Dancer2 app, called \f(CW\*(C`Dancr2\*(C'\fR, to help you
gain an understanding of what the \f(CW\*(C`dancer2\*(C'\fR utility does for you.
.PP
Finally, in \fBPart \s-1III\s0\fR, we give you a taste of the power of plugins that other
developers have written and will show you how to modify the \f(CW\*(C`Dancr2\*(C'\fR app to use
a database plugin.
.PP
This tutorial assumes you have some familiarity with Perl and that you know how
to create and execute a Perl script on your computer. Some experience with web
development is also greatly helpful but not entirely necessary. This tutorial is
mostly geared toward developers but website designers can get something out of
it as well since the basics of templating are covered plus it might be
good for a designer to have a decent idea of how Dancer2 works.
.SH "Part I: Let's Get Dancing!"
.IX Header "Part I: Let's Get Dancing!"
Part I covers many of the basic concepts you'll need to know to lay a good
foundation for your future development work with Dancer2 by building a simple
micro-blogging app.
.SS "What is Dancer2?"
.IX Subsection "What is Dancer2?"
Dancer2 is a micro-web framework, written in the Perl programming language, and is
modeled after a Ruby web application framework called Sinatra <http://www.sinatrarb.com>.
.PP
When we say \*(L"micro\*(R" framework, we mean that Dancer2 aims to maximize your freedom
and control by getting out of your way. \*(L"Micro\*(R" doesn't mean Dancer2
is only good for creating small apps. Instead, it means that Dancer2's primary
focus is on taking care of a lot of the boring, technical details of your app
for you and by creating an easy, clean routing layer on top of your app's
code. It also means you have almost total control over the app's functionality
and how you create and present your content. You will not confined to someone
else's approach to creating a website or app.
.PP
With Dancer2, you can build anything from a specialized content management
system to providing a simple \s-1API\s0 for querying a database over the web. But you
don't have to reinvent the wheel, either. Dancer2 has hundreds of plugins that
you can take advantage of. You can add only the capabilities your app needs to
keep complexity to a minimum.
.PP
As a framework, Dancer2 provides you with the tools and infrastructure you can
leverage to deliver content on the web quickly, easily and securely. The tools,
Dancer2 provides, called \*(L"keywords,\*(R" are commands that you use to build your app,
access the data inside of it, and deliver it on the internet in many
different formats.
.PP
Dancer2's keywords provide what is called a \fBDomain Specific Language\fR (\s-1DSL\s0)
designed specifically for the task of building apps. But don't let the
technical jargon scare you off. Things will become clearer in our first code
example which we will look at shortly.
.PP
\fIGetting Dancer2 installed\fR
.IX Subsection "Getting Dancer2 installed"
.PP
First, we need to make sure you have Dancer2 installed. Typically, you will do
that with one of the following two commands:
.PP
.Vb 2
\&    cpan Dancer2  # requires the cpan command to be installed and configured
\&    cpanm Dancer2 # requires you have cpanminus installed
.Ve
.PP
If you aren't familiar with installing Perl modules on your machine, you should
read this guide <https://www.cpan.org/modules/INSTALL.html>. You may also want
to consult your \s-1OS\s0's documentation or a knowledgeable expert. And, of course,
your search engine of choice is always there for you, as well.
.PP
\fIYour first Dancer2 \*(L"Hello World!\*(R" app\fR
.IX Subsection "Your first Dancer2 Hello World! app"
.PP
Now that you have Dancer2 installed, open up your favorite text editor and copy
and paste the following lines of Perl code into it and save it to a file
called \f(CW\*(C`dancr.pl\*(C'\fR:
.PP
.Vb 2
\&    #!/usr/bin/env perl
\&    use Dancer2;
\&
\&    get \*(Aq/\*(Aq => sub {
\&        return \*(AqHello World!\*(Aq;
\&    };
\&
\&    start;
.Ve
.PP
If you make this script executable and run it, it will fire up a simple,
standalone web server that will display \*(L"Hello World!\*(R" when you point your
browser to <http://localhost:3000>. Cool!
.PP
\&\fBImportant note:\fR We want to emphasize that writing a script file like
this with a \f(CW\*(C`start\*(C'\fR command is \fBnot\fR how you would typically begin writing a
Dancer2 app. Part \s-1II\s0 of this tutorial will show you the recommended approach
using the \f(CW\*(C`dancer2\*(C'\fR utility. For now, we want to stay focused on the
fundamentals.
.PP
So, though our example app is very simple, there is a lot going on under the hood
when we invoke \f(CW\*(C`use Dancer2;\*(C'\fR in our first line of code. We won't go into the
gory details of how it all works. For now, it's enough for you to know that the
Dancer2 module infuses your script with the ability to use Dancer2 keywords for
building apps. Getting comfortable with the concept of keywords is probably the
most important step you can take as a budding Dancer2 developer and this
tutorial will do its best to help foster your understanding of them.
.PP
The next line of code in our example (which spans three lines to make it more
readable) is the \fBroute handler\fR. Let's examine this line closely, because
route handlers are at the core of how to build an app with Dancer2.
.PP
The syntax of a Dancer2 \f(CW\*(C`route handler\*(C'\fR has three parts:
.IP "\(bu" 4
an \fBhttp method\fR or \fBhttp verb\fR; in this example, we use the \f(CW\*(C`get\*(C'\fR keyword
to tell Dancer2 that this route should apply to \s-1GET\s0 http requests. \f(CW\*(C`get\*(C'\fR is the
first of many keywords that Dancer2 provides that we will cover in this tutorial.
Those familiar with web development will know that a \s-1GET\s0 request is what we use
to fetch information from a website.
.IP "\(bu" 4
the \fBroute pattern\fR; this is the bit of code that appears immediately after
our \f(CW\*(C`get\*(C'\fR keyword. In this example it is a forward slash (\f(CW\*(C`/\*(C'\fR), wrapped in
single quotes, and it represents the pattern we wish to match against the \s-1URL\s0
that the browser, or client, has requested. Web developers will immediately
recognize that the forward slash symbolizes the root directory of our website.
Experienced Perl programmers will pick up on the fact that the route pattern is
nothing more than an argument for our \f(CW\*(C`get\*(C'\fR keyword.
.IP "\(bu" 4
the \fBroute action\fR; this is the subroutine that returns our data. More
precisely, it is a subroutine reference. The route action in our example returns
a simple string, \f(CW\*(C`Hello World!\*(C'\fR. Like the route pattern, the route action is
nothing more than an argument to our \f(CW\*(C`get\*(C'\fR keyword.
.Sp
Note that convention has us use the fat comma (\f(CW\*(C`=>\*(C'\fR) operator between the
route pattern and the action to to make our code more readable. But we
could just as well have used a regular old comma to separate these argument to
our \f(CW\*(C`get\*(C'\fR method. Gotta love Perl for its flexibility.
.PP
So to put our route pattern in the example into plain English, we are telling
our app, \*(L"If the root directory is requested with the \s-1GET\s0 http method, send
the string 'Hello World!' back in our response.\*(R" Of course, since this is a web
app, we also have to send back headers with our response. This is quitely taken
care of for us by Dancer2 so we don't have to think about it.
.PP
The syntax for route handlers might seem a bit foreign for newer Perl developers.
But rest assured there is nothing magical about it and it is all just plain
old Perl under the hood. If you keep in mind that the keyword is a subroutine
(or more precisely, a method) and that the pattern and action are arguments to
the keyword, you'll pick it up in no time. Thinking of these keywords as
\&\*(L"built-ins\*(R" to the Dancer2 framework might also eliminate any initial confusion
about them.
.PP
The most important takeaway here is that we build our app by adding route
handlers which are nothing more than a collection of, \s-1HTTP\s0 verbs, \s-1URL\s0 patterns,
and actions.
.SS "How about a little more involved example?"
.IX Subsection "How about a little more involved example?"
While investigating some Python web frameworks like Flask <http://flask.pocoo.org/>
or Bottle <https://bottlepy.org/docs/dev/>, I enjoyed the way they explained
step-by-step how to build an example application which was a little more involved
than a trivial example. This tutorial is modeled after them.
.PP
Using the
Flaskr <https://github.com/pallets/flask>
sample application as my inspiration (\s-1OK,\s0 shamelessly plagiarised) I
translated that application to the Dancer2 framework so I could better
understand how Dancer2 worked. (I'm learning it too!)
.PP
So \*(L"dancr\*(R" was born.
.PP
dancr is a simple \*(L"micro\*(R" blog which uses the
SQLite <http://www.sqlite.org> database engine for simplicity's sake.
You'll need to install sqlite on your server if you don't have it
installed already. Consult your \s-1OS\s0 documentation for getting SQLite
installed on your machine.
.PP
\fIRequired Perl modules\fR
.IX Subsection "Required Perl modules"
.PP
Obviously you need Dancer2 installed. You'll also need the
Template Toolkit, File::Slurper, and DBD::SQLite modules.
These all can be installed using your \s-1CPAN\s0 client with the following command:
.PP
.Vb 1
\&    cpan Template File::Slurper DBD::SQLite
.Ve
.SS "The database code"
.IX Subsection "The database code"
We're not going to spend a lot of time on the database, as it's not really the
point of this particular tutorial. Try not to dwell on this section too much
if you don't understand all of it.
.PP
Open your favorite text editor <http://www.vim.org> and create a schema
definition called 'schema.sql' with the following content:
.PP
.Vb 5
\&    create table if not exists entries (
\&        id integer primary key autoincrement,
\&        title string not null,
\&        text string not null
\&    );
.Ve
.PP
Here we have a single table with three columns: id, title, and text. The
\&'id' field is the primary key and will automatically get an \s-1ID\s0 assigned by
the database engine when a row is inserted.
.PP
We want our application to initialize the database automatically for us when
we start it. So, let's edit the 'dancr.pl' file we created earlier and give it
the ability to talk to our database with the following subroutines: (Or, if you
prefer, you can copy and paste the finished dancr.pl script, found near the end
of Part I in this tutorial, into the file all at once and then just follow along
with the tutorial.)
.PP
.Vb 3
\&    sub connect_db {
\&        my $dbh = DBI\->connect("dbi:SQLite:dbname=".setting(\*(Aqdatabase\*(Aq))
\&            or die $DBI::errstr;
\&
\&        return $dbh;
\&    }
\&
\&    sub init_db {
\&        my $db     = connect_db();
\&        my $schema = read_text(\*(Aq./schema.sql\*(Aq);
\&        $db\->do($schema)
\&            or die $db\->errstr;
\&    }
.Ve
.PP
Nothing too fancy in here, I hope. It's standard \s-1DBI\s0 except for the
\&\f(CW\*(C`setting(\*(Aqdatabase\*(Aq)\*(C'\fR thing, more on that in a bit. For now, just assume
that the expression evaluates to the location of the database file.
.PP
In Part \s-1III\s0 of the tutorial, we will show you how to use the
Dancer2::Plugin::Database module for an easier way to configure and manage
database connections for your Dancer2 apps.
.SS "Our first route handler"
.IX Subsection "Our first route handler"
Ok, let's get back to the business of learning Dancer2 by creating our app's
first route handler for the root \s-1URL.\s0  Replace the route handler in our
simple example above with this one:
.PP
.Vb 3
\&    get \*(Aq/\*(Aq => sub {
\&        my $db  = connect_db();
\&        my $sql = \*(Aqselect id, title, text from entries order by id desc\*(Aq;
\&
\&        my $sth = $db\->prepare($sql)
\&            or die $db\->errstr;
\&
\&        $sth\->execute
\&            or die $sth\->errstr;
\&
\&        template \*(Aqshow_entries.tt\*(Aq, {
\&            msg           => get_flash(),
\&            add_entry_url => uri_for(\*(Aq/add\*(Aq),
\&            entries       => $sth\->fetchall_hashref(\*(Aqid\*(Aq),
\&        };
\&    };
.Ve
.PP
Our new route handler is the same as the one in our first example except that
our route action does a lot more work.
.PP
Something you might not have noticed right away is the semicolon at the end of
the route handler. This might confuse newer Perl coders and is a source of bugs
for more experienced ones who forget to add it. We need the semicolon there
because we are creating a reference to a subroutine and because that's just what
the Perl compiler demands and we must obey if we want our code to run.
.PP
Alright, let's take a closer look at this route's action. The first few lines are
standard \s-1DBI.\s0 The important bit related to Dancer2 is the \f(CW\*(C`template\*(C'\fR keyword
at the end of the action. That tells Dancer2 to process the output through one
of its templating engines. There are many template engines available for use with
Dancer2. In this tutorial, we're using Template Toolkit
which offers a lot more flexibility than the simple default Dancer2
template engine.
.PP
Templates all go into a \f(CW\*(C`views/\*(C'\fR directory which located in the same
directory as our dancr.pl script. Optionally, you can create a \*(L"layout\*(R" template
which provides a consistent look and feel for all of your views. We'll construct
our own layout template, cleverly named \fImain.tt\fR, a little later in
this tutorial.
.PP
So what's going on with the hashref as the second argument to the template
directive? Those are all of the parameters we want to pass into our
template. We have a \f(CW\*(C`msg\*(C'\fR field which displays a message to the user when
an event happens like a new entry is posted, or the user logs in or out.
It's called a \*(L"flash\*(R" message because we only want to display it one time,
not every time the \f(CW\*(C`/\*(C'\fR \s-1URL\s0 is rendered.
.PP
The \f(CW\*(C`uri_for\*(C'\fR directive tells Dancer2 to provide a \s-1URI\s0 for that specific
route, in this case, it is the route to post a new entry into the database.
You might ask why we don't simply hardcode the \f(CW\*(C`/add\*(C'\fR \s-1URI\s0 in our
application or templates.  The best reason \fBnot\fR to do that is because it
removes a layer of flexibility as to where to \*(L"mount\*(R" the web application.
Although the application is coded to use the root \s-1URL\s0 \f(CW\*(C`/\*(C'\fR it might be
better in the future to locate it under its own \s-1URL\s0 route (maybe \f(CW\*(C`/dancr\*(C'\fR?)
\&\- at that point we'd have to go through our application and the templates
and update the URLs and hope we didn't miss any of them.  By using the
\&\f(CW\*(C`uri_for\*(C'\fR Dancer2 method, we can easily load the application wherever we
like and not have to modify the application at all.
.PP
Finally, the \f(CW\*(C`entries\*(C'\fR field contains a hashref with the results from our
database query.  Those results will be rendered in the template itself, so
we just pass them in.
.PP
So what does the \fIshow_entries.tt\fR template look like? This:
.PP
.Vb 10
\&  [% IF session.logged_in %]
\&    <form action="[% add_entry_url %]" method=post class=add\-entry>
\&      <dl>
\&        <dt>Title:
\&        <dd><input type=text size=30 name=title>
\&        <dt>Text:
\&        <dd><textarea name=text rows=5 cols=40></textarea>
\&        <dd><input type=submit value=Share>
\&      </dl>
\&    </form>
\&  [% END %]
\&  <ul class=entries>
\&  [% IF entries.size %]
\&    [% FOREACH id IN entries.keys.nsort %]
\&      <li><h2>[% entries.$id.title | html %]</h2>[% entries.$id.text | html %]
\&    [% END %]
\&  [% ELSE %]
\&    <li><em>Unbelievable. No entries here so far</em>
\&  [% END %]
\&  </ul>
.Ve
.PP
Go ahead and create a \f(CW\*(C`views/\*(C'\fR directory in the same directory as the script
and add this file to it.
.PP
Again, since this isn't a tutorial about Template Toolkit, we'll gloss
over the syntax here and just point out the section which starts with
\&\f(CW\*(C`<ul class=entries>\*(C'\fR. This is the section where the database query
results are displayed. You can also see at the very top some discussion about a
session, more on that soon.
.PP
The only other Template Toolkit related thing that has to be mentioned here is
the \f(CW\*(C`| html\*(C'\fR in \f(CW\*(C`[% entries.$id.title | html %]\*(C'\fR. That's
a filter <http://www.template-toolkit.org/docs/manual/Filters.html#section_html>
to convert characters like \f(CW\*(C`<\*(C'\fR and \f(CW\*(C`>\*(C'\fR to \f(CW\*(C`&lt;\*(C'\fR and \f(CW\*(C`&gt;\*(C'\fR. This
way they will be displayed by the browser as content on the page rather than
just included. If we did not do this, the browser might interpret content as
part of the page, and a malicious user could smuggle in all kinds of bad code
that would then run in another user's browser. This is called
Cross Site Scripting <https://en.wikipedia.org/wiki/Cross-site_scripting> or
\&\s-1XSS\s0 and you should make sure to avoid it by always filtering data that came
in from the web when you display it in a template.
.SS "Other \s-1HTTP\s0 verbs"
.IX Subsection "Other HTTP verbs"
There are 8 defined \s-1HTTP\s0 verbs defined in \s-1RFC
2616\s0 <http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9>: \s-1OPTIONS,
GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT.\s0  Of these, the majority of web
applications focus on the verbs which closely map to the \s-1CRUD\s0 (Create,
Retrieve, Update, Delete) operations most database-driven applications need
to implement.
.PP
In addition, the \f(CW\*(C`PATCH\*(C'\fR verb was defined in
\&\s-1RFC5789\s0 <http://tools.ietf.org/html/rfc5789>, and is intended as a \*(L"partial
\&\s-1PUT\*(R",\s0 sending just the changes required to the entity in question.  How
this would be handled is down to your app, it will vary depending on the
type of entity in question and the serialization in use.
.PP
Dancer2's keywords currently supports \s-1GET, PUT/PATCH, POST, DELETE, OPTIONS\s0 which
map to Retrieve, Update, Create, Delete respectively.  Let's take a look now at
the \f(CW\*(C`/add\*(C'\fR route handler which handles a \s-1POST\s0 operation.
.PP
.Vb 4
\&    post \*(Aq/add\*(Aq => sub {
\&        if ( not session(\*(Aqlogged_in\*(Aq) ) {
\&            send_error("Not logged in", 401);
\&        }
\&
\&        my $db = connect_db();
\&        my $sql = \*(Aqinsert into entries (title, text) values (?, ?)\*(Aq;
\&        my $sth = $db\->prepare($sql)
\&            or die $db\->errstr;
\&
\&        $sth\->execute(
\&            body_parameters\->get(\*(Aqtitle\*(Aq),
\&            body_parameters\->get(\*(Aqtext\*(Aq)
\&        ) or die $sth\->errstr;
\&
\&        set_flash(\*(AqNew entry posted!\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\&    };
.Ve
.PP
As before, the \s-1HTTP\s0 verb begins the handler, followed by the route, and a
subroutine to do something; in this case it will insert a new entry into
the database.
.PP
The first check in the subroutine is to make sure the user sending the data
is logged in. If not, the application returns an error and stops
processing. Otherwise, we have standard \s-1DBI\s0 stuff. Let me insert (heh, heh)
a blatant plug here for always, always using parameterized INSERTs in your
application \s-1SQL\s0 statements. It's the only way to be sure your application
won't be vulnerable to \s-1SQL\s0 injection. (See <http://www.bobby\-tables.com>
for correct \s-1INSERT\s0 examples in multiple languages.) Here we're using the
\&\f(CW\*(C`body_parameters\*(C'\fR convenience method to pull in the parameters in the current \s-1HTTP\s0
request. (You can see the 'title' and 'text' form parameters in the
\&\fIshow_entries.tt\fR template above.) Those values are inserted into the
database, then we set a flash message for the user and redirect her back to
the root \s-1URL.\s0
.PP
It's worth mentioning that the \*(L"flash message\*(R" is not part of Dancer2, but a
part of this specific application. We need to implement it ourself.
.SS "Logins and sessions"
.IX Subsection "Logins and sessions"
Dancer2 comes with a simple in-memory session manager out of the box. It
supports a bunch of other session engines including \s-1YAML,\s0 memcached, browser
cookies and others. We'll just stick with the in-memory model which works great
for development and tutorials, but won't persist across server restarts or
scale very well in \*(L"real world\*(R" production scenarios.
.PP
\fIConfiguration options\fR
.IX Subsection "Configuration options"
.PP
To use sessions in our application, we have to tell Dancer2 to activate the
session handler and initialize a session manager. To do that, we add some
configuration directives toward the top of our 'dancr.pl' file.  But there are
more options than just the session engine we want to set.
.PP
.Vb 7
\&    set \*(Aqdatabase\*(Aq     => File::Spec\->catfile(File::Spec\->tmpdir(), \*(Aqdancr.db\*(Aq);
\&    set \*(Aqsession\*(Aq      => \*(AqSimple\*(Aq;
\&    set \*(Aqtemplate\*(Aq     => \*(Aqtemplate_toolkit\*(Aq;
\&    set \*(Aqlogger\*(Aq       => \*(Aqconsole\*(Aq;
\&    set \*(Aqlog\*(Aq          => \*(Aqdebug\*(Aq;
\&    set \*(Aqshow_errors\*(Aq  => 1;
\&    set \*(Aqstartup_info\*(Aq => 1;
.Ve
.PP
Hopefully these are fairly self-explanatory. We want the Simple session
engine, the Template Toolkit template engine, logging enabled (at the
\&'debug' level with output to the console instead of a file), we want to show
errors to the web browser and prints a banner at the server start with
information such as versions and the environment.
.PP
Dancer2 doesn't impose any limits on what parameters you can set using the
\&\f(CW\*(C`set\*(C'\fR syntax. For this application we're going to embed our single username
and password into the application itself:
.PP
.Vb 2
\&    set \*(Aqusername\*(Aq => \*(Aqadmin\*(Aq;
\&    set \*(Aqpassword\*(Aq => \*(Aqpassword\*(Aq;
.Ve
.PP
Hopefully no one will ever guess our clever password!  Obviously, you will
want a more sophisticated user authentication scheme in any sort of
non-tutorial application but this is good enough for our purposes.
.PP
In Part \s-1II\s0 of our tutorial, we will show you how to use Dancer2's configuration
files to manage these options and set up different environments for your app
using different configuration files. For now, we're going to keep it simple and
leave that discussion for later.
.PP
\fILogging in\fR
.IX Subsection "Logging in"
.PP
Now that dancr is configured to handle sessions, let's take a look at the
\&\s-1URL\s0 handler for the \f(CW\*(C`/login\*(C'\fR route.
.PP
.Vb 2
\&    any [\*(Aqget\*(Aq, \*(Aqpost\*(Aq] => \*(Aq/login\*(Aq => sub {
\&        my $err;
\&
\&        if ( request\->method() eq "POST" ) {
\&            # process form input
\&            if ( body_parameters\->get(\*(Aqusername\*(Aq) ne setting(\*(Aqusername\*(Aq) ) {
\&                $err = "Invalid username";
\&            }
\&            elsif ( body_parameters\->get(\*(Aqpassword\*(Aq) ne setting(\*(Aqpassword\*(Aq) ) {
\&                $err = "Invalid password";
\&            }
\&            else {
\&                session \*(Aqlogged_in\*(Aq => true;
\&                set_flash(\*(AqYou are logged in.\*(Aq);
\&                return redirect \*(Aq/\*(Aq;
\&            }
\&        }
\&
\&        # display login form
\&        template \*(Aqlogin.tt\*(Aq, {
\&            err => $err,
\&        };
\&    };
.Ve
.PP
This is the first handler which accepts two different verb types, a \s-1GET\s0 for
a human browsing to the \s-1URL\s0 and a \s-1POST\s0 for the browser to submit the user's
input to the web application.  Since we're handling two different verbs, we
check to see what verb is in the request.  If it's \fBnot\fR a \s-1POST,\s0 we drop
down to the \f(CW\*(C`template\*(C'\fR directive and display the \fIlogin.tt\fR template:
.PP
.Vb 11
\&  <h2>Login</h2>
\&  [% IF err %]<p class=error><strong>Error:</strong> [% err %][% END %]
\&  <form action="[% login_url %]" method=post>
\&    <dl>
\&      <dt>Username:
\&      <dd><input type=text name=username>
\&      <dt>Password:
\&      <dd><input type=password name=password>
\&      <dd><input type=submit value=Login>
\&    </dl>
\&  </form>
.Ve
.PP
This is even simpler than our \fIshow_entries.tt\fR template–but wait– there's a
\&\f(CW\*(C`login_url\*(C'\fR template parameter and we're only passing in the
\&\f(CW\*(C`err\*(C'\fR parameter. Where's the missing parameter? It's being generated and
sent to the template in a \f(CW\*(C`before_template_render\*(C'\fR directive, we'll come
back to that in a moment or two.
.PP
So the user fills out the \fIlogin.tt\fR template and submits it back to the
\&\f(CW\*(C`/login\*(C'\fR route handler.  We now check the user input against our
application settings and if the input is incorrect, we alert the user, otherwise
the application starts a session and sets the \f(CW\*(C`logged_in\*(C'\fR session parameter
to the \f(CW\*(C`true()\*(C'\fR value. Dancer2 exports both a \f(CW\*(C`true()\*(C'\fR and \f(CW\*(C`false()\*(C'\fR
convenience method which we use here.  After that, it's another flash
message and back to the root \s-1URL\s0 handler.
.PP
\fILogging out\fR
.IX Subsection "Logging out"
.PP
And finally, we need a way to clear our user's session with the customary
logout procedure.
.PP
.Vb 5
\&    get \*(Aq/logout\*(Aq => sub {
\&        app\->destroy_session;
\&        set_flash(\*(AqYou are logged out.\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\&    };
.Ve
.PP
\&\f(CW\*(C`app\->destroy_session;\*(C'\fR is Dancer2's way to remove a stored session.
We notify the user she is logged out and route her back to the root \s-1URL\s0 once
again.
.PP
You might wonder how we can then set a value in the session in \f(CW\*(C`set_flash\*(C'\fR,
because we just destroyed the session.
.PP
Destroying the session has removed the data from the persistence layer (which
is the memory of our running application, because we are using the \f(CW\*(C`simple\*(C'\fR
session engine). If we write to \fIthe session\fR now, it will actually create
a completely new session for our user. This new, empty session will have a new
\&\fIsession \s-1ID\s0\fR, which Dancer2 tells the user's browser about in the response.
When the browser requests the root \s-1URL,\s0 it will send this new session \s-1ID\s0 to our
application.
.SS "Layout and static files"
.IX Subsection "Layout and static files"
We still have a missing puzzle piece or two. First, how can we use Dancer2
to serve our \s-1CSS\s0 stylesheet? Second, where are flash messages displayed?
Third, what about the \f(CW\*(C`before_template_render\*(C'\fR directive?
.PP
\fIServing static files\fR
.IX Subsection "Serving static files"
.PP
In Dancer2, static files should go into the \f(CW\*(C`public/\*(C'\fR directory, but in the
application itself be sure to omit the \f(CW\*(C`public/\*(C'\fR element from the path.  For
example, the stylesheet for dancr lives in \f(CW\*(C`dancr/public/css/style.css\*(C'\fR but
is served from <http://localhost:3000/css/style.css>.
.PP
If you wanted to build a mostly static web site you could simply write route
handlers like this one:
.PP
.Vb 3
\&    get \*(Aq/\*(Aq => sub {
\&        send_file \*(Aqindex.html\*(Aq;
\&    };
.Ve
.PP
where index.html would live in your \f(CW\*(C`public/\*(C'\fR directory.
.PP
\&\f(CW\*(C`send_file\*(C'\fR does exactly what it says: it loads a static file, then sends
the contents of that file to the user.
.PP
Let's go ahead and create our style sheet. In the same directory as your dancr.pl
script, issue the following commands:
.PP
.Vb 1
\&    mkdir public && mkdir public/css && touch public/css/style.css
.Ve
.PP
Next add the following css to the \f(CW\*(C`public/css/style.css\*(C'\fR file you just created:
.PP
.Vb 5
\&    body            { font\-family: sans\-serif; background: #eee; }
\&    a, h1, h2       { color: #377ba8; }
\&    h1, h2          { font\-family: \*(AqGeorgia\*(Aq, serif; margin: 0; }
\&    h1              { border\-bottom: 2px solid #eee; }
\&    h2              { font\-size: 1.2em; }
\&
\&    .page           { margin: 2em auto; width: 35em; border: 5px solid #ccc;
\&                      padding: 0.8em; background: white; }
\&    .entries        { list\-style: none; margin: 0; padding: 0; }
\&    .entries li     { margin: 0.8em 1.2em; }
\&    .entries li h2  { margin\-left: \-1em; }
\&    .add\-entry      { font\-size: 0.9em; border\-bottom: 1px solid #ccc; }
\&    .add\-entry dl   { font\-weight: bold; }
\&    .metanav        { text\-align: right; font\-size: 0.8em; padding: 0.3em;
\&                      margin\-bottom: 1em; background: #fafafa; }
\&    .flash          { background: #cee5F5; padding: 0.5em;
\&                      border: 1px solid #aacbe2; }
\&    .error          { background: #f0d6d6; padding: 0.5em; }
.Ve
.PP
Be sure to save the file.
.PP
\fILayouts\fR
.IX Subsection "Layouts"
.PP
I mentioned earlier in the tutorial that it is possible to
create a \f(CW\*(C`layout\*(C'\fR template. In dancr, that layout is called \f(CW\*(C`main\*(C'\fR and
it's set up by putting in a directive like this:
.PP
.Vb 1
\&    set layout => \*(Aqmain\*(Aq;
.Ve
.PP
near the top of your web application.  This tells Dancer2's template
engine that it should look for a file called \fImain.tt\fR in
\&\f(CW\*(C`views/layouts/\*(C'\fR and insert the calls from the \f(CW\*(C`template\*(C'\fR directive
into a template parameter called \f(CW\*(C`content\*(C'\fR.
.PP
Here is the simple layout file we will use for this web application. Go ahead
and add this the \fImain.tt\fR file to the \f(CW\*(C`views/layouts/\*(C'\fR directory.
.PP
.Vb 10
\&  <!doctype html>
\&  <html>
\&  <head>
\&    <title>dancr</title>
\&    <link rel=stylesheet type=text/css href="[% css_url %]">
\&  </head>
\&  <body>
\&    <div class=page>
\&    <h1>dancr</h1>
\&       <div class=metanav>
\&       [% IF not session.logged_in %]
\&         <a href="[% login_url %]">log in</a>
\&       [% ELSE %]
\&         <a href="[% logout_url %]">log out</a>
\&       [% END %]
\&    </div>
\&    [% IF msg %]
\&      <div class=flash> [% msg %] </div>
\&    [% END %]
\&    [% content %]
\&  </div>
\&  </body>
\&  </html>
.Ve
.PP
Aha! You now see where the flash message \f(CW\*(C`msg\*(C'\fR parameter gets rendered. You
can also see where the content from the specific route handlers is inserted
(the fourth line from the bottom in the \f(CW\*(C`content\*(C'\fR template parameter).
.PP
But what about all those other \f(CW*_url\fR template parameters?
.PP
\fIUsing \f(CI\*(C`before_template_render\*(C'\fI\fR
.IX Subsection "Using before_template_render"
.PP
Dancer2 has a way to manipulate the template parameters before they're
passed to the engine for processing. It's \f(CW\*(C`before_template_render\*(C'\fR. Using
this keyword, you can generate and set the URIs for the \f(CW\*(C`/login\*(C'\fR and
\&\f(CW\*(C`/logout\*(C'\fR route handlers and the \s-1URI\s0 for the stylesheet. This is handy for
situations like this where there are values which are re-used consistently
across all (or most) templates. This cuts down on code-duplication and
makes your app easier to maintain over time since you only need to update
the values in this one place instead of everywhere you render a template.
.PP
.Vb 2
\&    hook before_template_render => sub {
\&        my $tokens = shift;
\&
\&        $tokens\->{\*(Aqcss_url\*(Aq}    = request\->base . \*(Aqcss/style.css\*(Aq;
\&        $tokens\->{\*(Aqlogin_url\*(Aq}  = uri_for(\*(Aq/login\*(Aq);
\&        $tokens\->{\*(Aqlogout_url\*(Aq} = uri_for(\*(Aq/logout\*(Aq);
\&    };
.Ve
.PP
Here again I'm using \f(CW\*(C`uri_for\*(C'\fR instead of hardcoding the routes.  This code
block is executed before any of the templates are processed so that the
template parameters have the appropriate values before being rendered.
.SS "Putting it all together"
.IX Subsection "Putting it all together"
Here's the complete 'dancr.pl' script from start to finish.
.PP
.Vb 5
\&    use Dancer2;
\&    use DBI;
\&    use File::Spec;
\&    use File::Slurper qw/ read_text /;
\&    use Template;
\&
\&    set \*(Aqdatabase\*(Aq     => File::Spec\->catfile(File::Spec\->tmpdir(), \*(Aqdancr.db\*(Aq);
\&    set \*(Aqsession\*(Aq      => \*(AqSimple\*(Aq;
\&    set \*(Aqtemplate\*(Aq     => \*(Aqtemplate_toolkit\*(Aq;
\&    set \*(Aqlogger\*(Aq       => \*(Aqconsole\*(Aq;
\&    set \*(Aqlog\*(Aq          => \*(Aqdebug\*(Aq;
\&    set \*(Aqshow_errors\*(Aq  => 1;
\&    set \*(Aqstartup_info\*(Aq => 1;
\&    set \*(Aqusername\*(Aq     => \*(Aqadmin\*(Aq;
\&    set \*(Aqpassword\*(Aq     => \*(Aqpassword\*(Aq;
\&    set \*(Aqlayout\*(Aq       => \*(Aqmain\*(Aq;
\&
\&    sub set_flash {
\&        my $message = shift;
\&
\&        session flash => $message;
\&    }
\&
\&    sub get_flash {
\&        my $msg = session(\*(Aqflash\*(Aq);
\&        session\->delete(\*(Aqflash\*(Aq);
\&
\&        return $msg;
\&    }
\&
\&    sub connect_db {
\&        my $dbh = DBI\->connect("dbi:SQLite:dbname=".setting(\*(Aqdatabase\*(Aq))
\&            or die $DBI::errstr;
\&
\&        return $dbh;
\&    }
\&
\&    sub init_db {
\&        my $db     = connect_db();
\&        my $schema = read_text(\*(Aq./schema.sql\*(Aq);
\&        $db\->do($schema)
\&            or die $db\->errstr;
\&    }
\&
\&    hook before_template_render => sub {
\&        my $tokens = shift;
\&
\&        $tokens\->{\*(Aqcss_url\*(Aq}    = request\->base . \*(Aqcss/style.css\*(Aq;
\&        $tokens\->{\*(Aqlogin_url\*(Aq}  = uri_for(\*(Aq/login\*(Aq);
\&        $tokens\->{\*(Aqlogout_url\*(Aq} = uri_for(\*(Aq/logout\*(Aq);
\&    };
\&
\&    get \*(Aq/\*(Aq => sub {
\&        my $db  = connect_db();
\&        my $sql = \*(Aqselect id, title, text from entries order by id desc\*(Aq;
\&
\&        my $sth = $db\->prepare($sql)
\&            or die $db\->errstr;
\&
\&        $sth\->execute
\&            or die $sth\->errstr;
\&
\&        template \*(Aqshow_entries.tt\*(Aq, {
\&            msg           => get_flash(),
\&            add_entry_url => uri_for(\*(Aq/add\*(Aq),
\&            entries       => $sth\->fetchall_hashref(\*(Aqid\*(Aq),
\&        };
\&    };
\&
\&    post \*(Aq/add\*(Aq => sub {
\&        if ( not session(\*(Aqlogged_in\*(Aq) ) {
\&            send_error("Not logged in", 401);
\&        }
\&
\&        my $db  = connect_db();
\&        my $sql = \*(Aqinsert into entries (title, text) values (?, ?)\*(Aq;
\&
\&        my $sth = $db\->prepare($sql)
\&            or die $db\->errstr;
\&
\&        $sth\->execute(
\&            body_parameters\->get(\*(Aqtitle\*(Aq),
\&            body_parameters\->get(\*(Aqtext\*(Aq)
\&        ) or die $sth\->errstr;
\&
\&        set_flash(\*(AqNew entry posted!\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\&    };
\&
\&    any [\*(Aqget\*(Aq, \*(Aqpost\*(Aq] => \*(Aq/login\*(Aq => sub {
\&        my $err;
\&
\&        if ( request\->method() eq "POST" ) {
\&            # process form input
\&            if ( body_parameters\->get(\*(Aqusername\*(Aq) ne setting(\*(Aqusername\*(Aq) ) {
\&                $err = "Invalid username";
\&            }
\&            elsif ( body_parameters\->get(\*(Aqpassword\*(Aq) ne setting(\*(Aqpassword\*(Aq) ) {
\&                $err = "Invalid password";
\&            }
\&            else {
\&                session \*(Aqlogged_in\*(Aq => true;
\&                set_flash(\*(AqYou are logged in.\*(Aq);
\&                return redirect \*(Aq/\*(Aq;
\&            }
\&        }
\&
\&        # display login form
\&        template \*(Aqlogin.tt\*(Aq, {
\&            err => $err,
\&        };
\&
\&    };
\&
\&    get \*(Aq/logout\*(Aq => sub {
\&        app\->destroy_session;
\&        set_flash(\*(AqYou are logged out.\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\&    };
\&
\&    init_db();
\&    start;
.Ve
.PP
\fIAdvanced route moves\fR
.IX Subsection "Advanced route moves"
.PP
There's a lot more to route matching than shown here. For example, you can
match routes with regular expressions, or you can match pieces of a route
like \f(CW\*(C`/hello/:name\*(C'\fR where the \f(CW\*(C`:name\*(C'\fR piece magically turns into a named
parameter in your handler for manipulation.
.PP
You can explore this and other advanced concepts by reading the Dancer2::Manual.
.ie n .SH "Part II: Taking Advantage of the ""dancer2"" Utility to Set Up New Apps"
.el .SH "Part II: Taking Advantage of the \f(CWdancer2\fP Utility to Set Up New Apps"
.IX Header "Part II: Taking Advantage of the dancer2 Utility to Set Up New Apps"
In Part I, we took an ordinary Perl script and turned it into a simple web
app to teach you basic Dancer2 concepts. While starting with a simple script
like this helped make it easier to teach these concepts, it did not demonstrate
how a typical app is built by a Dancer2 developer. So let's show you how things
really get done.
.SS "Creating a new app"
.IX Subsection "Creating a new app"
So now that you have a better idea of what goes into building an app with
Dancer2, it's time to cha-cha with the \f(CW\*(C`dancer2\*(C'\fR utility which will save you a
lot of time and effort by setting up directories, files, and default
configuration settings for you.
.PP
The \f(CW\*(C`dancer2\*(C'\fR utility was installed on your machine when you installed the
Dancer2 distribution. Hop over to the command line into a directory you have
permission to write to and issue the following command:
.PP
.Vb 1
\&    dancer2 gen \-a Dancr2
.Ve
.PP
That command should output something like the following to the console:
.PP
.Vb 10
\&    + Dancr2
\&    + Dancr2/config.yml
\&    + Dancr2/Makefile.PL
\&    + Dancr2/MANIFEST.SKIP
\&    + Dancr2/.dancer
\&    + Dancr2/cpanfile
\&    + Dancr2/bin
\&    + Dancr2/bin/app.psgi
\&    + Dancr2/environments
\&    + Dancr2/environments/development.yml
\&    + Dancr2/environments/production.yml
\&    + Dancr2/lib
\&    + Dancr2/lib/Dancr2.pm
\&    + Dancr2/public
\&    + Dancr2/public/favicon.ico
\&    + Dancr2/public/500.html
\&    + Dancr2/public/dispatch.cgi
\&    + Dancr2/public/404.html
\&    + Dancr2/public/dispatch.fcgi
\&    + Dancr2/public/css
\&    + Dancr2/public/css/error.css
\&    + Dancr2/public/css/style.css
\&    + Dancr2/public/images
\&    + Dancr2/public/images/perldancer.jpg
\&    + Dancr2/public/images/perldancer\-bg.jpg
\&    + Dancr2/public/javascripts
\&    + Dancr2/public/javascripts/jquery.js
\&    + Dancr2/t
\&    + Dancr2/t/001_base.t
\&    + Dancr2/t/002_index_route.t
\&    + Dancr2/views
\&    + Dancr2/views/index.tt
\&    + Dancr2/views/layouts
\&    + Dancr2/views/layouts/main.tt
.Ve
.PP
What you just did was create a fully functional app in Dancer2 with just one
command! The new app, named \*(L"Dancr2,\*(R" won't do anything particularly useful until
you add your own routes to it, but it does take care of many of the tedious tasks
of setting up an app for you.
.PP
The files and folders that were generated and that you see listed above provide
a convenient scaffolding, or \fBskeleton\fR, upon which you can build your app. The
default skelelton provides you with basic error pages, css, javascript,
graphics, tests, templates and other files which you are free to modify and
customize to your liking.
.PP
If you don't like the default skeleton provided to you by Dancer, the \f(CW\*(C`dancer2\*(C'\fR
command allows you to generate your own custom skeletons. Consult
\&\*(L"BOOTSTRAPPING-A-NEW-APP\*(R" in Dancer2::Manual for further details on this and other
capabilities of the \f(CW\*(C`dancer2\*(C'\fR) utility.
.SS "Getting the new app up and running with Plack"
.IX Subsection "Getting the new app up and running with Plack"
In Part I, we used the \f(CW\*(C`start\*(C'\fR command in our script to launch a
server to serve our app. Things are a little different when using \f(CW\*(C`dancer2\*(C'\fR,
however. You'll notice that the \f(CW\*(C`dancer2\*(C'\fR utility created a \f(CW\*(C`bin/\*(C'\fR directory
with a file in it called \f(CW\*(C`app.psgi\*(C'\fR. This is the file we use to get our
app up and running.
.PP
Let's see how to to do that by first changing into the Dancr2 directory and
then starting the server using the \f(CW\*(C`plackup\*(C'\fR command:
.PP
.Vb 2
\&    cd Dancr2;
\&    plackup \-p 5000 bin/app.psgi
.Ve
.PP
If all went well, you'll be able to see the Dancr2 home page by visiting:
.PP
.Vb 1
\&    http://localhost:5000
.Ve
.PP
The web page you see there gives you some very basic advice for tuning and
modifying your app and where you can go for more information to learn about
developing apps with Dancer2 (like this handy tutorial!).
.PP
Our Dancr2 app is served on a simple web server provided by Plack. Plack is 
\&\s-1PSGI\s0 compliant software, hence the \f(CW\*(C`psgi\*(C'\fR extension for our file in the \f(CW\*(C`bin/\*(C'\fR
directory. Plack and \s-1PSGI\s0 is beyond the scope of this tutorial but you can learn
more by visiting the Plack website <http://plackperl.org/>.
.PP
For now, all you need to know is that if you are deploying an app for use by
just yourself or a handful of people on a local network, Plack alone may do the
trick. More typically, you would use Plack in conjunction with other server
software to make your app much more robust. But in the early stages of your app's
development, a simple Plack server is more than likely all you need.
.PP
To learn more about the different ways for deploying your app, see the
Dancer2 Deployment Manual
.SS "Porting dancr.pl over to the new Dancr2 app"
.IX Subsection "Porting dancr.pl over to the new Dancr2 app"
Ok, so now that we've got our new Dancr2 app up and running, it's time to learn
how to take advantage of what the \f(CW\*(C`dancer2\*(C'\fR utility set up for us by porting
our dancr.pl script created in Part I into Dancr2.
.PP
\fIThe \f(CI\*(C`lib/\*(C'\fI directory\fR
.IX Subsection "The lib/ directory"
.PP
The \f(CW\*(C`lib/\*(C'\fR directory in our Dancr2 app is where our \f(CW\*(C`app.psgi\*(C'\fR file will
expect our code to live. So let's take a peek at the file generated for us
in there:
.PP
.Vb 1
\&    cat lib/Dancr2.pm
.Ve
.PP
You'll see something like the following bit of code which provides a single
route to our app's home page and loads the index template:
.PP
.Vb 2
\&    package Dancr2;
\&    use Dancer2;
\&
\&    our $VERSION = \*(Aq0.1\*(Aq;
\&
\&    get \*(Aq/\*(Aq => sub {
\&        template \*(Aqindex\*(Aq => { title => \*(AqDancr2\*(Aq };
\&    };
\&
\&    true;
.Ve
.PP
The first thing you'll notice is that instead of a script, we are using a module,
\&\f(CW\*(C`Dancr2\*(C'\fR to package our code. Modules make it easer to pull off many powerful
tricks like packaging our app across several discrete modules. We'll let the
manual explain this more
advanced technique.
.PP
\fIUpdating the Dancr2 module\fR
.IX Subsection "Updating the Dancr2 module"
.PP
Now that we know where to put our code, let's update the \f(CW\*(C`Dancr2.pm\*(C'\fR module
with our original \f(CW\*(C`dancr.pl\*(C'\fR code. Remove the existing sample route in
\&\f(CW\*(C`Dancr2.pm\*(C'\fR and replace it with the code from our \f(CW\*(C`dancr.pl\*(C'\fR file. You'll have
to make a couple of adjustments to the \f(CW\*(C`dancr.pl\*(C'\fR code like removing the
\&\f(CW\*(C`use Dancer2;\*(C'\fR line since it's already provided by our module. You'll also want
to be sure to remove the \f(CW\*(C`start;\*(C'\fR line as well from the end of the file.
.PP
When you're done, \f(CW\*(C`Dancr2.pm\*(C'\fR should look something close to this:
.PP
.Vb 2
\&    package Dancr2;
\&    use Dancer2;
\&
\&    our $VERSION = \*(Aq0.1\*(Aq;
\&
\&    # Our original dancr.pl code with some minor tweaks
\&    use DBI;
\&    use File::Spec;
\&    use File::Slurper qw/ read_text /;
\&    use Template;
\&
\&    set \*(Aqdatabase\*(Aq => File::Spec\->catfile(File::Spec\->tmpdir(), \*(Aqdancr.db\*(Aq);
\&    set \*(Aqsession\*(Aq  => \*(AqYAML\*(Aq;
\&    ...
\&
\&    <snip> # The rest of the stuff </snip>
\&
\&    ...
\&
\&    sub init_db {
\&        my $schema = read_text(\*(Aq./schema.sql\*(Aq);
\&        $db\->do($schema)
\&            or die $db\->errstr;
\&    }
\&
\&    get \*(Aq/logout\*(Aq => sub {
\&        app\->destroy_session;
\&        set_flash(\*(AqYou are logged out.\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\&    };
\&
\&    init_db();
.Ve
.PP
Finally, to avoid getting an error in the \f(CW\*(C`init_db\*(C'\fR) subroutine when it tries to
load our schema file, copy over the \f(CW\*(C`schema.db\*(C'\fR file to the root directory of
the Dancr2 app:
.PP
.Vb 1
\&    cp /path/to/dancr.pl/schema.db /path/to/Dancr2;
.Ve
.PP
Ok, now that we've got the code moved over, let's move the assets from dancr.pl
to our new app.
.PP
\fIThe \f(CI\*(C`public/\*(C'\fI directory\fR
.IX Subsection "The public/ directory"
.PP
As mentioned in Part I, our static assets go into our \f(CW\*(C`public/\*(C'\fR directory. If
you followed along with the tutorial in Part I, you should have a \f(CW\*(C`public/\*(C'\fR
directory with a \f(CW\*(C`public/css\*(C'\fR subdirectory and a file called \f(CW\*(C`style.css\*(C'\fR
within that.
.PP
Dancer2 has conveniently generated the \f(CW\*(C`public/css\*(C'\fR directory for us which has 
a default css file. Let's copy the style sheet from our original app so our new
app can use it:
.PP
.Vb 2
\&    # Note: This command overwrites the default style sheet. Move it or copy
\&    # it if you wish to preserve it.
\&
\&    cp /path/to/dancr.pl/public/css/style.css /path/to/Dancr2/public/css;
.Ve
.PP
\fIThe \f(CI\*(C`views\*(C'\fI directory\fR
.IX Subsection "The views directory"
.PP
Along with our \f(CW\*(C`public/\*(C'\fR directory, Dancer has also provided a \f(CW\*(C`views/\*(C'\fR directory,
which as we covered, serves as the a home for our templates. Let's get those
copied over now:
.PP
.Vb 2
\&    # NOTE: This command will overwrite the default main.tt tempalte file. Move
\&    # it or copy it if you wish to preserve it.
\&
\&    cp \-r /path/to/dancr.pl/views/* /path/to/Dancr2/views;
.Ve
.PP
\fIDoes it work?\fR
.IX Subsection "Does it work?"
.PP
If you followed the instructions here closely, your Dancr2 app should be working.
Shut down any running Plack servers and then issue the same plackup command to
see if it runs:
.PP
.Vb 2
\&    cd /path/to/Dancr2
\&    plackup \-p 5000 bin/app.psgi
.Ve
.PP
If you see any errors, get them resolved until the app loads.
.SS "Configuring Your App"
.IX Subsection "Configuring Your App"
In Part I, you configured your app with a series of \f(CW\*(C`set\*(C'\fR statements near the
top of your file. Now we will show you a better way to configure your app using
Dancer2's configuration files.
.PP
Your skeleton provides your app with three different configuration files. The
first two files we'll discuss, found in the \f(CW\*(C`environments/\*(C'\fR folder of
your app, are \f(CW\*(C`development.yml\*(C'\fR and \f(CW\*(C`production.yml\*(C'\fR. As you can probably
guess, the \f(CW\*(C`development.yml\*(C'\fR file has settings intended to be used while
developing the app. The \f(CW\*(C`production.yml\*(C'\fR file has settings more appropriate
for running your app when used by others. The third configuration file is found
in the root directory of your app and is named \f(CW\*(C`config.yml\*(C'\fR. This file has the
settings that are common to all environments but that can be overridden by the
environment configuration files. You can still override any configuration file
settings in your modules using the \f(CW\*(C`set\*(C'\fR command.
.PP
We will take a look at the \f(CW\*(C`development.yml\*(C'\fR file first. Open that file in
your text editor and take a look inside. It has a bunch of helpful comments and
the following five settings sprinkled throughout:
.PP
.Vb 4
\&    logger: "console"
\&    log: "core"
\&    show_errors: 1
\&    startup_info: 1
.Ve
.PP
The first four settings duplicate many of the settings in our new Dancr2 app. So
in the spirit of \s-1DRY\s0 (don't repeat yourself), edit your Dancr2 module and delete
the four lines that correspond to these four settings.
.PP
Then, in the configuration file, be sure to change the value for the \f(CW\*(C`log\*(C'\fR
setting from \*(L"core\*(R" to \*(L"debug\*(R" so it matches the value we had in our module.
.PP
We will leave it up to you what you want to do with the fourth setting,
\&\f(CW\*(C`startup_info\*(C'\fR. You can read about that setting, along with all the other
settings, in the configuration manual.
.PP
Finally, let's add a new setting to the configuration file for \f(CW\*(C`session\*(C'\fR with
the following line:
.PP
.Vb 1
\&    session: "Simple"
.Ve
.PP
Then delete the corresponding setting from your Dancr2 module.
.PP
Alright, our Dancr2 app is a little leaner and meaner. Now open the main
\&\f(CW\*(C`config.yml\*(C'\fR file and look for the settings in there that are also duplicated in
our app's module. There are two:
.PP
.Vb 2
\&    layout: "main"
\&    template: "simple"
.Ve
.PP
Leave \f(CW\*(C`layout\*(C'\fR as is but change the template setting to \*(L"template_toolkit\*(R".
Then edit your Dancr2 module file and delete these two settings.
.PP
Finally, add the following configuration settings to the .yml file:
.PP
.Vb 2
\&    username: "admin"
\&    password: "password"
.Ve
.PP
Then you delete these two settings from the Dancr2 module, as well.
.PP
So, if you have been following along, you now have only the following \f(CW\*(C`set\*(C'\fR
command in your Dancr2 module, related to the database configuration:
.PP
.Vb 1
\&    set \*(Aqdatabase\*(Aq => File::Spec\->catfile(File::Spec\->tmpdir(), \*(Aqdancr.db\*(Aq);
.Ve
.PP
We will get rid of this setting in Part \s-1III\s0 of the tutorial. All the rest of the
settings have been transferred to our configuration files. Nice!
.PP
We still have a little more cleanup we can do. Now that Dancer2 knows we are
using Template::Toolkit, we can delete the \f(CW\*(C`use Template;\*(C'\fR line from our
module.
.PP
Now start the app \f(CW\*(C`plackup\*(C'\fR command and check to see that everything works. By
default, Dancer2 will load the development environment configuration. When it
comes time to put your app into production, you can load the \f(CW\*(C`production.yml\*(C'\fR
file configuration with plackup's \f(CW\*(C`\-\-env\*(C'\fR switch like so:
.PP
.Vb 1
\&    plackup \-p 5000 \-\-env production bin/app.psgi
.Ve
.SS "Keep on Dancing!"
.IX Subsection "Keep on Dancing!"
This concludes Part \s-1II\s0 of our tutorial where we showed you how to take advantage
of the \f(CW\*(C`dancer2\*(C'\fR utility to set up a app skeleton to make it really easy to get
started developing your own apps.
.PP
Part \s-1III\s0 will refine our app a little further by showing you how to use plugins
so you can start capitalizing on all the great work contributed by other
Dancer2 developers.
.SH "Part III: Plugins, Your Many Dancing Partners"
.IX Header "Part III: Plugins, Your Many Dancing Partners"
Dancer2 takes advantage of the open source software revolution by making it
exceedingly easy to use plugins that you can mix into your app to give it new
functionality. In Part \s-1III\s0 of this tutorial, we will update our new Dancr2 app
to use the Dancer2::Plugin::Database to give you enough skills to go out and
explore other plugins on your own.
.SS "Installing plugins"
.IX Subsection "Installing plugins"
Like Dancer2 itself, Dancer2 plugins can be found on the \s-1CPAN.\s0 Use your
favorite method for downloading and installing the Dancer2::Plugin::Database
module on your machine. We recommend using \f(CW\*(C`cpanminus\*(C'\fR like so:
.PP
.Vb 1
\&    cpanm Dancer2::Plugin::Database
.Ve
.SS "Using plugins"
.IX Subsection "Using plugins"
Using a plugin couldn't be easier. Simply add the following line to your Dancr2
module below the \f(CW\*(C`use Dancer2;\*(C'\fR line in your module:
.PP
.Vb 1
\&    use Dancer2::Plugin::Database;
.Ve
.SS "Configuring plugins"
.IX Subsection "Configuring plugins"
Plugins can be configured with the \s-1YAML\s0 configuration files mentioned in Part \s-1II\s0
of this tutorial. Let's edit the \f(CW\*(C`development.yml\*(C'\fR file and add our database
configuration there. Below the last line in that file, add the following lines,
being careful to keep the indentation as you see it here:
.PP
.Vb 6
\&  plugins:                 # all plugin configuration settings go in this section
\&    Database:              # the name of our plugin
\&      driver: "SQLite"     # driver we want to use
\&      database: "dancr.db" # where the database will go in our app
\&                           # run a query when connecting to the datbase:
\&      on_connect_do: [ "create table if not exists entries (id integer primary key autoincrement, title string not null, text string not null)" ]
.Ve
.PP
Here, we direct our database plugin to use the \*(L"SQLite\*(R" driver and to
place the database in the root directory of our Dancr2. The \f(CW\*(C`on_connect_db\*(C'\fR
setting tells the plugin to run an \s-1SQL\s0 query when it connects with the database
to create a table for us if it doesn't already exist.
.SS "Modifying our database code in the Dancr2 module"
.IX Subsection "Modifying our database code in the Dancr2 module"
Now it's time to modify our Dancr2 module so it will use the plugin to query the
database instead of our own code. There are a few things to do. First, we will
delete the code we no longer need.
.PP
Since our configuration file tells the plugin where our database is, we can
delete this line:
.PP
.Vb 1
\&    set \*(Aqdatabase\*(Aq => File::Spec\->catfile(File::Spec\->tmpdir(), \*(Aqdancr.db\*(Aq);
.Ve
.PP
And since the database plugin will create our database connection and initialize
our database for us, we can scrap the following two subroutines and line from our
module:
.PP
.Vb 3
\&    sub connect_db {
\&        my $dbh = DBI\->connect("dbi:SQLite:dbname=".setting(\*(Aqdatabase\*(Aq))
\&            or die $DBI::errstr;
\&
\&        return $dbh;
\&    }
\&
\&    sub init_db {
\&        my $db = connect_db();
\&        my $schema = read_text(\*(Aq./schema.sql\*(Aq);
\&        $db\->do($schema)
\&            or die $db\->errstr;
\&    }
\&
\&    init_db(); # Found at the bottom of our file
.Ve
.PP
With that done, let's now take advantage of a hook the plugin provides us that
we can use to handle certain events by adding the following command to our
module to handle database errors:
.PP
.Vb 4
\&    hook \*(Aqdatabase_error\*(Aq => sub {
\&        my $error = shift;
\&        die $error;
\&    };
.Ve
.PP
Now let's make a few adjustments to the bits of code that make the
database queries. In our \f(CW\*(C`get \*(Aq/\*(Aq\*(C'\fR route, change all instances of \f(CW$db\fR with
\&\f(CW\*(C`database\*(C'\fR and remove all the \f(CW\*(C`die\*(C'\fR calls since we now have a hook to
handle the errors for us. When you are done, your route should look something
like this:
.PP
.Vb 10
\&    get \*(Aq/\*(Aq => sub {
\&        my $sql = \*(Aqselect id, title, text from entries order by id desc\*(Aq;
\&        my $sth = database\->prepare($sql);
\&        $sth\->execute;
\&        template \*(Aqshow_entries.tt\*(Aq, {
\&            msg           => get_flash(),
\&            add_entry_url => uri_for(\*(Aq/add\*(Aq),
\&            entries       => $sth\->fetchall_hashref(\*(Aqid\*(Aq),
\&        };
\&    };
.Ve
.PP
Make the same changes to the \f(CW\*(C`post \*(Aq/add\*(Aq\*(C'\fR route to transform it into this:
.PP
.Vb 4
\&    post \*(Aq/add\*(Aq => sub {
\&        if ( not session(\*(Aqlogged_in\*(Aq) ) {
\&            send_error("Not logged in", 401);
\&        }
\&
\&        my $sql = \*(Aqinsert into entries (title, text) values (?, ?)\*(Aq;
\&        my $sth = database\->prepare($sql);
\&        $sth\->execute(
\&            body_parameters\->get(\*(Aqtitle\*(Aq),
\&            body_parameters\->get(\*(Aqtext\*(Aq)
\&        );
\&
\&        set_flash(\*(AqNew entry posted!\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\&    };
.Ve
.PP
Our last step is to get rid of the following lines which we no longer need,
thanks to our plugin:
.PP
.Vb 3
\&  use DBI;
\&  use File::Spec;
\&  use File::Slurper qw/ read_text /;
.Ve
.PP
That's it! Now start your app with \f(CW\*(C`plackup\*(C'\fR to make sure you don't get any
errors and then point your browser to test the app to make sure it works as
expected. If it doesn't, double and triple check your configuration settings and
your module's code which should now look like this:
.PP
.Vb 3
\&    package Dancr2;
\&    use Dancer2;
\&    use Dancer2::Plugin::Database;
\&
\&    our $VERSION = \*(Aq0.1\*(Aq;
\&
\&    my $flash;
\&
\&    sub set_flash {
\&        my $message = shift;
\&
\&        $flash = $message;
\&    }
\&
\&    sub get_flash {
\&        my $msg = $flash;
\&        $flash  = "";
\&
\&        return $msg;
\&    }
\&
\&    hook before_template_render => sub {
\&        my $tokens = shift;
\&
\&        $tokens\->{\*(Aqcss_url\*(Aq}    = request\->base . \*(Aqcss/style.css\*(Aq;
\&        $tokens\->{\*(Aqlogin_url\*(Aq}  = uri_for(\*(Aq/login\*(Aq);
\&        $tokens\->{\*(Aqlogout_url\*(Aq} = uri_for(\*(Aq/logout\*(Aq);
\&    };
\&
\&    hook \*(Aqdatabase_error\*(Aq => sub {
\&        my $error = shift;
\&        die $error;
\&    };
\&
\&    get \*(Aq/\*(Aq => sub {
\&        my $sql = \*(Aqselect id, title, text from entries order by id desc\*(Aq;
\&        my $sth = database\->prepare($sql);
\&        $sth\->execute;
\&        template \*(Aqshow_entries.tt\*(Aq, {
\&            msg           => get_flash(),
\&            add_entry_url => uri_for(\*(Aq/add\*(Aq),
\&            entries       => $sth\->fetchall_hashref(\*(Aqid\*(Aq),
\&        };
\&    };
\&
\&    post \*(Aq/add\*(Aq => sub {
\&        if ( not session(\*(Aqlogged_in\*(Aq) ) {
\&            send_error("Not logged in", 401);
\&        }
\&
\&        my $sql = \*(Aqinsert into entries (title, text) values (?, ?)\*(Aq;
\&        my $sth = database\->prepare($sql);
\&        $sth\->execute(
\&            body_parameters\->get(\*(Aqtitle\*(Aq),
\&            body_parameters\->get(\*(Aqtext\*(Aq)
\&        );
\&
\&        set_flash(\*(AqNew entry posted!\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\&    };
\&
\&    any [\*(Aqget\*(Aq, \*(Aqpost\*(Aq] => \*(Aq/login\*(Aq => sub {
\&        my $err;
\&
\&        if ( request\->method() eq "POST" ) {
\&            # process form input
\&            if ( params\->{\*(Aqusername\*(Aq} ne setting(\*(Aqusername\*(Aq) ) {
\&                $err = "Invalid username";
\&            }
\&            elsif ( params\->{\*(Aqpassword\*(Aq} ne setting(\*(Aqpassword\*(Aq) ) {
\&                $err = "Invalid password";
\&            }
\&            else {
\&                session \*(Aqlogged_in\*(Aq => true;
\&                set_flash(\*(AqYou are logged in.\*(Aq);
\&                return redirect \*(Aq/\*(Aq;
\&            }
\&        }
\&
\&        # display login form
\&        template \*(Aqlogin.tt\*(Aq, {
\&            err => $err,
\&        };
\&
\&    };
\&
\&    get \*(Aq/logout\*(Aq => sub {
\&        app\->destroy_session;
\&        set_flash(\*(AqYou are logged out.\*(Aq);
\&        redirect \*(Aq/\*(Aq;
\&    };
\&
\&    true;
.Ve
.SS "Next steps"
.IX Subsection "Next steps"
Congrats! You are now using the database plugin like a boss. The database plugin
does a lot more than what we showed you here. We'll leave it up to you to consult
the Dancer2::Plugin::Database to unlock its full potential.
.PP
There are many more plugins for you to explore. You now know enough to install
and experiment with them. Some of the more popular and useful plugins are listed
at Dancer2::Plugins. You can also search \s-1CPAN\s0 with \*(L"Dancer2::Plugin\*(R" for a
more comprehensive listing.
.PP
If you are feeling really inspired, you can learn how to extend Dancer2 with
your own plugins by reading Dancer2::Plugin.
.SH "Happy dancing!"
.IX Header "Happy dancing!"
I hope these tutorials have been helpful and interesting enough to get you
exploring Dancer2 on your own. The framework is still under development but
it's definitely mature enough to use in a production project.
.PP
Happy dancing!
.SS "One more thing: Test!"
.IX Subsection "One more thing: Test!"
Before we go, we want to mention that Dancer2 makes it very easy to
run automated tests on your app to help you find bugs. If you are new to
testing, we encourage you to start learning how. Your future self will thank you.
The effort you put into creating tests for your app will save you many hours of
frustration in the long run. Unfortunately, until we get Part \s-1IV\s0 of this tutorial
written, you'll have to consult the Dancer2 testing documentation
for more details on how to test your app.
.PP
Enjoy!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
<http://perldancer.org>
.IP "\(bu" 4
<http://github.com/PerlDancer/Dancer2>
.IP "\(bu" 4
Dancer2::Plugins
.SH "CSS COPYRIGHT AND LICENSE"
.IX Header "CSS COPYRIGHT AND LICENSE"
The \s-1CSS\s0 stylesheet is copied verbatim from the Flaskr example application
and is subject to their license:
.PP
Copyright (c) 2010, 2013 by Armin Ronacher and contributors.
.PP
Some rights reserved.
.PP
Redistribution and use in source and binary forms of the software as well as
documentation, with or without modification, are permitted provided that the
following conditions are met:
.IP "\(bu" 4
Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
.IP "\(bu" 4
Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
.IP "\(bu" 4
The names of the contributors may not be used to endorse or promote products
derived from this software without specific prior written permission.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dancer Core Developers
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2022 by Alexis Sukrieh.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
