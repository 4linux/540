.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dancer2::Manual::Deployment 3"
.TH Dancer2::Manual::Deployment 3 "2022-03-14" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer2::Manual::Deployment \- common ways to put your Dancer app into use
.SH "VERSION"
.IX Header "VERSION"
version 0.400000
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Dancer has been designed to be flexible, and this flexibility extends to your
choices when deploying your Dancer app.
.SS "Running stand-alone"
.IX Subsection "Running stand-alone"
To start your application, just run plackup:
.PP
.Vb 2
\&    $ plackup bin/app.psgi
\&    HTTP::Server::PSGI: Accepting connections at http://0:5000/
.Ve
.PP
Point your browser at it, and away you go!
.PP
This option can be useful for small personal web apps or internal apps, but if
you want to make your app available to the world, it probably won't suit you.
.PP
\fIAuto Reloading the Application\fR
.IX Subsection "Auto Reloading the Application"
.PP
While developing your application, it is often handy to have the server
automatically reload your application when changes are made. There are
two recommended ways of handling this with Dancer: using \f(CW\*(C` plackup \-r \*(C'\fR
and Plack::Loader::Shotgun. Both have their advantages and disadvantages
(which will be explained below).
.PP
Regardless of the method you use, it is \fB not \fR recommended that you
automatically reload your applications in a production environment, for
reasons of performance, deployment best practices, etc.
.PP
For Dancer 1 programmers that used the \f(CW\*(C` auto_reload \*(C'\fR option, please use
one of these alternatives instead:
.PP
Auto reloading with \f(CW\*(C` plackup \-r \*(C'\fR
.IX Subsection "Auto reloading with plackup -r "
.PP
Plack's built-in reloader will reload your application anytime a file in
your application's directory (usually, \fI /bin \fR) changes. You will likely
want to monitor your \fI lib/ \fR directory too, using the \f(CW\*(C` \-R \*(C'\fR option:
.PP
.Vb 1
\&    $ plackup \-r \-R lib bin/app.psgi
.Ve
.PP
There is a performance hit associated with this, as Plack will spin off
a separate process that monitors files in the application and other
specified directories. If the timestamp of any files in a watched
directory changes, the application is recompiled and reloaded.
.PP
See the plackup docs for more information on the \f(CW\*(C` \-r \*(C'\fR and \f(CW\*(C` \-R \*(C'\fR
options.
.PP
Auto reloading with plackup and Shotgun
.IX Subsection "Auto reloading with plackup and Shotgun"
.PP
There may be circumstances where Plack's built-in reloader won't work for
you, be it for the way it looks for changes, or because there are many
directories you need to monitor, or you want to reload the application any
time one of the modules in Perl's \fI lib/ \fR path changes.
Plack::Loader::Shotgun makes this easy by recompiling the application
on every request.
.PP
To use Shotgun, specify it using the loader argument to \f(CW\*(C` plackup (\-L) \*(C'\fR:
.PP
.Vb 1
\&    $ plackup \-L Shotgun bin/app.psgi
.Ve
.PP
The Shotgun, while effective, can quickly cause you performance issues, even
during the development phase of your application. As the number of plugins
you use in your application grows, as the number of static resources (images,
etc.) grows, the more requests your server process needs to handle. Since
each request recompiles the application, even simple page refreshes can get
unbearably slow over time. Use with caution.
.PP
You can bypass Shotgun's auto-reloading of specific modules with the
\&\f(CW\*(C` \-M \*(C'\fR switch:
.PP
.Vb 1
\&    $ plackup \-L Shotgun \-M<MyApp::Foo> \-M<MyApp::Bar> bin/app.psgi
.Ve
.PP
On Windows, Shotgun loader is known to cause huge memory leaks in a
fork-emulation layer. If you are aware of this and still want to run the
loader, please use the following command:
.PP
.Vb 2
\&    > set PLACK_SHOTGUN_MEMORY_LEAK=1 && plackup \-L Shotgun bin\eapp.psgi
\&    HTTP::Server::PSGI: Accepting connections at http://0:5000/
.Ve
.PP
\&\fBPlease note: \fR if you are using Dancer 2's asynchronous capabilities, using
Shotgun will kill Twiggy. If you need async processing, consider an
alternative to Shotgun.
.SS "Running under Apache"
.IX Subsection "Running under Apache"
You can run your Dancer app from Apache using the following examples:
.PP
\fIAs a \s-1CGI\s0 script\fR
.IX Subsection "As a CGI script"
.PP
In its simplest form, your Dancer app can be run as a simple \s-1CGI\s0 script
out-of-the-box. You will need to enable the Apache mod_cgi or mod_cgid modules
(\f(CW\*(C`a2enmod cgi\*(C'\fR or \f(CW\*(C`a2enmod cgid\*(C'\fR on Debian-based systems) and mod_rewrite
(\f(CW\*(C`a2enmod rewrite\*(C'\fR). The Perl module Plack::Runner is required.
.PP
The following is an example apache configuration. Depending on your Apache
configuration layout, this should be placed in \f(CW\*(C`httpd.conf\*(C'\fR or
\&\f(CW\*(C`sites\-available/*site*\*(C'\fR. The configuration options can also be placed in
\&\f(CW\*(C`.htaccess\*(C'\fR files if you prefer.
.PP
.Vb 2
\&    <VirtualHost *:80>
\&        ServerName www.example.com
\&
\&        # /srv/www.example.com is the root of your
\&        # dancer application
\&        DocumentRoot /srv/www.example.com/public
\&
\&        ServerAdmin you@example.com
\&
\&        <Directory "/srv/www.example.com/public">
\&            AllowOverride None
\&            Options +ExecCGI \-MultiViews +SymLinksIfOwnerMatch
\&            AddHandler cgi\-script .cgi
\&            # Apache 2.2
\&            Order allow,deny
\&            Allow from all
\&            # Apache 2.4
\&            Require all granted
\&        </Directory>
\&
\&        RewriteEngine On
\&        RewriteCond %{REQUEST_FILENAME} !\-f
\&        RewriteRule ^(.*)$ /dispatch.cgi$1 [QSA,L]
\&
\&        ErrorLog  /var/log/apache2/www.example.com\-error.log
\&        CustomLog /var/log/apache2/www.example.com\-access_log common
\&    </VirtualHost>
.Ve
.PP
Now you can access your dancer application URLs as if you were using the
embedded web server.
.PP
.Vb 1
\&    http://www.example.com/
.Ve
.PP
This option is a no-brainer, easy to setup and low maintenance, but serves
requests slower than all other options, as each time a request is made to your
server, Apache will start your application. This might be suitable for a small,
occasionally-used sites, as the application is not using resources when it is
not being accessed. For anything more, you probably want to use FastCGI instead
(see next section).
.PP
To list all currently loaded modules, type \f(CW\*(C`apachectl \-M\*(C'\fR
(\f(CW\*(C`apache2ctl \-M\*(C'\fR on Debian/Ubuntu).
.PP
\fIAs a FastCGI script\fR
.IX Subsection "As a FastCGI script"
.PP
This has all the easy-to-setup and low-maintenance advantages of \s-1CGI,\s0 but is
much faster for each request, as it keeps a copy of the application running all
the time.
.PP
You will still need to enable \f(CW\*(C`mod_rewrite\*(C'\fR, but will need to use a FastCGI
module instead of a \s-1CGI\s0 module. There are 3 available:
mod_fcgid <http://httpd.apache.org/mod_fcgid/>,
mod_fastcgi <http://www.fastcgi.com/> and
mod_proxy_fcgi <https://httpd.apache.org/docs/trunk/mod/mod_proxy_fcgi.html>.
For this example, we will use mod_fastcgi (\f(CW\*(C`a2enmod fastcgi\*(C'\fR in Debian).
.PP
The \s-1CGI\s0 configuration above now changes as follows (differences highlighted
with \s-1XXX\s0):
.PP
.Vb 2
\&    <VirtualHost *:80>
\&        ServerName www.example.com
\&
\&        # /srv/www.example.com is the root of your
\&        # dancer application
\&        DocumentRoot /srv/www.example.com/public
\&
\&        ServerAdmin you@example.com
\&
\&        # XXX Start a FastCGI server to run in the background
\&        FastCgiServer /srv/www.example.com/public/dispatch.fcgi
\&
\&        <Directory "/srv/www.example.com/public">
\&            AllowOverride None
\&            Options +ExecCGI \-MultiViews +SymLinksIfOwnerMatch
\&            # XXX Use FastCGI handler instead of CGI
\&            AddHandler fastcgi\-script .fcgi
\&            # Apache 2.2
\&            Order allow,deny
\&            Allow from all
\&            # Apache 2.4
\&            Require all granted
\&        </Directory>
\&
\&        RewriteEngine On
\&        RewriteCond %{REQUEST_FILENAME} !\-f
\&        # Run FastCGI dispatcher instead of CGI dispatcher
\&        RewriteRule ^(.*)$ /dispatch.fcgi$1 [QSA,L]
\&
\&        ErrorLog  /var/log/apache2/www.example.com\-error.log
\&        CustomLog /var/log/apache2/www.example.com\-access_log common
\&    </VirtualHost>
.Ve
.PP
This is the easiest way to get a production server up and running, as there is
no need to worry about daemonizing your application. Apache manages all that
for you.
.PP
Reloading your application
.IX Subsection "Reloading your application"
.PP
You can use \f(CW\*(C`apache2ctl restart\*(C'\fR or \f(CW\*(C`apache2ctl graceful\*(C'\fR to reload your
application. The latter will be more friendly to your users in a production
environment. If your application loads relatively quickly, then it should go
unnoticed.
.PP
Configuration
.IX Subsection "Configuration"
.PP
See <http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html> for FastCGI
configuration options. An example configuration:
.PP
.Vb 1
\&   FastCgiServer /srv/www.example.com/public/dispatch.fcgi \-processes 5 \-initial\-env DANCER_ENVIRONMENT="production"
.Ve
.PP
\fIWith Plack\fR
.IX Subsection "With Plack"
.PP
You can run your app from Apache using \s-1PSGI\s0 (Plack), with a config like the
following:
.PP
.Vb 4
\&    <VirtualHost myapp.example.com>
\&        ServerName www.myapp.example.com
\&        ServerAlias myapp.example.com
\&        DocumentRoot /websites/myapp.example.com
\&
\&        <Directory /home/myapp/myapp>
\&            AllowOverride None
\&            Order allow,deny
\&            Allow from all
\&        </Directory>
\&
\&        <Location />
\&            SetHandler perl\-script
\&            PerlResponseHandler Plack::Handler::Apache2
\&            PerlSetVar psgi_app /websites/myapp.example.com/app.psgi
\&        </Location>
\&
\&        ErrorLog  /websites/myapp.example.com/logs/error_log
\&        CustomLog /websites/myapp.example.com/logs/access_log common
\&    </VirtualHost>
.Ve
.PP
To set the environment you want to use for your application (production or
development), you can set it this way:
.PP
.Vb 5
\&    <VirtualHost>
\&        ...
\&        SetEnv DANCER_ENVIRONMENT "production"
\&        ...
\&    </VirtualHost>
.Ve
.PP
\fIRunning multiple applications under the same virtualhost\fR
.IX Subsection "Running multiple applications under the same virtualhost"
.PP
If you want to deploy multiple applications under the same \f(CW\*(C`VirtualHost\*(C'\fR
(using one application per directory, for example) you can use the following
example Apache configuration.
.PP
This example uses the FastCGI dispatcher that comes with Dancer, but you should
be able to adapt this to use any other way of deployment described in this
guide. The only purpose of this example is to show how to deploy multiple
applications under the same base directory/virtualhost.
.PP
.Vb 5
\&    <VirtualHost *:80>
\&        ServerName localhost
\&        DocumentRoot "/path/to/rootdir"
\&        RewriteEngine On
\&        RewriteCond %{REQUEST_FILENAME} !\-f
\&
\&        <Directory "/path/to/rootdir">
\&            AllowOverride None
\&            Options +ExecCGI \-MultiViews +SymLinksIfOwnerMatch
\&            Order allow,deny
\&            Allow from all
\&            AddHandler fastcgi\-script .fcgi
\&        </Directory>
\&
\&        RewriteRule /App1(.*)$ /App1/public/dispatch.fcgi$1 [QSA,L]
\&        RewriteRule /App2(.*)$ /App2/public/dispatch.fcgi$1 [QSA,L]
\&        ...
\&        RewriteRule /AppN(.*)$ /AppN/public/dispatch.fcgi$1 [QSA,L]
\&    </VirtualHost>
.Ve
.PP
Of course, if your Apache configuration allows that, you can put the
RewriteRules in a .htaccess file directly within the application's directory,
which lets you add a new application without changing the Apache configuration.
.SS "Running on PSGI-based Perl webservers"
.IX Subsection "Running on PSGI-based Perl webservers"
A number of Perl web servers supporting \s-1PSGI\s0 are available on cpan:
.IP "Starman" 4
.IX Item "Starman"
\&\f(CW\*(C`Starman\*(C'\fR is a high performance web server, with support for preforking,
signals, multiple interfaces, graceful restarts and dynamic worker pool
configuration.
.IP "Twiggy" 4
.IX Item "Twiggy"
\&\f(CW\*(C`Twiggy\*(C'\fR is an \f(CW\*(C`AnyEvent\*(C'\fR web server, it's light and fast.
.IP "Corona" 4
.IX Item "Corona"
\&\f(CW\*(C`Corona\*(C'\fR is a \f(CW\*(C`Coro\*(C'\fR based web server.
.PP
Similar to running standalone, use plackup to start your application
(see Plack and specific servers above for all available options):
.PP
.Vb 2
\&    $ plackup bin/app.psgi
\&    $ plackup \-E deployment \-s Starman \-\-workers=10 \-p 5001 \-a bin/app.psgi
.Ve
.PP
As you can see, the scaffolded Perl script for your app can be used as a \s-1PSGI\s0
startup file.
.PP
\fIEnabling content compression\fR
.IX Subsection "Enabling content compression"
.PP
Content compression (gzip, deflate) can be easily enabled via a Plack
middleware (see \*(L"Plack::Middleware\*(R" in Plack): Plack::Middleware::Deflater.
It's a middleware to encode the response body in gzip or deflate, based on
the \f(CW\*(C`Accept\-Encoding\*(C'\fR \s-1HTTP\s0 request header.
.PP
Enable it as you would enable any Plack middleware. First you need to
install Plack::Middleware::Deflater, then in the handler (usually
\&\fIapp.psgi\fR) edit it to use Plack::Builder, as described above:
.PP
.Vb 3
\&    use Dancer2;
\&    use MyWebApp;
\&    use Plack::Builder;
\&
\&    builder {
\&        enable \*(AqDeflater\*(Aq;
\&        dance;
\&    };
.Ve
.PP
To test if content compression works, trace the \s-1HTTP\s0 request and response
before and after enabling this middleware. Among other things, you should
notice that the response is gzip or deflate encoded, and contains a header
\&\f(CW\*(C`Content\-Encoding\*(C'\fR set to \f(CW\*(C`gzip\*(C'\fR or \f(CW\*(C`deflate\*(C'\fR.
.PP
\fICreating a service\fR
.IX Subsection "Creating a service"
.PP
You can turn your app into proper service running in background using one of
the following examples:
.PP
Using Ubic
.IX Subsection "Using Ubic"
.PP
Ubic is an extensible perlish service manager. You can use it to start
and stop any services, automatically start them on reboots or daemon
failures, and implement custom status checks.
.PP
A basic \s-1PSGI\s0 service description (usually in \f(CW\*(C`/etc/ubic/service/application\*(C'\fR):
.PP
.Vb 1
\&    use parent qw(Ubic::Service::Plack);
\&
\&    # if your application is not installed in @INC path:
\&    sub start {
\&        my $self = shift;
\&        $ENV{PERL5LIB} = \*(Aq/path/to/your/application/lib\*(Aq;
\&        $self\->SUPER::start(@_);
\&    }
\&
\&    _\|_PACKAGE_\|_\->new(
\&        server => \*(AqStarman\*(Aq,
\&        app => \*(Aq/path/to/your/application/app.psgi\*(Aq,
\&        port => 5000,
\&        user => \*(Aqwww\-data\*(Aq,
\&    );
.Ve
.PP
Run \f(CW\*(C`ubic start application\*(C'\fR to start the service.
.PP
Using daemontools
.IX Subsection "Using daemontools"
.PP
daemontools is a collection of tools for managing \s-1UNIX\s0 services. You can use
it to easily start/restart/stop services.
.PP
A basic script to start an application: (in \f(CW\*(C`/service/application/run\*(C'\fR)
.PP
.Vb 1
\&    #!/bin/sh
\&
\&    # if your application is not installed in @INC path:
\&    export PERL5LIB=\*(Aq/path/to/your/application/lib\*(Aq
\&
\&    exec 2>&1 \e
\&    /usr/local/bin/plackup \-s Starman \-a /path/to/your/application/app.psgi \-p 5000
.Ve
.SS "Running stand-alone behind a proxy / load balancer"
.IX Subsection "Running stand-alone behind a proxy / load balancer"
Another option would be to run your app stand-alone as described above, but then
use a proxy or load balancer to accept incoming requests (on the standard port
80, say) and feed them to your Dancer app. Also, in this case you might want
to look at the \f(CW\*(C`behind_proxy\*(C'\fR configuration option, to make sure that all the
URLs are constructed properly.
.PP
.Vb 1
\&    behind_proxy: 1
.Ve
.PP
This setup can be achieved using various software; examples would include:
.PP
\fIUsing Apache's mod_proxy\fR
.IX Subsection "Using Apache's mod_proxy"
.PP
You could set up a \f(CW\*(C`VirtualHost\*(C'\fR for your web app, and proxy all requests through
to it:
.PP
.Vb 4
\&    <VirtualHost mywebapp.example.com:80>
\&    ProxyPass / http://localhost:3000/
\&    ProxyPassReverse / http://localhost:3000/
\&    </VirtualHost>
.Ve
.PP
Or, if you want your webapp to share an existing VirtualHost, you could have
it under a specified dir:
.PP
.Vb 2
\&    ProxyPass /mywebapp/ http://localhost:3000/
\&    ProxyPassReverse /mywebapp/ http://localhost:3000/
.Ve
.PP
It is important for you to note that the Apache2 modules \f(CW\*(C`mod_proxy\*(C'\fR and
\&\f(CW\*(C`mod_proxy_http\*(C'\fR must be enabled:
.PP
.Vb 2
\&    $ a2enmod proxy
\&    $ a2enmod proxy_http
.Ve
.PP
It is also important to set permissions for proxying for security purposes,
below is an example.
.PP
.Vb 4
\&    <Proxy *>
\&      Order allow,deny
\&      Allow from all
\&    </Proxy>
.Ve
.PP
\fIUsing perlbal\fR
.IX Subsection "Using perlbal"
.PP
\&\f(CW\*(C`Perlbal\*(C'\fR is a single-threaded event-based server written in Perl supporting
\&\s-1HTTP\s0 load balancing, web serving, and a mix of the two, available from
<http://www.danga.com/perlbal/>
.PP
It processes hundreds of millions of requests a day just for LiveJournal, Vox
and TypePad and dozens of other \*(L"Web 2.0\*(R" applications.
.PP
It can also provide a management interface to let you see various information on
requests handled etc.
.PP
It could easily be used to handle requests for your Dancer apps, too.
.PP
It can be easily installed from \s-1CPAN:\s0
.PP
.Vb 1
\&    perl \-MCPAN \-e \*(Aqinstall Perlbal\*(Aq
.Ve
.PP
Once installed, you'll need to write a configuration file.  See the examples
provided with perlbal, but you'll probably want something like:
.PP
.Vb 5
\&    CREATE POOL my_dancers
\&    POOL my_dancers ADD 10.0.0.10:3030
\&    POOL my_dancers ADD 10.0.0.11:3030
\&    POOL my_dancers ADD 10.0.0.12:3030
\&    POOL my_dancers ADD 10.0.0.13:3030
\&
\&    CREATE SERVICE my_webapp
\&    SET listen          = 0.0.0.0:80
\&    SET role            = reverse_proxy
\&    SET pool            = my_dancers
\&    SET persist_client  = on
\&    SET persist_backend = on
\&    SET verify_backend  = on
\&    ENABLE my_webapp
.Ve
.PP
\fIUsing balance\fR
.IX Subsection "Using balance"
.PP
\&\f(CW\*(C`balance\*(C'\fR is a simple load-balancer from Inlab Software, available from
<http://www.inlab.de/balance.html>.
.PP
It could be used simply to hand requests to a standalone Dancer app. You could
even run several instances of your Dancer app, on the same machine or on several
machines, and use a machine running \f(CW\*(C`balance\*(C'\fR to distribute the requests between
them, for some serious heavy traffic handling!
.PP
To listen on port 80, and send requests to a Dancer app on port 3000:
.PP
.Vb 1
\&    balance http localhost:3000
.Ve
.PP
To listen on a specified \s-1IP\s0 only on port 80, and distribute requests between
multiple Dancer apps on multiple other machines:
.PP
.Vb 1
\&    balance \-b 10.0.0.1 80 10.0.0.2:3000 10.0.0.3:3000 10.0.0.4:3000
.Ve
.PP
\fIUsing Lighttpd\fR
.IX Subsection "Using Lighttpd"
.PP
You can use Lighttpd's \f(CW\*(C`mod_proxy\*(C'\fR:
.PP
.Vb 7
\&    $HTTP["url"] =~ "/application" {
\&        proxy.server = (
\&            "/" => (
\&                "application" => ( "host" => "127.0.0.1", "port" => 3000 )
\&            )
\&        )
\&    }
.Ve
.PP
This configuration will proxy all request to the \fB/application\fR path to the
path \fB/\fR on localhost:3000.
.PP
\fIUsing Nginx\fR
.IX Subsection "Using Nginx"
.PP
with Nginx:
.PP
.Vb 3
\&    upstream backendurl {
\&        server unix:THE_PATH_OF_YOUR_PLACKUP_SOCKET_HERE.sock;
\&    }
\&
\&    server {
\&      listen       80;
\&      server_name YOUR_HOST_HERE;
\&
\&      access_log /var/log/YOUR_ACCESS_LOG_HERE.log;
\&      error_log  /var/log/YOUR_ERROR_LOG_HERE.log info;
\&
\&      root YOUR_ROOT_PROJECT/public;
\&      location / {
\&        try_files $uri @proxy;
\&        access_log off;
\&        expires max;
\&      }
\&
\&      location @proxy {
\&            proxy_set_header Host $http_host;
\&            proxy_set_header X\-Forwarded\-Host $host;
\&            proxy_set_header X\-Real\-IP $remote_addr;
\&            proxy_set_header X\-Forwarded\-For $proxy_add_x_forwarded_for;
\&            proxy_pass       http://backendurl;
\&      }
\&
\&    }
.Ve
.PP
You will need plackup to start a worker listening on a socket :
.PP
.Vb 2
\&    cd YOUR_PROJECT_PATH
\&    sudo \-u www plackup \-E production \-s Starman \-\-workers=2 \-l THE_PATH_OF_YOUR_PLACKUP_SOCKET_HERE.sock \-a bin/app.pl
.Ve
.PP
A good way to start this is to use \f(CW\*(C`daemontools\*(C'\fR and place this line with
all environments variables in the \*(L"run\*(R" file.
.PP
\fIUsing HAProxy\fR
.IX Subsection "Using HAProxy"
.PP
\&\f(CW\*(C`HAProxy\*(C'\fR is a reliable high-performance \s-1TCP/HTTP\s0 load balancer written in C available from
<https://www.haproxy.org/>.
.PP
Suppose we want to run an application at \f(CW\*(C`app.example.com:80\*(C'\fR and would to use two
backends listen on hosts \f(CW\*(C`app\-be1.example.com:3000\*(C'\fR and \f(CW\*(C`app\-be2.example.com:3000\*(C'\fR.
.PP
Here is HAProxy configuration file (haproxy.conf):
.PP
.Vb 11
\&    global
\&        nbproc  1
\&        maxconn 4096
\&        user    nobody
\&        group   nobody
\&        # haproxy logs will be collected by syslog
\&        # syslog: unix socket path or tcp pair (ipaddress:port)
\&        log     /var/run/log local0
\&        daemon
\&        # enable compression (haproxy v1.5\-dev13 and above required)
\&        tune.comp.maxlevel  5
\&
\&    defaults
\&        log     global
\&        option  httpclose
\&        option  httplog
\&        option  dontlognull
\&        option  forwardfor
\&        option  abortonclose
\&        mode    http
\&        balance roundrobin
\&        retries 3
\&        timeout connect         5s
\&        timeout server          30s
\&        timeout client          30s
\&        timeout http\-keep\-alive 200m
\&        # enable compression (haproxy v1.5\-dev13 and above required)
\&        compression algo gzip
\&        compression type text/html application/javascript text/css application/x\-javascript text/javascript
\&
\&    # application frontend (available at http://app.example.com)
\&    frontend app.example.com
\&        bind                  :80
\&        # modify request headers
\&        reqadd                X\-Forwarded\-Proto:\e http
\&        reqadd                X\-Forwarded\-Port:\e 80
\&        # modify response headers
\&        rspdel                ^Server:.*
\&        rspdel                ^X\-Powered\-By:.*
\&        rspadd                Server:\e Dethklok\e (Unix/0.2.3)
\&        rate\-limit sessions   1024
\&        acl is\-haproxy\-stats  path_beg /stats
\&        # uncomment if you\*(Aqd like to get haproxy usage statistics
\&        # use_backend haproxy   if is\-haproxy\-stats
\&        default_backend       dynamic
\&
\&    # haproxy statistics (available at http://app.example.com/stats)
\&    backend haproxy
\&        stats uri             /stats
\&        stats refresh         180s
\&        stats realm           app.example.com\e haproxy\e statistics
\&        # change credentials
\&        stats auth            admin1:password1
\&        stats auth            admin2:password2
\&        stats hide\-version
\&        stats show\-legends
\&
\&    # application backends
\&    backend dynamic
\&        # change path_info to check and value of the Host header sent to application server
\&        option httpchk HEAD / HTTP/1.1\er\enHost:\e app.example.com
\&        server app1 app\-be1.example.com:3000 check inter 30s
\&        server app2 app\-be2.example.com:3000 check inter 30s
.Ve
.PP
We will need to start the workers on each backend of our application. This can be done by starman utility:
.PP
.Vb 4
\&    # on app\-be1.example.com
\&    $ starman \-\-workers=2 \-\-listen :3000 /path/to/app.pl
\&    # on app\-be2.example.com
\&    $ starman \-\-workers=2 \-\-listen :3000 /path/to/app.pl
.Ve
.PP
Then start the haproxy itself:
.PP
.Vb 4
\&    # check the configuration..
\&    $ sudo haproxy \-c \-f haproxy.conf
\&    # now really start it..
\&    $ sudo haproxy \-f haproxy.conf
.Ve
.SS "Running on lighttpd"
.IX Subsection "Running on lighttpd"
\fIRunning on lighttpd (\s-1CGI\s0)\fR
.IX Subsection "Running on lighttpd (CGI)"
.PP
To run as a \s-1CGI\s0 app on lighttpd, just create a soft link to the \f(CW\*(C`dispatch.cgi\*(C'\fR
script (created when you run \f(CW\*(C`dancer \-a MyApp\*(C'\fR) inside your system's \f(CW\*(C`cgi\-bin\*(C'\fR
folder. Make sure \f(CW\*(C`mod_cgi\*(C'\fR is enabled.
.PP
.Vb 1
\&    ln \-s /path/to/MyApp/public/dispatch.cgi /usr/lib/cgi\-bin/mycoolapp.cgi
.Ve
.PP
\fIRunning on lighttpd (FastCGI)\fR
.IX Subsection "Running on lighttpd (FastCGI)"
.PP
Make sure \f(CW\*(C`mod_fcgi\*(C'\fR is enabled. You also must have \s-1FCGI\s0 installed.
.PP
This example configuration uses \s-1TCP/IP:\s0
.PP
.Vb 11
\&    $HTTP["url"] == "^/app" {
\&        fastcgi.server += (
\&            "/app" => (
\&                "" => (
\&                    "host" => "127.0.0.1",
\&                    "port" => "5000",
\&                    "check\-local" => "disable",
\&                )
\&            )
\&        )
\&    }
.Ve
.PP
Launch your application:
.PP
.Vb 1
\&    plackup \-s FCGI \-\-port 5000 bin/app.psgi
.Ve
.PP
This example configuration uses a socket:
.PP
.Vb 10
\&    $HTTP["url"] =~ "^/app" {
\&        fastcgi.server += (
\&            "/app" => (
\&                "" => (
\&                    "socket" => "/tmp/fcgi.sock",
\&                    "check\-local" => "disable",
\&                )
\&            )
\&        )
\&    }
.Ve
.PP
Launch your application:
.PP
.Vb 1
\&    plackup \-s FCGI \-\-listen /tmp/fcgi.sock bin/app.psgi
.Ve
.SS "Performance Improvements"
.IX Subsection "Performance Improvements"
The following modules can be used to speed up an app in Dancer2:
.IP "\(bu" 4
CGI::Deurl::XS
.IP "\(bu" 4
Class::XSAccessor
.IP "\(bu" 4
Cpanel::JSON::XS
.IP "\(bu" 4
Crypt::URandom
.IP "\(bu" 4
HTTP::XSCookies
.IP "\(bu" 4
HTTP::XSHeaders
.IP "\(bu" 4
Math::Random::ISAAC::XS
.IP "\(bu" 4
MooX::TypeTiny
.IP "\(bu" 4
Type::Tiny::XS
.IP "\(bu" 4
URL::Encode::XS
.IP "\(bu" 4
\&\s-1YAML::XS\s0
.PP
If you generated your application with \f(CW\*(C`dancer2 gen\*(C'\fR, you can easily install
these with the following command:
.PP
.Vb 1
\&    cpanm \-\-installdeps . \-\-with\-feature=accelerate
.Ve
.PP
To build them, you will need access to a C compiler, and using these modules
will prevent you from fatpacking your application.
.PP
These modules are installed by default when building a Docker container 
containing your application.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dancer Core Developers
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2022 by Alexis Sukrieh.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
