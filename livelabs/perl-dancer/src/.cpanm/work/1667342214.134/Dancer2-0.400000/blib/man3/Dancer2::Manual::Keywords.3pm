.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dancer2::Manual::Keywords 3"
.TH Dancer2::Manual::Keywords 3 "2022-03-14" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer2::Manual::Keywords \- Dancer2 DSL Keywords
.SH "VERSION"
.IX Header "VERSION"
version 0.400000
.SH "DSL KEYWORDS"
.IX Header "DSL KEYWORDS"
Dancer2 provides you with a \s-1DSL\s0 (Domain-Specific Language) which makes
implementing your web application trivial.
.PP
For example, take the following example:
.PP
.Vb 1
\&    use Dancer2;
\&
\&    get \*(Aq/hello/:name\*(Aq => sub {
\&        my $name = route_parameters\->get(\*(Aqname\*(Aq);
\&    };
\&    true;
.Ve
.PP
\&\f(CW\*(C`get\*(C'\fR and \f(CW\*(C`route_parameters\*(C'\fR are keywords provided by Dancer2.
.PP
This document lists all keywords provided by Dancer2. It does not cover
additional keywords which may be provided by loaded plugins; see the
documentation for plugins you use to see which additional keywords they make
available to you.
.SS "any"
.IX Subsection "any"
Defines a route for multiple \s-1HTTP\s0 methods at once:
.PP
.Vb 3
\&    any [\*(Aqget\*(Aq, \*(Aqpost\*(Aq] => \*(Aq/myaction\*(Aq => sub {
\&        # code
\&    };
.Ve
.PP
Or even, a route handler that would match any \s-1HTTP\s0 methods:
.PP
.Vb 3
\&    any \*(Aq/myaction\*(Aq => sub {
\&        # code
\&    };
.Ve
.SS "app"
.IX Subsection "app"
Returns an instance of the app. App is a Dancer2::Core::App.
.SS "body_parameters"
.IX Subsection "body_parameters"
Returns a Hash::MultiValue object from the body parameters.
.PP
.Vb 4
\&    post \*(Aq/\*(Aq => sub {
\&        my $last_name = body_parameters\->get(\*(Aqname\*(Aq);
\&        my @all_names = body_parameters\->get_all(\*(Aqname\*(Aq);
\&    };
.Ve
.SS "captures"
.IX Subsection "captures"
Returns a reference to a copy of \f(CW\*(C`%+\*(C'\fR, if there are named captures in the
route's regular expression.
.PP
.Vb 11
\&    get qr{
\&        / (?<object> user   | ticket | comment )
\&        / (?<action> delete | find )
\&        / (?<id> \ed+ )
\&        /?$
\&    }x
\&    , sub {
\&        my $value_for = captures;
\&        "i don\*(Aqt want to $value_for\->{action} " . 
\&            "the $value_for\->{object} $value_for\->{id} !"
\&    };
.Ve
.SS "cookie"
.IX Subsection "cookie"
Accesses a cookie value (or sets it). Note that this method will eventually
be preferred over \f(CW\*(C`set_cookie\*(C'\fR.
.PP
.Vb 3
\&    cookie lang => "fr\-FR";              # set a cookie and return its value
\&    cookie lang => "fr\-FR", expires => "2 hours";   # extra cookie info
\&    cookie "lang"                        # return a cookie value
.Ve
.PP
If your cookie value is a key/value \s-1URI\s0 string, like
.PP
.Vb 1
\&    token=ABC&user=foo
.Ve
.PP
\&\f(CW\*(C`cookie\*(C'\fR will only return the first part (\f(CW\*(C`token=ABC\*(C'\fR) if called in scalar
context. Use list context to fetch them all:
.PP
.Vb 1
\&    my @values = cookie "name";
.Ve
.SS "cookies"
.IX Subsection "cookies"
Accesses cookies values, it returns a hashref of Dancer2::Core::Cookie
objects:
.PP
.Vb 4
\&    get \*(Aq/some_action\*(Aq => sub {
\&        my $cookie = cookies\->{name};
\&        return $cookie\->value;
\&    };
.Ve
.PP
In case you have stored something other than a scalar in your cookie:
.PP
.Vb 5
\&    get \*(Aq/some_action\*(Aq => sub {
\&        my $cookie = cookies\->{oauth};
\&        my %values = $cookie\->value;
\&        return ($values{token}, $values{token_secret});
\&    };
.Ve
.SS "config"
.IX Subsection "config"
Accesses the configuration of the application:
.PP
.Vb 3
\&    get \*(Aq/appname\*(Aq => sub {
\&        return "This is " . config\->{appname};
\&    };
.Ve
.SS "content"
.IX Subsection "content"
Sets the content for the response. This \fBonly\fR works within a delayed
response.
.PP
This will crash:
.PP
.Vb 4
\&    get \*(Aq/\*(Aq => sub {
\&        # THIS WILL CRASH
\&        content \*(AqHello, world!\*(Aq;
\&    };
.Ve
.PP
But this will work just fine:
.PP
.Vb 6
\&    get \*(Aq/\*(Aq => sub {
\&        delayed {
\&            content \*(AqHello, world!\*(Aq;
\&            ...
\&        };
\&    };
.Ve
.SS "content_type"
.IX Subsection "content_type"
Sets the \fBcontent-type\fR rendered, for the current route handler:
.PP
.Vb 2
\&    get \*(Aq/cat/:txtfile\*(Aq => sub {
\&        content_type \*(Aqtext/plain\*(Aq;
\&
\&        # here we can dump the contents of route_parameters\->get(\*(Aqtxtfile\*(Aq)
\&    };
.Ve
.PP
You can use abbreviations for content types. For instance:
.PP
.Vb 2
\&    get \*(Aq/svg/:id\*(Aq => sub {
\&        content_type \*(Aqsvg\*(Aq;
\&
\&        # here we can dump the image with id route_parameters\->get(\*(Aqid\*(Aq)
\&    };
.Ve
.PP
Note that if you want to change the default content-type for every route,
it is easier to change the \f(CW\*(C`content_type\*(C'\fR setting instead.
.SS "context"
.IX Subsection "context"
Deprecated. Use app instead.
.SS "dance"
.IX Subsection "dance"
Alias for the \f(CW\*(C`start\*(C'\fR keyword. to_app is preferable.
.SS "dancer_app"
.IX Subsection "dancer_app"
Returns the app object. See app.
.SS "dancer_version"
.IX Subsection "dancer_version"
Returns the version of Dancer. If you need the major version, do something
like:
.PP
.Vb 1
\&    int(dancer_version);
.Ve
.PP
or (better), call \f(CW\*(C`dancer_major_version\*(C'\fR.
.SS "dancer_major_version"
.IX Subsection "dancer_major_version"
Returns the major version of Dancer.
.SS "debug"
.IX Subsection "debug"
Logs a message of debug level:
.PP
.Vb 1
\&    debug "This is a debug message";
.Ve
.PP
See Dancer2::Core::Role::Logger for details on how to configure where log
messages go.
.SS "decode_json ($string)"
.IX Subsection "decode_json ($string)"
Deserializes a \s-1JSON\s0 structure from an \s-1UTF\-8\s0 binary string.
.SS "del"
.IX Subsection "del"
Defines a route for \s-1HTTP\s0 \fB\s-1DELETE\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 1
\&    del \*(Aq/resource\*(Aq => sub { ... };
.Ve
.SS "delayed"
.IX Subsection "delayed"
Stream a response asynchronously. For more information, please see 
\&\*(L"Delayed responses (Async/Streaming)\*(R" in Dancer2::Manual, or 
this article <https://advent.perldancer.org/2020/22> in the 2020 Dancer 
Advent Calendar.
.SS "dirname"
.IX Subsection "dirname"
Returns the dirname of the path given:
.PP
.Vb 1
\&    my $dir = dirname($some_path);
.Ve
.SS "done"
.IX Subsection "done"
Close the streaming connection. Can only be called within a streaming 
response callback.
.SS "dsl"
.IX Subsection "dsl"
Allows access to the \s-1DSL\s0 within your plugin/application. Is an instance of
Dancer2::Core::DSL.
.SS "encode_json ($structure)"
.IX Subsection "encode_json ($structure)"
Serializes a structure to a \s-1UTF\-8\s0 binary \s-1JSON\s0 string.
.PP
Calling this function will \fBnot\fR trigger the serialization's hooks.
.SS "engine"
.IX Subsection "engine"
Given a namespace, returns the current engine object
.PP
.Vb 3
\&    my $template_engine = engine \*(Aqtemplate\*(Aq;
\&    my $html = $template_engine\->apply_renderer(...);
\&    $template_engine\->apply_layout($html);
.Ve
.SS "error"
.IX Subsection "error"
Logs a message of error level:
.PP
.Vb 1
\&    error "This is an error message";
.Ve
.PP
See Dancer2::Core::Role::Logger for details on how to configure where log
messages go.
.SS "false"
.IX Subsection "false"
Constant that returns a false value (0).
.SS "flush"
.IX Subsection "flush"
Flush headers when streaming a response. Necessary when content is called
multiple times.
.SS "forward"
.IX Subsection "forward"
Runs an \*(L"internal redirect\*(R" of the current route to another route. More
formally; when \f(CW\*(C`forward\*(C'\fR is executed, the current dispatch of the route is
aborted, the request is modified (altering query params or request method),
and the modified request following a new route is dispatched again. Any
remaining code (route and hooks) from the current dispatch will never be run
and the modified route's dispatch will execute hooks for the new route normally.
.PP
It effectively lets you chain routes together in a clean manner.
.PP
.Vb 1
\&    get \*(Aq/demo/articles/:article_id\*(Aq => sub {
\&
\&        # you\*(Aqll have to implement this next sub yourself :)
\&        change_the_main_database_to_demo();
\&
\&        forward "/articles/" . route_parameters\->get(\*(Aqarticle_id\*(Aq);
\&    };
.Ve
.PP
In the above example, the users that reach \fI/demo/articles/30\fR will
actually reach \fI/articles/30\fR but we've changed the database to demo
before.
.PP
This is pretty cool because it lets us retain our paths and offer a demo
database by merely going to \fI/demo/...\fR.
.PP
You'll notice that in the example we didn't indicate whether it was \fB\s-1GET\s0\fR
or \fB\s-1POST\s0\fR. That is because \f(CW\*(C`forward\*(C'\fR chains the same type of route the
user reached. If it was a \fB\s-1GET\s0\fR, it will remain a \fB\s-1GET\s0\fR (but if you do
need to change the method, you can do so; read on below for details.)
.PP
Also notice that \f(CW\*(C`forward\*(C'\fR only redirects to a new route. It does not redirect
the requests involving static files. This is because static files are handled
before Dancer2 tries to match the request to a route \- static files take
higher precedence.
.PP
This means that you will not be able to \f(CW\*(C`forward\*(C'\fR to a static file. If you
wish to do so, you have two options: either redirect (asking the browser to
make another request, but to a file path instead) or use \f(CW\*(C`send_file\*(C'\fR to
provide a file.
.PP
\&\fB\s-1WARNING:\s0\fR Any code after a \f(CW\*(C`forward\*(C'\fR is ignored, until the end of the
route. It's not necessary to use \f(CW\*(C`return\*(C'\fR with \f(CW\*(C`forward\*(C'\fR anymore.
.PP
.Vb 6
\&    get \*(Aq/foo/:article_id\*(Aq => sub {
\&        if ($condition) {
\&            forward "/articles/" . route_parameters\->get(\*(Aqarticle_id\*(Aq);
\&            # The following code WILL NOT BE executed
\&            do_stuff();
\&        }
\&
\&        more_stuff();
\&    };
.Ve
.PP
Note that \f(CW\*(C`forward\*(C'\fR doesn't parse \s-1GET\s0 arguments. So, you can't use
something like:
.PP
.Vb 1
\&    forward \*(Aq/home?authorized=1\*(Aq;
.Ve
.PP
But \f(CW\*(C`forward\*(C'\fR supports an optional hashref with parameters to be added to
the actual parameters:
.PP
.Vb 1
\&    forward \*(Aq/home\*(Aq, { authorized => 1 };
.Ve
.PP
Finally, you can add some more options to the \f(CW\*(C`forward\*(C'\fR method, in a third
argument, also as a hashref. That option is currently only used to change
the method of your request. Use with caution.
.PP
.Vb 1
\&    forward \*(Aq/home\*(Aq, { auth => 1 }, { method => \*(AqPOST\*(Aq };
.Ve
.SS "from_dumper ($structure)"
.IX Subsection "from_dumper ($structure)"
Deserializes a Data::Dumper structure.
.SS "from_json ($string, \e%options)"
.IX Subsection "from_json ($string, %options)"
Deserializes a \s-1JSON\s0 structure from a string. You should probably use
\&\f(CW\*(C`decode_json\*(C'\fR which expects a \s-1UTF\-8\s0 encoded binary string and
handles decoding it for you.
.SS "from_yaml ($structure)"
.IX Subsection "from_yaml ($structure)"
Deserializes a \s-1YAML\s0 structure.
.SS "get"
.IX Subsection "get"
Defines a route for \s-1HTTP\s0 \fB\s-1GET\s0\fR requests to the given path:
.PP
.Vb 3
\&    get \*(Aq/\*(Aq => sub {
\&        return "Hello world";
\&    }
.Ve
.PP
Note that a route to match \fB\s-1HEAD\s0\fR requests is automatically created as well.
.SS "halt"
.IX Subsection "halt"
Sets a response object with the content given.
.PP
When used as a return value from a hook, this breaks the execution flow and
renders the response immediately:
.PP
.Vb 3
\&    hook before => sub {
\&        if ($some_condition) {
\&            halt("Unauthorized");
\&
\&            # this code is not executed
\&            do_stuff();
\&        }
\&    };
\&
\&    get \*(Aq/\*(Aq => sub {
\&        "hello there";
\&    };
.Ve
.PP
\&\fB\s-1WARNING:\s0\fR Issuing a halt immediately exits the current route, and performs
the halt. Thus, any code after a halt is ignored, until the end of the route.
Hence, it's not necessary anymore to use \f(CW\*(C`return\*(C'\fR with halt.
.SS "header"
.IX Subsection "header"
Deprecated. Use response_header instead.
.SS "headers"
.IX Subsection "headers"
Deprecated. Use response_headers instead.
.SS "hook"
.IX Subsection "hook"
Adds a hook at some position. For example :
.PP
.Vb 4
\&  hook before_serializer => sub {
\&    my $content = shift;
\&    ...
\&  };
.Ve
.PP
There can be multiple hooks assigned to a given position, and each will be
executed in order.
.PP
See the \s-1HOOKS\s0 section for a list of available hooks.
.SS "info"
.IX Subsection "info"
Logs a message of \f(CW\*(C`info\*(C'\fR level:
.PP
.Vb 1
\&    info "This is an info message";
.Ve
.PP
See Dancer2::Core::Role::Logger for details on how to configure where log
messages go.
.SS "log"
.IX Subsection "log"
Logs messages at the specified level. For example:
.PP
.Vb 1
\&    log( debug => "This is a debug message." );
.Ve
.SS "mime"
.IX Subsection "mime"
Shortcut to access the instance object of Dancer2::Core::MIME. You should
read the Dancer2::Core::MIME documentation for full details, but the most
commonly-used methods are summarized below:
.PP
.Vb 2
\&    # set a new mime type
\&    mime\->add_type( foo => \*(Aqtext/foo\*(Aq );
\&
\&    # set a mime type alias
\&    mime\->add_alias( f => \*(Aqfoo\*(Aq );
\&
\&    # get mime type for an alias
\&    my $m = mime\->for_name( \*(Aqf\*(Aq );
\&
\&    # get mime type for a file (based on extension)
\&    my $m = mime\->for_file( "foo.bar" );
\&
\&    # get current defined default mime type
\&    my $d = mime\->default;
\&
\&    # set the default mime type using config.yml
\&    # or using the set keyword
\&    set default_mime_type => \*(Aqtext/plain\*(Aq;
.Ve
.SS "options"
.IX Subsection "options"
Defines a route for \s-1HTTP\s0 \fB\s-1OPTIONS\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 1
\&    options \*(Aq/resource\*(Aq => sub { ... };
.Ve
.SS "param"
.IX Subsection "param"
\&\fIThis method should be called from a route handler\fR.
This method is an accessor to the parameters hash table.
.PP
.Vb 5
\&   post \*(Aq/login\*(Aq => sub {
\&       my $username = param "user";
\&       my $password = param "pass";
\&       # ...
\&   };
.Ve
.PP
We now recommend using one of the specific keywords for parameters
(\f(CW\*(C`route_parameters\*(C'\fR, \f(CW\*(C`query_parameters\*(C'\fR, and \f(CW\*(C`body_parameters\*(C'\fR)
instead of \f(CW\*(C`params\*(C'\fR or \f(CW\*(C`param\*(C'\fR.
.SS "params"
.IX Subsection "params"
\&\fIThis method should be called from a route handler\fR.
It's an alias for the Dancer2::Core::Request params
accessor. It returns a hash (in
list context) or a hash reference (in scalar context) to all defined
parameters. Check \f(CW\*(C`param\*(C'\fR below to access quickly to a single parameter
value.
.PP
.Vb 3
\&    post \*(Aq/login\*(Aq => sub {
\&        # get all parameters as a single hash
\&        my %all_parameters = params;
\&
\&        // request all parmameters from a specific source: body, query, route
\&        my %body_parameters  = params(\*(Aqbody\*(Aq);
\&        my %route_parameters = params(\*(Aqroute\*(Aq);
\&        my %query_parameters = params(\*(Aqquery\*(Aq);
\&
\&        # any $source that is not body, query, or route generates an exception
\&        params(\*(Aqfake_source\*(Aq); // Unknown source params "fake_source"
\&    };
.Ve
.PP
We now recommend using one of the specific keywords for parameters
(\f(CW\*(C`route_parameters\*(C'\fR, \f(CW\*(C`query_parameters\*(C'\fR, and \f(CW\*(C`body_parameters\*(C'\fR)
instead of \f(CW\*(C`params\*(C'\fR or \f(CW\*(C`param\*(C'\fR.
.SS "pass"
.IX Subsection "pass"
\&\fIThis method should be called from a route handler\fR.
Tells Dancer2 to pass the processing of the request to the next matching
route.
.PP
\&\fB\s-1WARNING:\s0\fR Issuing a pass immediately exits the current route, and performs
the pass. Thus, any code after a pass is ignored, until the end of the
route. Hence, it's not necessary anymore to use \f(CW\*(C`return\*(C'\fR with pass.
.PP
.Vb 4
\&    get \*(Aq/some/route\*(Aq => sub {
\&        if (...) {
\&            # we want to let the next matching route handler process this one
\&            pass(...);
\&
\&            # this code will be ignored
\&            do_stuff();
\&        }
\&    };
.Ve
.PP
\&\fB\s-1WARNING:\s0\fR You cannot set the content before passing and have it remain,
even if you use the \f(CW\*(C`content\*(C'\fR keyword or set it directly in the response
object.
.SS "patch"
.IX Subsection "patch"
Defines a route for \s-1HTTP\s0 \fB\s-1PATCH\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 1
\&    patch \*(Aq/resource\*(Aq => sub { ... };
.Ve
.PP
(\f(CW\*(C`PATCH\*(C'\fR is a relatively new and not-yet-common \s-1HTTP\s0 verb, which is
intended to work as a \*(L"partial-PUT\*(R", transferring just the changes; please
see \s-1RFC5789\s0 <http://tools.ietf.org/html/rfc5789> for further details.)
.SS "path"
.IX Subsection "path"
Concatenates multiple paths together, without worrying about the underlying
operating system:
.PP
.Vb 1
\&    my $path = path(dirname($0), \*(Aqlib\*(Aq, \*(AqFile.pm\*(Aq);
.Ve
.PP
It also normalizes (cleans) the path aesthetically. It does not verify whether
the path exists, though.
.SS "post"
.IX Subsection "post"
Defines a route for \s-1HTTP\s0 \fB\s-1POST\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 3
\&    post \*(Aq/\*(Aq => sub {
\&        return "Hello world";
\&    }
.Ve
.SS "prefix"
.IX Subsection "prefix"
Defines a prefix for each route handler, like this:
.PP
.Vb 1
\&    prefix \*(Aq/home\*(Aq;
.Ve
.PP
From here, any route handler is defined to /home/*:
.PP
.Vb 1
\&    get \*(Aq/page1\*(Aq => sub {}; # will match \*(Aq/home/page1\*(Aq
.Ve
.PP
You can unset the prefix value:
.PP
.Vb 2
\&    prefix undef;
\&    get \*(Aq/page1\*(Aq => sub {}; # will match /page1
.Ve
.PP
For a safer alternative you can use lexical prefix like this:
.PP
.Vb 2
\&    prefix \*(Aq/home\*(Aq => sub {
\&        ## Prefix is set to \*(Aq/home\*(Aq here
\&
\&        get ...;
\&        get ...;
\&    };
\&    ## prefix reset to the previous version here
.Ve
.PP
This makes it possible to nest prefixes:
.PP
.Vb 2
\&   prefix \*(Aq/home\*(Aq => sub {
\&       ## some routes
\&
\&      prefix \*(Aq/private\*(Aq => sub {
\&         ## here we are under /home/private...
\&
\&         ## some more routes
\&      };
\&      ## back to /home
\&   };
\&   ## back to the root
.Ve
.PP
\&\fBNotice:\fR Once you have a prefix set, do not add a caret to the regex:
.PP
.Vb 3
\&    prefix \*(Aq/foo\*(Aq;
\&    get qr{^/bar} => sub { ... } # BAD BAD BAD
\&    get qr{/bar}  => sub { ... } # Good!
.Ve
.SS "prepare_app"
.IX Subsection "prepare_app"
You can introduce code you want to run when your app is loaded, similar to the
\&\f(CW\*(C`prepare_app\*(C'\fR in Plack::Middleware.
.PP
.Vb 2
\&    prepare_app {
\&        my $app = shift;
\&
\&        ... # do your thing
\&    };
.Ve
.PP
You should not close over the App instance, since you receive it as a first
argument. If you close over it, you \fBwill\fR have a memory leak.
.PP
.Vb 1
\&    my $app = app();
\&
\&    prepare_app {
\&        do_something_with_app($app); # MEMORY LEAK
\&    };
.Ve
.SS "psgi_app"
.IX Subsection "psgi_app"
Provides the same functionality as to_app but uses the deprecated
Dispatcher engine. You should use to_app instead.
.SS "push_header"
.IX Subsection "push_header"
Deprecated. Use \f(CW\*(C`push_response_header\*(C'\fR instead.
.SS "push_response_header"
.IX Subsection "push_response_header"
Do the same as \f(CW\*(C`response_header\*(C'\fR, but allow for multiple headers with the same
name.
.PP
.Vb 5
\&    get \*(Aq/send/header\*(Aq, sub {
\&        push_response_header \*(Aqx\-my\-header\*(Aq => \*(Aq1\*(Aq;
\&        push_response_header \*(Aqx\-my\-header\*(Aq => \*(Aq2\*(Aq;
\&        # will result in two headers "x\-my\-header" in the response
\&    }
.Ve
.SS "put"
.IX Subsection "put"
Defines a route for \s-1HTTP\s0 \fB\s-1PUT\s0\fR requests to the given \s-1URL:\s0
.PP
.Vb 1
\&    put \*(Aq/resource\*(Aq => sub { ... };
.Ve
.SS "query_parameters"
.IX Subsection "query_parameters"
Returns a Hash::MultiValue object from the request parameters.
.PP
.Vb 4
\&    /?foo=hello
\&    get \*(Aq/\*(Aq => sub {
\&        my $name = query_parameters\->get(\*(Aqfoo\*(Aq);
\&    };
\&
\&    /?name=Alice&name=Bob
\&    get \*(Aq/\*(Aq => sub {
\&        my @names = query_parameters\->get_all(\*(Aqname\*(Aq);
\&    };
.Ve
.SS "redirect"
.IX Subsection "redirect"
Generates a \s-1HTTP\s0 redirect (302). You can either redirect to a complete
different site or within the application:
.PP
.Vb 4
\&    get \*(Aq/twitter\*(Aq, sub {
\&        redirect \*(Aqhttp://twitter.com/me\*(Aq;
\&        # Any code after the redirect will not be executed.
\&    };
.Ve
.PP
\&\fB\s-1WARNING:\s0\fR Issuing a \f(CW\*(C`redirect\*(C'\fR immediately exits the current route.
Thus, any code after a \f(CW\*(C`redirect\*(C'\fR is ignored, until the end of the route.
Hence, it's not necessary anymore to use \f(CW\*(C`return\*(C'\fR with \f(CW\*(C`redirect\*(C'\fR.
.PP
You can also force Dancer to return a specific 300\-ish \s-1HTTP\s0 response code:
.PP
.Vb 3
\&    get \*(Aq/old/:resource\*(Aq, sub {
\&        redirect \*(Aq/new/\*(Aq . route_parameters\->get(\*(Aqresource\*(Aq), 301;
\&    };
.Ve
.SS "request"
.IX Subsection "request"
Returns a Dancer2::Core::Request object representing the current request.
.PP
See the Dancer2::Core::Request documentation for the methods you can
call, for example:
.PP
.Vb 3
\&    request\->referer;         # value of the HTTP referer header
\&    request\->remote_address;  # user\*(Aqs IP address
\&    request\->user_agent;      # User\-Agent header value
.Ve
.SS "request_data"
.IX Subsection "request_data"
Returns the request's body in data form
(in case a serializer is set, it will be in deserialized).
.PP
This allows us to distinguish between \f(CW\*(C`body_parameters\*(C'\fR, a representation
of request parameters (Hash::MultiValue) and other forms of content.
.SS "request_header"
.IX Subsection "request_header"
Returns request header(s).
.PP
.Vb 4
\&    get \*(Aq/get/headers\*(Aq => sub {
\&        my $xfoo = request_header \*(AqX\-Foo\*(Aq;
\&        ...
\&    };
.Ve
.SS "response"
.IX Subsection "response"
Returns the current response object, which is of type 
Dancer2::Core::Route::REQUEST.
.SS "response_header"
.IX Subsection "response_header"
Adds a custom header to response:
.PP
.Vb 3
\&    get \*(Aq/send/header\*(Aq, sub {
\&        response_header \*(Aqx\-my\-header\*(Aq => \*(Aqshazam!\*(Aq;
\&    }
.Ve
.PP
Note that it will overwrite the old value of the header, if any. To avoid
that, see \*(L"push_response_header\*(R".
.SS "response_headers"
.IX Subsection "response_headers"
Adds custom headers to response:
.PP
.Vb 3
\&    get \*(Aq/send/headers\*(Aq, sub {
\&        response_headers \*(AqX\-Foo\*(Aq => \*(Aqbar\*(Aq, \*(AqX\-Bar\*(Aq => \*(Aqfoo\*(Aq;
\&    }
.Ve
.SS "route_parameters"
.IX Subsection "route_parameters"
Returns a Hash::MultiValue object from the route parameters.
.PP
.Vb 4
\&    # /hello
\&    get \*(Aq/:foo\*(Aq => sub {
\&        my $foo = route_parameters\->get(\*(Aqfoo\*(Aq);
\&    };
.Ve
.SS "runner"
.IX Subsection "runner"
Returns the runner singleton. Type is Dancer2::Core::Runner.
.SS "send_as"
.IX Subsection "send_as"
Allows the current route handler to return specific content types to the
client using either a specified serializer or as html.
.PP
Any Dancer2 serializer may be used. The specified serializer class will
be loaded if required, or an error generated if the class can not be found.
Serializer configuration may be added to your apps \f(CW\*(C`engines\*(C'\fR configuration.
.PP
If \f(CW\*(C`html\*(C'\fR is specified, the content will be returned assuming it is \s-1HTML\s0 with
appropriate \f(CW\*(C`Content\-Type\*(C'\fR headers and encoded using the apps configured
\&\f(CW\*(C`charset\*(C'\fR (or \s-1UTF\-8\s0).
.PP
.Vb 2
\&    set serializer => \*(AqYAML\*(Aq;
\&    set template   => \*(AqTemplateToolkit\*(Aq;
\&
\&    # returns html (not YAML)
\&    get \*(Aq/\*(Aq => sub { send_as html => template \*(Aqwelcome.tt\*(Aq };
\&
\&    # return json (not YAML)
\&    get \*(Aq/json\*(Aq => sub {
\&        send_as JSON => [ some => { data => \*(Aqstructure\*(Aq } ];
\&    };
.Ve
.PP
\&\f(CW\*(C`send_as\*(C'\fR uses \*(L"send_file\*(R" to return the content immediately. You may
pass any option \f(CW\*(C`send_file\*(C'\fR supports as an extra option. For example:
.PP
.Vb 5
\&    # return json with a custom content_type header
\&    get \*(Aq/json\*(Aq => sub {
\&        send_as JSON => [ some => { data => \*(Aqstructure\*(Aq } ],
\&                { content_type => \*(Aqapplication/json; charset=UTF\-8\*(Aq },
\&    };
.Ve
.PP
\&\fB\s-1WARNING:\s0\fR Issuing a send_as immediately exits the current route, and
performs the \f(CW\*(C`send_as\*(C'\fR. Thus, any code after a \f(CW\*(C`send_as\*(C'\fR is ignored,
until the end of the route. Hence, it's not necessary to use \f(CW\*(C`return\*(C'\fR
with \f(CW\*(C`send_as\*(C'\fR.
.PP
.Vb 3
\&    get \*(Aq/some/route\*(Aq => sub {
\&        if (...) {
\&            send_as JSON => $some_data;
\&
\&            # this code will be ignored
\&            do_stuff();
\&        }
\&    };
.Ve
.SS "send_error"
.IX Subsection "send_error"
Returns a \s-1HTTP\s0 error. By default the \s-1HTTP\s0 code returned is 500:
.PP
.Vb 7
\&    get \*(Aq/photo/:id\*(Aq => sub {
\&        if (...) {
\&            send_error("Not allowed", 403);
\&        } else {
\&           # return content
\&        }
\&    }
.Ve
.PP
\&\fB\s-1WARNING:\s0\fR Issuing a send_error immediately exits the current route, and
performs the \f(CW\*(C`send_error\*(C'\fR. Thus, any code after a \f(CW\*(C`send_error\*(C'\fR is ignored,
until the end of the route. Hence, it's not necessary anymore to use \f(CW\*(C`return\*(C'\fR
with \f(CW\*(C`send_error\*(C'\fR.
.PP
.Vb 4
\&    get \*(Aq/some/route\*(Aq => sub {
\&        if (...) {
\&            # Something bad happened, stop immediately!
\&            send_error(..);
\&
\&            # this code will be ignored
\&            do_stuff();
\&        }
\&    };
.Ve
.SS "send_file"
.IX Subsection "send_file"
Lets the current route handler send a file to the client. Note that the path
of the file must be relative to the \fBpublic\fR directory unless you use the
\&\f(CW\*(C`system_path\*(C'\fR option (see below).
.PP
.Vb 3
\&    get \*(Aq/download/:file\*(Aq => sub {
\&        return send_file(route_parameters\->get(\*(Aqfile\*(Aq));
\&    }
.Ve
.PP
\&\fB\s-1WARNING:\s0\fR Issuing a \f(CW\*(C`send_file\*(C'\fR immediately exits the current route, and
performs the \f(CW\*(C`send_file\*(C'\fR. Thus, any code after a \f(CW\*(C`send_file\*(C'\fR is ignored,
until the end of the route. Hence, it's not necessary anymore to use \f(CW\*(C`return\*(C'\fR
with \f(CW\*(C`send_file\*(C'\fR.
.PP
.Vb 4
\&    get \*(Aq/some/route\*(Aq => sub {
\&        if (...) {
\&            # OK, send her what she wants...
\&            send_file(...);
\&
\&            # this code will be ignored
\&            do_stuff();
\&        }
\&    };
.Ve
.PP
\&\f(CW\*(C`send_file\*(C'\fR will use \s-1PSGI\s0 streaming if the server supports it (most, if
not all, do). You can explicitly disable streaming by passing
\&\f(CW\*(C`streaming => 0\*(C'\fR as an option to \f(CW\*(C`send_file\*(C'\fR.
.PP
.Vb 3
\&    get \*(Aq/download/:file\*(Aq => sub {
\&        send_file( route_parameters\->get(\*(Aqfile\*(Aq), streaming => 0 );
\&    }
.Ve
.PP
The content-type will be set depending on the current \s-1MIME\s0 types definition
(see \f(CW\*(C`mime\*(C'\fR if you want to define your own).
.PP
If your filename does not have an extension, you are passing in a filehandle,
or you need to force a specific mime type, you can pass it to \f(CW\*(C`send_file\*(C'\fR
as follows:
.PP
.Vb 2
\&    send_file(route_parameters\->get(\*(Aqfile\*(Aq), content_type => \*(Aqimage/png\*(Aq);
\&    send_file($fh, content_type => \*(Aqimage/png\*(Aq);
.Ve
.PP
Also, you can use your aliases or file extension names on \f(CW\*(C`content_type\*(C'\fR,
like this:
.PP
.Vb 1
\&    send_file(route_parameters\->get(\*(Aqfile\*(Aq), content_type => \*(Aqpng\*(Aq);
.Ve
.PP
The encoding of the file or filehandle may be specified by passing both
the \f(CW\*(C`content_type\*(C'\fR and \f(CW\*(C`charset\*(C'\fR options. For example:
.PP
.Vb 1
\&    send_file($fh, content_type => \*(Aqtext/csv\*(Aq, charset => \*(Aqutf\-8\*(Aq );
.Ve
.PP
For files outside your \fBpublic\fR folder, you can use the \f(CW\*(C`system_path\*(C'\fR
switch. Just bear in mind that its use needs caution as it can be dangerous.
.PP
.Vb 1
\&   send_file(\*(Aq/etc/passwd\*(Aq, system_path => 1);
.Ve
.PP
If you have your data in a scalar variable, \f(CW\*(C`send_file\*(C'\fR can be useful as
well. Pass a reference to that scalar, and \f(CW\*(C`send_file\*(C'\fR will behave as if
there was a file with that contents:
.PP
.Vb 1
\&   send_file( \e$data, content_type => \*(Aqimage/png\*(Aq );
.Ve
.PP
Note that Dancer is unable to guess the content type from the data contents.
Therefore you might need to set the \f(CW\*(C`content_type\*(C'\fR properly. For this kind
of usage an attribute named \f(CW\*(C`filename\*(C'\fR can be useful. It is used as the
Content-Disposition header, to hint the browser about the filename it should
use.
.PP
.Vb 2
\&   send_file( \e$data, content_type => \*(Aqimage/png\*(Aq
\&                      filename     => \*(Aqonion.png\*(Aq );
.Ve
.PP
By default the Content-Disposition header uses the \*(L"attachment\*(R" type, which
triggers a \*(L"Save\*(R" dialog in some browsers. Supply a \f(CW\*(C`content_disposition\*(C'\fR
attribute of \*(L"inline\*(R" to have the file displayed inline by the browser.
.SS "session"
.IX Subsection "session"
Provides access to all data stored in the user's session (if any).
.PP
It can also be used as a setter to store data in the session:
.PP
.Vb 6
\&    # getter example
\&    get \*(Aq/user\*(Aq => sub {
\&        if (session(\*(Aquser\*(Aq)) {
\&            return "Hello, ".session(\*(Aquser\*(Aq)\->name;
\&        }
\&    };
\&
\&    # setter example
\&    post \*(Aq/user/login\*(Aq => sub {
\&        ...
\&        if ($logged_in) {
\&            session user => $user;
\&        }
\&        ...
\&    };
.Ve
.PP
You may also need to clear a session:
.PP
.Vb 6
\&    # destroy session
\&    get \*(Aq/logout\*(Aq => sub {
\&        ...
\&        app\->destroy_session;
\&        ...
\&    };
.Ve
.PP
If you need to fetch the session \s-1ID\s0 being used for any reason:
.PP
.Vb 1
\&    my $id = session\->id;
.Ve
.SS "set"
.IX Subsection "set"
Defines a setting:
.PP
.Vb 1
\&    set something => \*(Aqvalue\*(Aq;
.Ve
.PP
You can set more than one value at once:
.PP
.Vb 1
\&    set something => \*(Aqvalue\*(Aq, otherthing => \*(Aqothervalue\*(Aq;
.Ve
.SS "setting"
.IX Subsection "setting"
Returns the value of a given setting:
.PP
.Vb 1
\&    setting(\*(Aqsomething\*(Aq); # \*(Aqvalue\*(Aq
.Ve
.SS "splat"
.IX Subsection "splat"
Returns the list of captures made from a route handler with a route pattern
which includes wildcards:
.PP
.Vb 4
\&    get \*(Aq/file/*.*\*(Aq => sub {
\&        my ($file, $extension) = splat;
\&        ...
\&    };
.Ve
.PP
There is also the extensive splat (A.K.A. \*(L"megasplat\*(R"), which allows
extensive greedier matching, available using two asterisks. The additional
path is broken down and returned as an arrayref:
.PP
.Vb 4
\&    get \*(Aq/entry/*/tags/**\*(Aq => sub {
\&        my ( $entry_id, $tags ) = splat;
\&        my @tags = @{$tags};
\&    };
.Ve
.PP
The \f(CW\*(C`splat\*(C'\fR keyword in the above example for the route \fI/entry/1/tags/one/two\fR
would set \f(CW$entry_id\fR to \f(CW1\fR and \f(CW$tags\fR to \f(CW\*(C`[\*(Aqone\*(Aq, \*(Aqtwo\*(Aq]\*(C'\fR.
.SS "start"
.IX Subsection "start"
Starts the application or the standalone server (depending on the deployment
choices).
.PP
This keyword should be called at the very end of the script, once all routes
are defined. At this point, Dancer2 takes over.
.PP
to_app is preferable to dancer or \f(CW\*(C`start\*(C'\fR.
.SS "status"
.IX Subsection "status"
Changes the status code provided by an action. By default, an action will
produce an \f(CW\*(C`HTTP 200 OK\*(C'\fR status code, meaning everything is \s-1OK:\s0
.PP
.Vb 7
\&    get \*(Aq/download/:file\*(Aq => {
\&        if (! \-f route_parameters\->get(\*(Aqfile\*(Aq)) {
\&            status \*(Aqnot_found\*(Aq;
\&            return "File does not exist, unable to download";
\&        }
\&        # serving the file...
\&    };
.Ve
.PP
In that example, Dancer will notice that the status has changed, and will
render the response accordingly.
.PP
The \f(CW\*(C`status\*(C'\fR keyword receives either a numeric status code or its name in
lower case, with underscores as a separator for blanks \- see the list in
\&\*(L"\s-1HTTP CODES\*(R"\s0 in Dancer2::Core::HTTP. As an example, The above call translates
to setting the code to \f(CW404\fR.
.SS "template"
.IX Subsection "template"
Returns the response of processing the given template with the given
parameters (and optional settings), wrapping it in the default or specified
layout too, if layouts are in use.
.PP
An example of a  route handler which returns the result of using template to
build a response with the current template engine:
.PP
.Vb 4
\&    get \*(Aq/\*(Aq => sub {
\&        ...
\&        return template \*(Aqsome_view\*(Aq, { token => \*(Aqvalue\*(Aq};
\&    };
.Ve
.PP
Note that \f(CW\*(C`template\*(C'\fR simply returns the content, so when you use it in a
route handler, if execution of the route handler should stop at that point,
make sure you use \f(CW\*(C`return\*(C'\fR to ensure your route handler returns the content.
.PP
Since \f(CW\*(C`template\*(C'\fR just returns the result of rendering the template, you can
also use it to perform other templating tasks, e.g. generating emails:
.PP
.Vb 8
\&    post \*(Aq/some/route\*(Aq => sub {
\&        if (...) {
\&            email {
\&                to      => \*(Aqsomeone@example.com\*(Aq,
\&                from    => \*(Aqfoo@example.com\*(Aq,
\&                subject => \*(AqHello there\*(Aq,
\&                msg     => template(\*(Aqemails/foo\*(Aq, { name => body_parameters\->get(\*(Aqname\*(Aq) }),
\&            };
\&
\&            return template \*(Aqmessage_sent\*(Aq;
\&        } else {
\&            return template \*(Aqerror\*(Aq;
\&        }
\&    };
.Ve
.PP
Compatibility notice: \f(CW\*(C`template\*(C'\fR was changed in version 1.3090 to
immediately interrupt execution of a route handler and return the content,
as it's typically used at the end of a route handler to return content.
However, this caused issues for some people who were using \f(CW\*(C`template\*(C'\fR to
generate emails etc, rather than accessing the template engine directly, so
this change has been reverted in 1.3091.
.PP
The first parameter should be a template available in the views directory,
the second one (optional) is a hashref of tokens to interpolate, and the
third (again optional) is a hashref of options.
.PP
For example, to disable the layout for a specific request:
.PP
.Vb 3
\&    get \*(Aq/\*(Aq => sub {
\&        template \*(Aqindex\*(Aq, {}, { layout => undef };
\&    };
.Ve
.PP
Or to request a specific layout, of course:
.PP
.Vb 3
\&    get \*(Aq/user\*(Aq => sub {
\&        template \*(Aquser\*(Aq, {}, { layout => \*(Aquser\*(Aq };
\&    };
.Ve
.PP
Some tokens are automatically added to your template (\f(CW\*(C`perl_version\*(C'\fR,
\&\f(CW\*(C`dancer_version\*(C'\fR, \f(CW\*(C`settings\*(C'\fR, \f(CW\*(C`request\*(C'\fR, \f(CW\*(C`vars\*(C'\fR and, if you
have sessions enabled, \f(CW\*(C`session\*(C'\fR). Check Default Template
Variables
for further details.
.SS "to_app"
.IX Subsection "to_app"
Returns the \s-1PSGI\s0 coderef for the current (and only the current) application.
.PP
You can call it as a method on the class or as a \s-1DSL:\s0
.PP
.Vb 1
\&    my $app = MyApp\->to_app;
\&
\&    # or
\&
\&    my $app = to_app;
.Ve
.PP
There is a
Dancer Advent Calendar article <http://advent.perldancer.org/2014/9> covering
this keyword and its usage further.
.SS "to_dumper ($structure)"
.IX Subsection "to_dumper ($structure)"
Serializes a structure with Data::Dumper.
.PP
Calling this function will \fBnot\fR trigger the serialization's hooks.
.SS "to_json ($structure, \e%options)"
.IX Subsection "to_json ($structure, %options)"
Serializes a structure to \s-1JSON.\s0 You should probably use \f(CW\*(C`encode_json\*(C'\fR instead
which handles encoding the result for you.
.SS "to_yaml ($structure)"
.IX Subsection "to_yaml ($structure)"
Serializes a structure to \s-1YAML.\s0
.PP
Calling this function will \fBnot\fR trigger the serialization's hooks.
.SS "true"
.IX Subsection "true"
Constant that returns a true value (1).
.SS "upload"
.IX Subsection "upload"
Provides access to file uploads. Any uploaded file is accessible as a
Dancer2::Core::Request::Upload object. You can access all parsed uploads
via:
.PP
.Vb 4
\&    post \*(Aq/some/route\*(Aq => sub {
\&        my $file = upload(\*(Aqfile_input_foo\*(Aq);
\&        # $file is a Dancer2::Core::Request::Upload object
\&    };
.Ve
.PP
If you named multiple inputs of type \*(L"file\*(R" with the same name, the \f(CW\*(C`upload\*(C'\fR
keyword would return an Array of Dancer2::Core::Request::Upload objects:
.PP
.Vb 4
\&    post \*(Aq/some/route\*(Aq => sub {
\&        my ($file1, $file2) = upload(\*(Aqfiles_input\*(Aq);
\&        # $file1 and $file2 are Dancer2::Core::Request::Upload objects
\&    };
.Ve
.PP
You can also access the raw hashref of parsed uploads via the current
\&\f(CW\*(C`request\*(C'\fR object:
.PP
.Vb 5
\&    post \*(Aq/some/route\*(Aq => sub {
\&        my $all_uploads = request\->uploads;
\&        # $all_uploads\->{\*(Aqfile_input_foo\*(Aq} is a Dancer2::Core::Request::Upload object
\&        # $all_uploads\->{\*(Aqfiles_input\*(Aq} is an arrayref of Dancer2::Core::Request::Upload objects
\&    };
.Ve
.PP
Note that you can also access the filename of the upload received via the
\&\f(CW\*(C`body_parameters\*(C'\fR keyword:
.PP
.Vb 3
\&    post \*(Aq/some/route\*(Aq => sub {
\&        # body_parameters\->get(\*(Aqfiles_input\*(Aq) is the filename of the file uploaded
\&    };
.Ve
.PP
See Dancer2::Core::Request::Upload for details about the interface provided.
.SS "uri_for"
.IX Subsection "uri_for"
Returns a fully-qualified \s-1URI\s0 for the given path:
.PP
.Vb 4
\&    get \*(Aq/\*(Aq => sub {
\&        redirect uri_for(\*(Aq/path\*(Aq);
\&        # can be something like: http://localhost:5000/path
\&    };
.Ve
.PP
Query string parameters can be provided by passing a hashref as a second param:
.PP
.Vb 2
\&    uri_for(\*(Aq/path\*(Aq, { foo => \*(Aqbar\*(Aq });
\&    # would return e.g. http://localhost:5000/path?foo=bar
.Ve
.PP
By default, the parameters will be \s-1URL\s0 encoded:
.PP
.Vb 2
\&    uri_for(\*(Aq/path\*(Aq, { foo => \*(Aqhope;faith\*(Aq });
\&    # would return http://localhost:5000/path?foo=hope%3Bfaith
.Ve
.PP
If desired (for example, if you've already encoded your query
parameters and you want to prevent double encoding) you can disable
\&\s-1URL\s0 encoding via a third parameter:
.PP
.Vb 2
\&    uri_for(\*(Aq/path\*(Aq, { foo => \*(Aqqux%3Dquo\*(Aq }, 1);
\&    # would return http://localhost:5000/path?foo=qux%3Dquo
.Ve
.SS "var"
.IX Subsection "var"
Provides an accessor for variables shared between hooks and route
handlers. Given a key/value pair, it sets a variable:
.PP
.Vb 3
\&    hook before => sub {
\&        var foo => 42;
\&    };
.Ve
.PP
Later, route handlers and other hooks will be able to read that variable:
.PP
.Vb 4
\&    get \*(Aq/path\*(Aq => sub {
\&        my $foo = var \*(Aqfoo\*(Aq;
\&        ...
\&    };
.Ve
.SS "vars"
.IX Subsection "vars"
Returns the hashref of all shared variables set during the hook/route
chain with the \f(CW\*(C`var\*(C'\fR keyword:
.PP
.Vb 5
\&    get \*(Aq/path\*(Aq => sub {
\&        if (vars\->{foo} eq 42) {
\&            ...
\&        }
\&    };
.Ve
.SS "warning"
.IX Subsection "warning"
Logs a warning message through the current logger engine:
.PP
.Vb 1
\&    warning "This is a warning";
.Ve
.PP
See Dancer2::Core::Role::Logger for details on how to configure where log
messages go.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dancer Core Developers
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2022 by Alexis Sukrieh.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
