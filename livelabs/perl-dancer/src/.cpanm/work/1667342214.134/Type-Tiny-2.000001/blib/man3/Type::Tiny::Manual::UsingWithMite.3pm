.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Type::Tiny::Manual::UsingWithMite 3"
.TH Type::Tiny::Manual::UsingWithMite 3 "2022-09-29" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Type::Tiny::Manual::UsingWithMite \- how to use Type::Tiny with Mite
.SH "MANUAL"
.IX Header "MANUAL"
Mite takes an unorthodox approach to object-oriented code. When you first
start a project with Mite (which we'll assume is called Your::Project), Mite
will create a module called Your::Project::Mite for you.
.PP
Then all your classes use code like:
.PP
.Vb 1
\&   package Your::Project::Widget;
\&   
\&   use Your::Project::Mite \-all;
\&   
\&   has name => (
\&      is => ro,
\&      isa => \*(AqStr\*(Aq,
\&   );
\&   
\&   has id => (
\&      is => ro,
\&      isa => \*(AqPositiveInt\*(Aq,
\&   );
\&   
\&   signature_for warble => (
\&      named => [
\&         foo   => \*(AqInt\*(Aq,
\&         bar   => \*(AqArrayRef\*(Aq,
\&      ],
\&   );
\&   
\&   sub warble {
\&      my ( $self, $arg ) = @_;
\&      printf( "%s: %d\en", $self\->name, $arg\->foo );
\&      return;
\&   }
\&   
\&   1;
.Ve
.PP
After writing or editing each class or role, you run the command
\&\f(CW\*(C`mite compile\*(C'\fR and Mite will output a collection of compiled Perl
classes which have no non-core dependencies (on Perl 5.14+. There are
a couple of non-core dependencies on older versions of Perl.)
.PP
Attribute \f(CW\*(C`isa\*(C'\fR options are Type::Tiny type constraints expressed as
strings. Mite looks them up during compilation using \f(CW\*(C`dwim_type\*(C'\fR
from Type::Utils, and pre-loads Types::Standard,
Types::Common::String, and Types::Common::Numeric for you.
.PP
The \f(CW\*(C`signature_for\*(C'\fR keyword is similar to the corresponding function
in Type::Params. Again, note that types are expressed as strings
and looked up using \f(CW\*(C`dwim_type\*(C'\fR.
.PP
Any types which are inlineable should work. If using coercion, any
coercions which are inlineable should work.
.SS "Custom Types in Mite"
.IX Subsection "Custom Types in Mite"
You can define your own type library (say, Your::Project::Types) using
Type::Library as normal:
.PP
.Vb 1
\&   package Your::Project::Types;
\&   
\&   use Type::Library
\&      \-extends => [ \*(AqTypes::Standard\*(Aq, \*(AqTypes::Common::Numeric\*(Aq ];
\&   
\&   _\|_PACKAGE_\|_\->add_type(
\&      name    => \*(AqWidget\*(Aq,
\&      parent  => InstanceOf[\*(AqYour::Project::Widget\*(Aq],
\&   )\->coercion\->add_type_coercions(
\&      HashRef, q{Your::Project::Widget\->new($_)},
\&   );
\&   
\&   _\|_PACKAGE_\|_\->make_immutable;
\&   
\&   1;
.Ve
.PP
Now if your classes load Your::Project::Types they'll suddenly have a
dependency on Type::Library, so you don't get that nice zero-dependency
feeling. But you can add this to your \f(CW\*(C`.mite/config\*(C'\fR file:
.PP
.Vb 1
\&   types: Your::Project::Types
.Ve
.PP
Now Mite will know to load that type library at compile time, and will
make those types available as stringy types everywhere.
.SS "Compiled Type Libraries"
.IX Subsection "Compiled Type Libraries"
It does look really pretty to not have to quote your type constraints:
.PP
.Vb 4
\&   has name => (
\&      is   => ro,
\&      isa  => Str,
\&   );
.Ve
.PP
One solution for that is Type::Library::Compiler.
.PP
Say you've created the custom type library above, you can use 
Type::Library::Compiler to compile it into a module called
Your::Project::Types::Compiled, which just uses Exporter and
doesn't rely on Type::Library or any other part of Type::Tiny.
.PP
Then your Widget class can use that:
.PP
.Vb 1
\&   package Your::Project::Widget;
\&   
\&   use Your::Project::Mite \-all;
\&   use Your::Project::Types::Compiled \-types;
\&   
\&   has name => (
\&      is   => ro,
\&      isa  => Str,
\&   );
\&   
\&   has id => (
\&      is   => ro,
\&      isa  => PositiveInt,
\&   );
\&   
\&   signature_for warble => (
\&      named => [
\&         foo   => Int,
\&         bar   => ArrayRef,
\&      ],
\&   );
\&   
\&   sub warble {
\&      my ( $self, $arg ) = @_;
\&      printf( "%s: %d\en", $self\->name, $arg\->foo );
\&      return;
\&   }
\&   
\&   1;
.Ve
.PP
The compiled type libraries are more limited than real type libraries.
You can't, for example, do parameterized types with them. However, they
still offer some cool features like:
.PP
.Vb 4
\&   Foo\->check( $value )     # a few basic methods like this
\&   is_Foo( $value )         # boolean checks
\&   assert_Foo( $value )     # assertions which die
\&   Foo | Bar                # unions!
.Ve
.PP
This way you can write a project with object orientation, roles, method
modifiers, type-checked attributes, type-checked signatures, and even
coercion, with no non-core dependencies! (The tools like Mite and
Type::Library::Compiler are only needed by the developer, not the
end user.)
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Here's your next step:
.IP "\(bu" 4
Type::Tiny::Manual::UsingWithClassTiny
.Sp
Including how to Type::Tiny in your object's \f(CW\*(C`BUILD\*(C'\fR method, and
third-party shims between Type::Tiny and Class::Tiny.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2022 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
