.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Type::Params 3"
.TH Type::Params 3 "2022-09-29" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Type::Params \- sub signature validation using Type::Tiny type constraints and coercions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use v5.20;
\& use strict;
\& use warnings;
\& use experimental \*(Aqsignatures\*(Aq;
\& 
\& package Horse {
\&   use Moo;
\&   use Types::Standard qw( Object );
\&   use Type::Params \-sigs;
\&   use namespace::autoclean;
\&   
\&   ...;   # define attributes, etc
\&   
\&   signature_for add_child => (
\&     method     => 1,
\&     positional => [ Object ],
\&   );
\&   
\&   sub add_child ( $self, $child ) {
\&     
\&     push @{ $self\->children }, $child;
\&     
\&     return $self;
\&   }
\& }
\& 
\& package main;
\& 
\& my $boldruler = Horse\->new;
\& 
\& $boldruler\->add_child( Horse\->new );
\& 
\& $boldruler\->add_child( 123 );   # dies (123 is not an Object!)
.Ve
.SH "STATUS"
.IX Header "STATUS"
This module is covered by the
Type-Tiny stability policy.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This documents the details of the Type::Params package.
Type::Tiny::Manual is a better starting place if you're new.
.PP
Type::Params uses Type::Tiny constraints to validate the parameters to a
sub. It takes the slightly unorthodox approach of separating validation
into two stages:
.IP "1." 4
Compiling the parameter specification into a coderef; then
.IP "2." 4
Using the coderef to validate parameters.
.PP
The first stage is slow (it might take a couple of milliseconds), but you
only need to do it the first time the sub is called. The second stage is
fast; according to my benchmarks faster even than the \s-1XS\s0 version of
Params::Validate.
.SH "MODERN API"
.IX Header "MODERN API"
The modern \s-1API\s0 can be exported using:
.PP
.Vb 1
\& use Type::Params \-sigs;
.Ve
.PP
Or:
.PP
.Vb 1
\& use Type::Params \-v2;
.Ve
.PP
Or by requesting functions by name:
.PP
.Vb 1
\& use Type::Params qw( signature signature_for );
.Ve
.ie n .SS """signature( %spec )"""
.el .SS "\f(CWsignature( %spec )\fP"
.IX Subsection "signature( %spec )"
The \f(CW\*(C`signature\*(C'\fR function takes a specification for your function's
signature and returns a coderef. You then call the coderef in list
context, passing \f(CW@_\fR to it. The coderef will check, coerce, and
apply other procedures to the values, and return the tidied values,
or die with an error.
.PP
The usual way of using it is:
.PP
.Vb 3
\& sub your_function {
\&   state $signature = signature( ... );
\&   my ( $arg1, $arg2, $arg3 ) = $signature\->( @_ );
\&   
\&   ...;
\& }
.Ve
.PP
Perl allows a slightly archaic way of calling coderefs without using
parentheses, which may be slightly faster at the cost of being more
obscure:
.PP
.Vb 3
\& sub your_function {
\&   state $signature = signature( ... );
\&   my ( $arg1, $arg2, $arg3 ) = &$signature;
\&   
\&   ...;
\& }
.Ve
.PP
If you need to support Perl 5.8, which didn't have the \f(CW\*(C`state\*(C'\fR keyword:
.PP
.Vb 4
\& my $_\|_your_function_sig;
\& sub your_function {
\&   $_\|_your_function_sig ||= signature( ... );
\&   my ( $arg1, $arg2, $arg3 ) = $_\|_your_function_sig\->( @_ );
\&   
\&   ...;
\& }
.Ve
.PP
One important thing to note is how the signature is only compiled into a
coderef the first time your function gets called, and thereafter will be
reused.
.PP
\fISignature Specification Options\fR
.IX Subsection "Signature Specification Options"
.PP
The signature specification is a hash which must contain either a
\&\f(CW\*(C`positional\*(C'\fR, \f(CW\*(C`named\*(C'\fR, or \f(CW\*(C`multiple\*(C'\fR key indicating whether your
function takes positional parameters, named parameters, or supports
multiple calling conventions, but may also include other options.
.PP
\f(CW\*(C`positional\*(C'\fR \fBArrayRef\fR
.IX Subsection "positional ArrayRef"
.PP
This is conceptually a list of type constraints, one for each positional
parameter. For example, a signature for a function which accepts two
integers:
.PP
.Vb 1
\& signature( positional => [ Int, Int ] )
.Ve
.PP
However, each type constraint is optionally followed by a hashref of
options which affect that parameter. For example:
.PP
.Vb 4
\& signature( positional => [
\&   Int, { default => 40 },
\&   Int, { default =>  2 },
\& ] )
.Ve
.PP
Type constraints can instead be given as strings, which will be looked
up using \f(CW\*(C`dwim_type\*(C'\fR from Type::Utils.
.PP
.Vb 4
\& signature( positional => [
\&   \*(AqInt\*(Aq, { default => 40 },
\&   \*(AqInt\*(Aq, { default =>  2 },
\& ] )
.Ve
.PP
See the section below for more information on parameter options.
.PP
Optional parameters must follow required parameters, and can be specified
using either the \fBOptional\fR parameterizable type constraint, the
\&\f(CW\*(C`optional\*(C'\fR parameter option, or by providing a default.
.PP
.Vb 5
\& signature( positional => [
\&   Optional[Int],
\&   Int, { optional => !!1 },
\&   Int, { default  => 42 },
\& ] )
.Ve
.PP
A single slurpy parameter may be provided at the end, using the \fBSlurpy\fR
parameterizable type constraint, or the \f(CW\*(C`slurpy\*(C'\fR parameter option:
.PP
.Vb 4
\& signature( positional => [
\&   Int,
\&   Slurpy[ ArrayRef[Int] ],
\& ] )
\&
\& signature( positional => [
\&   Int,
\&   ArrayRef[Int], { slurpy => !!1 },
\& ] )
.Ve
.PP
The \f(CW\*(C`positional\*(C'\fR option can also be abbreviated to \f(CW\*(C`pos\*(C'\fR.
.PP
So \f(CW\*(C`signature( pos => [...] )\*(C'\fR can be used instead of the longer
\&\f(CW\*(C`signature( positional => [...] )\*(C'\fR.
.PP
If a signature uses positional parameters, the values are returned by the
coderef as a list:
.PP
.Vb 3
\& sub add_numbers {
\&   state $sig = signature( positional => [ Num, Num ] );
\&   my ( $num1, $num2 ) = $sig\->( @_ );
\&   
\&   return $num1 + $num2;
\& }
\& 
\& say add_numbers( 2, 3 );   # says 5
.Ve
.PP
\f(CW\*(C`named\*(C'\fR \fBArrayRef\fR
.IX Subsection "named ArrayRef"
.PP
This is conceptually a list of pairs of names and type constraints, one
name+type pair for each positional parameter. For example, a signature for
a function which accepts two integers:
.PP
.Vb 1
\& signature( named => [ foo => Int, bar => Int ] )
.Ve
.PP
However, each type constraint is optionally followed by a hashref of
options which affect that parameter. For example:
.PP
.Vb 4
\& signature( named => [
\&   foo => Int, { default => 40 },
\&   bar => Int, { default =>  2 },
\& ] )
.Ve
.PP
Type constraints can instead be given as strings, which will be looked
up using \f(CW\*(C`dwim_type\*(C'\fR from Type::Utils.
.PP
.Vb 4
\& signature( named => [
\&   foo => \*(AqInt\*(Aq, { default => 40 },
\&   bar => \*(AqInt\*(Aq, { default =>  2 },
\& ] )
.Ve
.PP
Optional and slurpy parameters are allowed, but unlike positional parameters,
they do not need to be at the end.
.PP
See the section below for more information on parameter options.
.PP
If a signature uses named parameters, the values are returned by the
coderef as an object:
.PP
.Vb 3
\& sub add_numbers {
\&   state $sig = signature( named => [ num1 => Num, num2 => Num ] );
\&   my ( $arg ) = $sig\->( @_ );
\&   
\&   return $arg\->num1 + $arg\->num2;
\& }
\& 
\& say add_numbers(   num1 => 2, num2 => 3   );   # says 5
\& say add_numbers( { num1 => 2, num2 => 3 } );   # also says 5
.Ve
.PP
\f(CW\*(C`named_to_list\*(C'\fR \fBArrayRef|Bool\fR
.IX Subsection "named_to_list ArrayRef|Bool"
.PP
The \f(CW\*(C`named_to_list\*(C'\fR option is ignored for signatures using positional
parameters, but for signatures using named parameters, allows them to
be returned in a list instead of as an object:
.PP
.Vb 6
\& sub add_numbers {
\&   state $sig = signature(
\&     named         => [ num1 => Num, num2 => Num ],
\&     named_to_list => !!1,
\&   );
\&   my ( $num1, $num2 ) = $sig\->( @_ );
\&   
\&   return $num1 + $num2;
\& }
\& 
\& say add_numbers(   num1 => 2, num2 => 3   );   # says 5
\& say add_numbers( { num1 => 2, num2 => 3 } );   # also says 5
.Ve
.PP
You can think of \f(CW\*(C`add_numbers\*(C'\fR above as a function which takes named
parameters from the outside, but receives positional parameters on the
inside.
.PP
You can use an arrayref to specify the order the paramaters will be
returned in. (By default they are returned in the order they were defined
in.)
.PP
.Vb 6
\& sub add_numbers {
\&   state $sig = signature(
\&     named         => [ num1 => Num, num2 => Num ],
\&     named_to_list => [ qw( num2 num1 ) ],
\&   );
\&   my ( $num2, $num1 ) = $sig\->( @_ );
\&   
\&   return $num1 + $num2;
\& }
.Ve
.PP
\f(CW\*(C`head\*(C'\fR \fBInt|ArrayRef\fR
.IX Subsection "head Int|ArrayRef"
.PP
\&\f(CW\*(C`head\*(C'\fR provides an additional list of non-optional, positional parameters
at the start of \f(CW@_\fR. This is often used for method calls. For example,
if you wish to define a signature for:
.PP
.Vb 1
\& $object\->my_method( foo => 123, bar => 456 );
.Ve
.PP
You could write it as this:
.PP
.Vb 6
\& sub my_method {
\&   state $signature = signature(
\&     head    => [ Object ],
\&     named   => [ foo => Optional[Int], bar => Optional[Int] ],
\&   );
\&   my ( $self, $arg ) = $signature\->( @_ );
\&   
\&   ...;
\& }
.Ve
.PP
If \f(CW\*(C`head\*(C'\fR is set as a number instead of an arrayref, it is the number of
additional arguments at the start:
.PP
.Vb 6
\& sub my_method {
\&   state $signature = signature(
\&     head    => 1,
\&     named   => [ foo => Optional[Int], bar => Optional[Int] ],
\&   );
\&   my ( $self, $arg ) = $signature\->( @_ );
\&   
\&   ...;
\&}
.Ve
.PP
In this case, no type checking is performed on those additional arguments;
it is just checked that they exist.
.PP
\f(CW\*(C`tail\*(C'\fR \fBInt|ArrayRef\fR
.IX Subsection "tail Int|ArrayRef"
.PP
A \f(CW\*(C`tail\*(C'\fR is like a \f(CW\*(C`head\*(C'\fR except that it is for arguments at the \fIend\fR
of \f(CW@_\fR.
.PP
.Vb 7
\& sub my_method {
\&   state $signature = signature(
\&     head    => [ Object ],
\&     named   => [ foo => Optional[Int], bar => Optional[Int] ],
\&     tail    => [ CodeRef ],
\&   );
\&   my ( $self, $arg, $callback ) = $signature\->( @_ );
\&   
\&   ...;
\& }
\& 
\& $object\->my_method( foo => 123, bar => 456, sub { ... } );
.Ve
.PP
\f(CW\*(C`method\*(C'\fR \fBBool|TypeTiny\fR
.IX Subsection "method Bool|TypeTiny"
.PP
While \f(CW\*(C`head\*(C'\fR can be used for method signatures, a more declarative way is
to set \f(CW\*(C`method => 1\*(C'\fR.
.PP
If you wish to be specific that this is an object method, intended to be
called on blessed objects only, then you may use \f(CW\*(C`method => Object\*(C'\fR,
using the \fBObject\fR type from Types::Standard. If you wish to specify
that it's a class method, then use \f(CW\*(C`method => Str\*(C'\fR, using the \fBStr\fR
type from Types::Standard. (\f(CW\*(C`method => ClassName\*(C'\fR is perhaps
clearer, but it's a slower check.)
.PP
.Vb 6
\& sub my_method {
\&   state $signature = signature(
\&     method  => 1,
\&     named   => [ foo => Optional[Int], bar => Optional[Int] ],
\&   );
\&   my ( $self, $arg ) = $signature\->( @_ );
\&   
\&   ...;
\& }
.Ve
.PP
If \f(CW\*(C`method\*(C'\fR is true (or a type constraint) then any parameter
defaults which are coderefs will be called as methods.
.PP
\f(CW\*(C`description\*(C'\fR \fBStr\fR
.IX Subsection "description Str"
.PP
This is the description of the coderef that will show up in stack traces.
It defaults to \*(L"parameter validation for X\*(R" where X is the caller sub name.
Usually the default will be fine.
.PP
\f(CW\*(C`package\*(C'\fR \fBStr\fR
.IX Subsection "package Str"
.PP
The package of the sub whose paramaters we're supposed to be checking.
As well as showing up in stack traces, it's used by \f(CW\*(C`dwim_type\*(C'\fR if you
provide any type constraints as strings.
.PP
The default is probably fine, but if you're wrapping \f(CW\*(C`signature\*(C'\fR so that
you can check signatures on behalf of another package, you may need to
provide it.
.PP
\f(CW\*(C`subname\*(C'\fR \fBStr\fR
.IX Subsection "subname Str"
.PP
The name of the sub whose paramaters we're supposed to be checking.
.PP
The default is probably fine, but if you're wrapping \f(CW\*(C`signature\*(C'\fR so that
you can check signatures on behalf of another package, you may need to
provide it.
.PP
\f(CW\*(C`caller_level\*(C'\fR \fBInt\fR
.IX Subsection "caller_level Int"
.PP
If you're wrapping \f(CW\*(C`signature\*(C'\fR so that you can check signatures on behalf
of another package, then setting \f(CW\*(C`caller_level\*(C'\fR to 1 (or more, depending on
the level of wrapping!) may be an alternative to manually setting the
\&\f(CW\*(C`package\*(C'\fR and \f(CW\*(C`subname\*(C'\fR.
.PP
\f(CW\*(C`on_die\*(C'\fR \fBMaybe[CodeRef]\fR
.IX Subsection "on_die Maybe[CodeRef]"
.PP
Usually when your coderef hits an error, it will throw an exception, which
is a blessed Error::TypeTiny object.
.PP
If you provide an \f(CW\*(C`on_die\*(C'\fR coderef, then instead the Error::TypeTiny
object will be passed to it. If the \f(CW\*(C`on_die\*(C'\fR coderef returns something,
then whatever it returns will be returned as your signature's parameters.
.PP
.Vb 10
\& sub add_numbers {
\&   state $sig = signature(
\&     positional => [ Num, Num ],
\&     on_die     => sub {
\&       my $error = shift;
\&       print "Existential crisis: $error\en";
\&       exit( 1 );
\&     },
\&   );
\&   my ( $num1, $num2 ) = $sig\->( @_ );
\&   
\&   return $num1 + $num2;
\& }
\& 
\& say add_numbers();   # has an existential crisis
.Ve
.PP
This is probably not very useful.
.PP
\f(CW\*(C`goto_next\*(C'\fR \fBBool|CodeLike\fR
.IX Subsection "goto_next Bool|CodeLike"
.PP
This can be used for chaining coderefs. If you understand \f(CW\*(C`on_die\*(C'\fR, it's
more like an \*(L"on_live\*(R".
.PP
.Vb 5
\& sub add_numbers {
\&   state $sig = signature(
\&     positional => [ Num, Num ],
\&     goto_next  => sub {
\&       my ( $num1, $num2 ) = @_;
\&       
\&       return $num1 + $num2;
\&     },
\&   );
\&   
\&   my $sum = $sig\->( @_ );
\&   return $sum;
\& }
\& 
\& say add_numbers( 2, 3 );   # says 5
.Ve
.PP
If set to a true boolean instead of a coderef, has a slightly different
behaviour:
.PP
.Vb 5
\& sub add_numbers {
\&   state $sig = signature(
\&     positional => [ Num, Num ],
\&     goto_next  => !!1,
\&   );
\&   
\&   my $sum = $sig\->(
\&     sub { return $_[0] + $_[1] },
\&     @_,
\&   );
\&   return $sum;
\& }
\& 
\& say add_numbers( 2, 3 );   # says 5
.Ve
.PP
This looks strange. Why would this be useful? Well, it works nicely with
Moose's \f(CW\*(C`around\*(C'\fR keyword.
.PP
.Vb 3
\& sub add_numbers {
\&   return $_[1] + $_[2];
\& }
\& 
\& around add_numbers => signature(
\&   method     => !!1,
\&   positional => [ Num, Num ],
\&   goto_next  => !!1,
\&   package    => _\|_PACKAGE_\|_,
\&   subname    => \*(Aqadd_numbers\*(Aq,
\& );
\& 
\& say _\|_PACKAGE_\|_\->add_numbers( 2, 3 );   # says 5
.Ve
.PP
Note the way \f(CW\*(C`around\*(C'\fR works in Moose is that it expects a wrapper coderef
as its final argument. That wrapper coderef then expects to be given a
reference to the original function as its first parameter.
.PP
This can allow, for example, a role to provide a signature wrapping
a method defined in a class.
.PP
This is kind of complex, and you're unlikely to use it, but it's been proven
useful for tools that integrate Type::Params with Moose-like method modifiers.
.PP
\f(CW\*(C`strictness\*(C'\fR \fBBool|Str\fR
.IX Subsection "strictness Bool|Str"
.PP
If you set \f(CW\*(C`strictness\*(C'\fR to a false value (0, undef, or the empty string),
then certain signature checks will simply never be done. The initial check
that there's the correct number of parameters, plus type checks on parameters
which don't coerce can be skipped.
.PP
If you set it to a true boolean (i.e. 1) or do not set it at all, then these
checks will always be done.
.PP
Alternatively, it may be set to the quoted fully-qualified name of a Perl
global variable or a constant, and that will be compiled into the coderef
as a condition to enable strict checks.
.PP
.Vb 4
\& state $signature = signature(
\&   strictness => \*(Aq$::CHECK_TYPES\*(Aq,
\&   positional => [ Int, ArrayRef ],
\& );
\& 
\& # Type checks are skipped
\& {
\&   local $::CHECK_TYPES = 0;
\&   my ( $number, $list ) = $signature\->( {}, {} );
\& }
\& 
\& # Type checks are performed
\& {
\&   local $::CHECK_TYPES = 1;
\&   my ( $number, $list ) = $signature\->( {}, {} );
\& }
.Ve
.PP
A recommended use of this is with Devel::StrictMode.
.PP
.Vb 1
\& use Devel::StrictMode qw( STRICT );
\& 
\& state $signature = signature(
\&   strictness => STRICT,
\&   positional => [ Int, ArrayRef ],
\& );
.Ve
.PP
\f(CW\*(C`multiple\*(C'\fR \fBArrayRef\fR
.IX Subsection "multiple ArrayRef"
.PP
This option allows your signature to support multiple calling conventions.
Each entry in the array is an alternative signature, as a hashref:
.PP
.Vb 11
\& state $signature = signature(
\&   multiple => [
\&     {
\&       positional => [ ArrayRef, Int ],
\&     },
\&     {
\&       named      => [ array => ArrayRef, index => Int ],
\&       named_to_list => 1,
\&     },
\&   ],
\& );
.Ve
.PP
That signature will allow your function to be called as:
.PP
.Vb 3
\& your_function( $arr, $ix )
\& your_function( array => $arr, index => $ix )
\& your_function( { array => $arr, index => $ix } )
.Ve
.PP
Sometimes the alternatives will return the parameters in a different
order:
.PP
.Vb 7
\& state $signature = signature(
\&   multiple => [
\&     { positional => [ ArrayRef, Int ] },
\&     { positional => [ Int, ArrayRef ] },
\&   ],
\& );
\& my ( $xxx, $yyy ) = $signature\->( @_ );
.Ve
.PP
So how does your sub know whether \f(CW$xxx\fR or \f(CW$yyy\fR is the arrayref?
One option is to use the \f(CW\*(C`${^_TYPE_PARAMS_MULTISIG}\*(C'\fR global variable
which will be set to the index of the signature which was used:
.PP
.Vb 4
\& my @results = $signature\->( @_ );
\& my ( $arr, $ix ) = ${^_TYPE_PARAMS_MULTISIG} == 1
\&   ? reverse( @results )
\&   : @results;
.Ve
.PP
A neater solution is to use a \f(CW\*(C`goto_next\*(C'\fR coderef to re-order alternative
signature results into your preferred order:
.PP
.Vb 7
\& state $signature = signature(
\&   multiple => [
\&     { positional => [ ArrayRef, Int ] },
\&     { positional => [ Int, ArrayRef ], goto_next => sub { reverse @_ } },
\&   ],
\& );
\& my ( $arr, $ix ) = $signature\->( @_ );
.Ve
.PP
While conceptally \f(CW\*(C`multiple\*(C'\fR is an arrayref of hashrefs, it is also possible
to use arrayrefs in the arrayref.
.PP
.Vb 4
\& multiple => [
\&   [ ArrayRef, Int ],
\&   [ Int, ArrayRef ],
\& ]
.Ve
.PP
When an arrayref is used like that, it is a shortcut for a positional
signature.
.PP
Coderefs may additionally be used:
.PP
.Vb 8
\& state $signature = signature(
\&   multiple => [
\&     [ ArrayRef, Int ],
\&     { positional => [ Int, ArrayRef ], goto_next => sub { reverse @_ } },
\&     sub { ... },
\&     sub { ... },
\&   ],
\& );
.Ve
.PP
The coderefs should be subs which return a list of parameters if they
succeed and throw an exception if they fail.
.PP
The following signatures are equivalent:
.PP
.Vb 6
\& state $sig_1 = signature(
\&   multiple => [
\&     { method => 1, positional => [ ArrayRef, Int ] },
\&     { method => 1, positional => [ Int, ArrayRef ] },
\&   ],
\& );
\& 
\& state $sig_2 = signature(
\&   method   => 1,
\&   multiple => [
\&     { positional => [ ArrayRef, Int ] },
\&     { positional => [ Int, ArrayRef ] },
\&   ],
\& );
.Ve
.PP
The \f(CW\*(C`multiple\*(C'\fR option can also be abbreviated to \f(CW\*(C`multi\*(C'\fR.
.PP
So \f(CW\*(C`signature( multi => [...] )\*(C'\fR can be used instead of the longer
\&\f(CW\*(C`signature( multiple => [...] )\*(C'\fR. Three whole keystrokes saved!
.PP
(\fBNote:\fR in older releases of Type::Params, \f(CW\*(C`${^_TYPE_PARAMS_MULTISIG}\*(C'\fR
was called \f(CW\*(C`${^TYPE_PARAMS_MULTISIG}\*(C'\fR. The latter name is deprecated,
and support for it will be removed in a future release of Type::Params.)
.PP
\f(CW\*(C`message\*(C'\fR \fBStr\fR
.IX Subsection "message Str"
.PP
Only used by \f(CW\*(C`multiple\*(C'\fR signatures. The error message to throw when no
signatures match.
.PP
\f(CW\*(C`want_source\*(C'\fR \fBBool\fR
.IX Subsection "want_source Bool"
.PP
Instead of returning a coderef, return Perl source code string. Handy
for debugging.
.PP
\f(CW\*(C`want_details\*(C'\fR \fBBool\fR
.IX Subsection "want_details Bool"
.PP
Instead of returning a coderef, return a hashref of stuff including the
coderef. This is mostly for people extending Type::Params and I won't go
into too many details about what else this hashref contains.
.PP
\f(CW\*(C`bless\*(C'\fR \fBBool|ClassName\fR, \f(CW\*(C`class\*(C'\fR \fBClassName|ArrayRef\fR, and \f(CW\*(C`constructor\*(C'\fR \fBStr\fR
.IX Subsection "bless Bool|ClassName, class ClassName|ArrayRef, and constructor Str"
.PP
Named parameters are usually returned as a blessed object:
.PP
.Vb 3
\& sub add_numbers {
\&   state $sig = signature( named => [ num1 => Num, num2 => Num ] );
\&   my ( $arg ) = $sig\->( @_ );
\&   
\&   return $arg\->num1 + $arg\->num2;
\& }
.Ve
.PP
The class they are blessed into is one built on-the-fly by Type::Params.
However, these three signature options allow you more control over that
process.
.PP
Firstly, if you set \f(CW\*(C`bless => false\*(C'\fR and do not set \f(CW\*(C`class\*(C'\fR or
\&\f(CW\*(C`constructor\*(C'\fR, then \f(CW$arg\fR will just be an unblessed hashref.
.PP
.Vb 6
\& sub add_numbers {
\&   state $sig = signature(
\&     named        => [ num1 => Num, num2 => Num ],
\&     bless        => !!0,
\&   );
\&   my ( $arg ) = $sig\->( @_ );
\&   
\&   return $arg\->{num1} + $arg\->{num2};
\& }
.Ve
.PP
This is a good speed boost, but having proper methods for each named
parameter is a helpful way to catch misspelled names.
.PP
If you wish to manually create a class instead of relying on Type::Params
generating one on-the-fly, you can do this:
.PP
.Vb 8
\& package Params::For::AddNumbers {
\&   sub num1 { return $_[0]{num1} }
\&   sub num2 { return $_[0]{num2} }
\&   sub sum {
\&     my $self = shift;
\&     return $self\->num1 + $self\->num2;
\&   }
\& }
\& 
\& sub add_numbers {
\&   state $sig = signature(
\&     named        => [ num1 => Num, num2 => Num ],
\&     bless        => \*(AqParams::For::AddNumbers\*(Aq,
\&   );
\&   my ( $arg ) = $sig\->( @_ );
\&   
\&   return $arg\->sum;
\& }
.Ve
.PP
Note that \f(CW\*(C`Params::For::AddNumbers\*(C'\fR here doesn't include a \f(CW\*(C`new\*(C'\fR method
because Type::Params will directly do \f(CW\*(C`bless( $arg, $opts{bless} )\*(C'\fR.
.PP
If you want Type::Params to use a proper constructor, you should use the
\&\f(CW\*(C`class\*(C'\fR option instead:
.PP
.Vb 8
\& package Params::For::AddNumbers {
\&   use Moo;
\&   has [ \*(Aqnum1\*(Aq, \*(Aqnum2\*(Aq ] => ( is => \*(Aqro\*(Aq );
\&   sub sum {
\&     my $self = shift;
\&     return $self\->num1 + $self\->num2;
\&   }
\& }
\& 
\& sub add_numbers {
\&   state $sig = signature(
\&     named        => [ num1 => Num, num2 => Num ],
\&     class        => \*(AqParams::For::AddNumbers\*(Aq,
\&   );
\&   my ( $arg ) = $sig\->( @_ );
\&   
\&   return $arg\->sum;
\& }
.Ve
.PP
If you wish to use a constructor named something other than \f(CW\*(C`new\*(C'\fR, then
use:
.PP
.Vb 5
\& state $sig = signature(
\&   named        => [ num1 => Num, num2 => Num ],
\&   class        => \*(AqParams::For::AddNumbers\*(Aq,
\&   constructor  => \*(Aqnew_from_hashref\*(Aq,
\& );
.Ve
.PP
Or as a shortcut:
.PP
.Vb 4
\& state $sig = signature(
\&   named        => [ num1 => Num, num2 => Num ],
\&   class        => [ \*(AqParams::For::AddNumbers\*(Aq, \*(Aqnew_from_hashref\*(Aq ],
\& );
.Ve
.PP
It is doubtful you want to use any of these options, except
\&\f(CW\*(C`bless => false\*(C'\fR.
.PP
\fIParameter Options\fR
.IX Subsection "Parameter Options"
.PP
In the parameter lists for the \f(CW\*(C`positional\*(C'\fR and \f(CW\*(C`named\*(C'\fR signature
options, each parameter may be followed by a hashref of options specific
to that parameter:
.PP
.Vb 7
\& signature(
\&   positional => [
\&     Int, \e%options_for_first_parameter,
\&     Int, \e%options_for_other_parameter,
\&   ],
\&   %more_options_for_signature,
\& );
\&
\& signature(
\&   named => [
\&     foo => Int, \e%options_for_foo,
\&     bar => Int, \e%options_for_bar,
\&   ],
\&   %more_options_for_signature,
\& );
.Ve
.PP
The following options are supported for parameters.
.PP
\f(CW\*(C`optional\*(C'\fR \fBBool\fR
.IX Subsection "optional Bool"
.PP
An option \fIcalled\fR optional!
.PP
This makes a parameter optional:
.PP
.Vb 8
\& sub add_nums {
\&   state $sig = signature(
\&     positional => [
\&       Int,
\&       Int,
\&       Bool, { optional => !!1 },
\&     ],
\&   );
\&   
\&   my ( $num1, $num2, $debug ) = $sig\->( @_ );
\&   
\&   my $sum = $num1 + $num2;
\&   warn "$sum = $num1 + $num2" if $debug;
\&   
\&   return $sum;
\& }
\& 
\& add_nums( 2, 3, 1 );   # prints warning
\& add_nums( 2, 3, 0 );   # no warning
\& add_nums( 2, 3    );   # no warning
.Ve
.PP
Types::Standard also provides a \fBOptional\fR parameterizable type
which may be a neater way to do this:
.PP
.Vb 3
\& state $sig = signature(
\&   positional => [ Int, Int, Optional[Bool] ],
\& );
.Ve
.PP
In signatures with positional parameters, any optional parameters must be
defined \fIafter\fR non-optional parameters. The \f(CW\*(C`tail\*(C'\fR option provides a
workaround for required parameters at the end of \f(CW@_\fR.
.PP
In signatures with named parameters, the order of optional and non-optional
parameters is unimportant.
.PP
\f(CW\*(C`slurpy\*(C'\fR \fBBool\fR
.IX Subsection "slurpy Bool"
.PP
A signature may contain a single slurpy parameter, which mops up any other
arguments the caller provides your function.
.PP
In signatures with positional parameters, slurpy params must always have
some kind of \fBArrayRef\fR or \fBHashRef\fR type constraint, must always appear
at the \fIend\fR of the list of positional parameters, and they work like this:
.PP
.Vb 8
\& sub add_nums {
\&   state $sig = signature(
\&     positional => [
\&       Num,
\&       ArrayRef[Num], { slurpy => !!1 },
\&     ],
\&   );
\&   my ( $first_num, $other_nums ) = $sig\->( @_ );
\&   
\&   my $sum = $first_num;
\&   $sum += $_ for @$other_nums;
\&   
\&   return $sum;
\& }
\& 
\& say add_nums( 1 );            # says 1
\& say add_nums( 1, 2 );         # says 3
\& say add_nums( 1, 2, 3 );      # says 6
\& say add_nums( 1, 2, 3, 4 );   # says 10
.Ve
.PP
In signatures with named parameters, slurpy params must always have
some kind of \fBHashRef\fR type constraint, and they work like this:
.PP
.Vb 1
\& use builtin qw( true false );
\& 
\& sub process_data {
\&   state $sig = signature(
\&     method => true,
\&     named  => [
\&       input   => FileHandle,
\&       output  => FileHandle,
\&       flags   => HashRef[Bool], { slurpy => true },
\&     ],
\&   );
\&   my ( $self, $arg ) = @_;
\&   warn "Beginning data processing" if $arg\->flags\->{debug};
\&   
\&   ...;
\& }
\& 
\& $widget\->process_data(
\&   input  => \e*STDIN,
\&   output => \e*STDOUT,
\&   debug  => true,
\& );
.Ve
.PP
The \fBSlurpy\fR type constraint from Types::Standard may be used as
a shortcut to specify slurpy parameters:
.PP
.Vb 3
\& signature(
\&   positional => [ Num, Slurpy[ ArrayRef[Num] ] ],
\& )
.Ve
.PP
The type \fBSlurpy[Any]\fR is handled specially and treated as a
slurpy \fBArrayRef\fR in signatures with positional parameters, and a
slurpy \fBHashRef\fR in signatures with named parameters, but has some
additional optimizations for speed.
.PP
\f(CW\*(C`default\*(C'\fR \fBCodeRef|ScalarRef|Ref|Str|Undef\fR
.IX Subsection "default CodeRef|ScalarRef|Ref|Str|Undef"
.PP
A default may be provided for a parameter.
.PP
.Vb 7
\& state $check = signature(
\&   positional => [
\&     Int,
\&     Int, { default => "666" },
\&     Int, { default => "999" },
\&   ],
\& );
.Ve
.PP
Supported defaults are any strings (including numerical ones), \f(CW\*(C`undef\*(C'\fR,
and empty hashrefs and arrayrefs. Non-empty hashrefs and arrayrefs are
\&\fInot allowed as defaults\fR.
.PP
Alternatively, you may provide a coderef to generate a default value:
.PP
.Vb 7
\& state $check = signature(
\&   positional => [
\&     Int,
\&     Int, { default => sub { 6 * 111 } },
\&     Int, { default => sub { 9 * 111 } },
\&   ]
\& );
.Ve
.PP
That coderef may generate any value, including non-empty arrayrefs and
non-empty hashrefs. For undef, simple strings, numbers, and empty
structures, avoiding using a coderef will make your parameter processing
faster.
.PP
Instead of a coderef, you can use a reference to a string of Perl source
code:
.PP
.Vb 7
\& state $check = signature(
\&   positional => [
\&     Int,
\&     Int, { default => \e \*(Aq6 * 111\*(Aq },
\&     Int, { default => \e \*(Aq9 * 111\*(Aq },
\&   ],
\& );
.Ve
.PP
Defaults \fIwill\fR be validated against the type constraint, and
potentially coerced.
.PP
Any parameter with a default will automatically be optional.
.PP
Note that having \fIany\fR defaults in a signature (even if they never
end up getting used) can slow it down, as Type::Params will need to
build a new array instead of just returning \f(CW@_\fR.
.PP
\f(CW\*(C`coerce\*(C'\fR \fBBool\fR
.IX Subsection "coerce Bool"
.PP
Speaking of which, the \f(CW\*(C`coerce\*(C'\fR option allows you to indicate that a
value should be coerced into the correct type:
.PP
.Vb 7
\& state $sig = signature(
\&   positional => [
\&     Int,
\&     Int,
\&     Bool, { coerce => true },
\&   ],
\& );
.Ve
.PP
Setting \f(CW\*(C`coerce\*(C'\fR to false will disable coercion.
.PP
If \f(CW\*(C`coerce\*(C'\fR is not specified, so is neither true nor false, then
coercion will be enabled if the type constraint has a coercion, and
disabled otherwise.
.PP
Note that having \fIany\fR coercions in a signature (even if they never
end up getting used) can slow it down, as Type::Params will need to
build a new array instead of just returning \f(CW@_\fR.
.PP
\f(CW\*(C`clone\*(C'\fR \fBBool\fR
.IX Subsection "clone Bool"
.PP
If this is set to true, it will deep clone incoming values via \f(CW\*(C`dclone\*(C'\fR
from Storable (a core module since Perl 5.7.3).
.PP
In the below example, \f(CW$arr\fR is a reference to a \fIclone of\fR
\&\f(CW@numbers\fR, so pushing additional numbers to it leaves \f(CW@numbers\fR
unaffected.
.PP
.Vb 7
\& sub foo {
\&   state $check = signature(
\&     positional => [
\&       ArrayRef, { clone => 1 }
\&     ],
\&   );
\&   my ( $arr ) = &$check;
\&   
\&   push @$arr, 4, 5, 6;
\& }
\& 
\& my @numbers = ( 1, 2, 3 );
\& foo( \e@numbers );
\& 
\& print "@numbers\en";  ## 1 2 3
.Ve
.PP
Note that cloning will significantly slow down your signature.
.PP
\f(CW\*(C`name\*(C'\fR \fBStr\fR
.IX Subsection "name Str"
.PP
This overrides the name of a named parameter. I don't know why you
would want to do that.
.PP
The following signature has two parameters: \f(CW\*(C`foo\*(C'\fR and \f(CW\*(C`bar\*(C'\fR. The
name \f(CW\*(C`fool\*(C'\fR is completely ignored.
.PP
.Vb 6
\& signature(
\&   named => [
\&     fool   => Int, { name => \*(Aqfoo\*(Aq },
\&     bar    => Int,
\&   ],
\& )
.Ve
.PP
You can, however, also name positional parameters, which don't usually
have names.
.PP
.Vb 6
\& signature(
\&   positional => [
\&     Int, { name => \*(Aqfoo\*(Aq },
\&     Int, { name => \*(Aqbar\*(Aq },
\&   ],
\& )
.Ve
.PP
The names of positional parameters are not really \fIused\fR for anything
at the moment, but may be incorporated into error messages or
similar in the future.
.PP
\f(CW\*(C`getter\*(C'\fR \fBStr\fR
.IX Subsection "getter Str"
.PP
For signatures with named parameters, specifies the method name used
to retrieve this parameter's value from the \f(CW$arg\fR object.
.PP
.Vb 11
\& sub process_data {
\&   state $sig = signature(
\&     method => true,
\&     named  => [
\&       input   => FileHandle,    { getter => \*(Aqin\*(Aq },
\&       output  => FileHandle,    { getter => \*(Aqout\*(Aq },
\&       flags   => HashRef[Bool], { slurpy => true },
\&     ],
\&   );
\&   my ( $self, $arg ) = @_;
\&   warn "Beginning data processing" if $arg\->flags\->{debug};
\&   
\&   my ( $in, $out ) = ( $arg\->in, $arg\->out );
\&   ...;
\& }
\& 
\& $widget\->process_data(
\&   input  => \e*STDIN,
\&   output => \e*STDOUT,
\&   debug  => true,
\& );
.Ve
.PP
Ignored by signatures with positional parameters.
.PP
\f(CW\*(C`predicate\*(C'\fR \fBStr\fR
.IX Subsection "predicate Str"
.PP
The \f(CW$arg\fR object provided by signatures with named parameters
will also include \*(L"has\*(R" methods for any optional arguments.
For example:
.PP
.Vb 9
\& state $sig = signature(
\&   method => true,
\&   named  => [
\&     input   => Optional[ FileHandle ],
\&     output  => Optional[ FileHandle ],
\&     flags   => Slurpy[ HashRef[Bool] ],
\&   ],
\& );
\& my ( $self, $arg ) = $sig\->( @_ );
\& 
\& if ( $self\->has_input and $self\->has_output ) {
\&   ...;
\& }
.Ve
.PP
Setting a \f(CW\*(C`predicate\*(C'\fR option allows you to choose a different name
for this method.
.PP
It is also possible to set a \f(CW\*(C`predicate\*(C'\fR for non-optional parameters,
which don't normally get a \*(L"has\*(R" method.
.PP
Ignored by signatures with positional parameters.
.PP
\f(CW\*(C`alias\*(C'\fR \fBStr|ArrayRef[Str]\fR
.IX Subsection "alias Str|ArrayRef[Str]"
.PP
A list of alternative names for the parameter, or a single alternative
name.
.PP
.Vb 8
\& sub add_numbers {
\&   state $sig = signature(
\&     named => [
\&       first_number   => Int, { alias => [ \*(Aqx\*(Aq ] },
\&       second_number  => Int, { alias =>   \*(Aqy\*(Aq   },
\&     ],
\&   );
\&   my ( $arg ) = $sig\->( @_ );
\&   
\&   return $arg\->first_number + $arg\->second_number;
\& }
\& 
\& say add_numbers( first_number => 40, second_number => 2 );  # 42
\& say add_numbers( x            => 40, y             => 2 );  # 42
\& say add_numbers( first_number => 40, y             => 2 );  # 42
\& say add_numbers( first_number => 40, x => 1, y => 2 );      # dies!
.Ve
.PP
Ignored by signatures with positional parameters.
.PP
\f(CW\*(C`strictness\*(C'\fR \fBBool|Str\fR
.IX Subsection "strictness Bool|Str"
.PP
Overrides the signature option \f(CW\*(C`strictness\*(C'\fR on a per-parameter basis.
.ie n .SS """signature_for $function_name => ( %spec )"""
.el .SS "\f(CWsignature_for $function_name => ( %spec )\fP"
.IX Subsection "signature_for $function_name => ( %spec )"
Like \f(CW\*(C`signature\*(C'\fR, but instead of returning a coderef, wraps an existing
function, so you don't need to deal with the mechanics of generating the
signature at run-time, calling it, and extracting the returned values.
.PP
The following three examples are roughly equivalent:
.PP
.Vb 5
\& sub add_nums {
\&   state $signature = signature(
\&     positional => [ Num, Num ],
\&   );
\&   my ( $x, $y ) = $signature\->( @_ );
\&   
\&   return $x + $y;
\& }
.Ve
.PP
Or:
.PP
.Vb 3
\& signature_for add_nums => (
\&   positional => [ Num, Num ],
\& );
\& 
\& sub add_nums {
\&   my ( $x, $y ) = @_;
\&   
\&   return $x + $y;
\& }
.Ve
.PP
Or since Perl 5.20:
.PP
.Vb 3
\& signature_for add_nums => (
\&   positional => [ Num, Num ],
\& );
\& 
\& sub add_nums ( $x, $y ) {
\&   return $x + $y;
\& }
.Ve
.PP
The \f(CW\*(C`signature_for\*(C'\fR keyword turns \f(CW\*(C`signature\*(C'\fR inside-out.
.PP
The same signature specification options are supported, with the exception
of \f(CW\*(C`want_source\*(C'\fR and \f(CW\*(C`want_details\*(C'\fR which will not work.
.PP
If you are providing a signature for a sub in another package, then
\&\f(CW\*(C`signature_for "Some::Package::some_sub" => ( ... )\*(C'\fR will work,
as will \f(CW\*(C`signature_for some_sub => ( package => "Some::Package", ... )\*(C'\fR.
If \f(CW\*(C`method\*(C'\fR is true, then \f(CW\*(C`signature_for\*(C'\fR will respect inheritance when
determining which sub to wrap. \f(CW\*(C`signature_for\*(C'\fR will not be able to find
lexical subs, so use \f(CW\*(C`signature\*(C'\fR within the sub instead.
.PP
The \f(CW\*(C`goto_next\*(C'\fR option is what \f(CW\*(C`signature_for\*(C'\fR uses to \*(L"connect\*(R" the
signature to the body of the sub, so do not use it unless you understand
the consequences and want to override the normal behaviour.
.PP
If the sub being wrapped cannot be found, then \f(CW\*(C`signature_for\*(C'\fR will usually
throw an error. If you want it to \*(L"work\*(R" in this situation, use the
\&\f(CW\*(C`fallback\*(C'\fR option. \f(CW\*(C`fallback => \e&alternative_coderef_to_wrap\*(C'\fR
or \f(CW\*(C`fallback => 1\*(C'\fR will instead wrap a different coderef if the original
cannot be found. \f(CW\*(C`fallback => 1\*(C'\fR is a shortcut for
\&\f(CW\*(C`fallback => sub {}\*(C'\fR. An example where this might be useful is if you're
adding signatures to methods which are inherited from a parent class, but
you are not 100% confident will exist (perhaps dependent on the version of
the parent class).
.PP
.Vb 4
\& signature_for add_nums => (
\&   positional => [ Num, Num ],
\&   fallback   => sub { $_[0] + $_[1] },
\& );
.Ve
.PP
\&\f(CW\*(C`signature_for( \e@functions, %opts )\*(C'\fR is a useful shortcut if you have
multiple functions with the same signature.
.SH "LEGACY API"
.IX Header "LEGACY API"
The following functions were the \s-1API\s0 prior to Type::Params v2. They are
still supported, but their use is now discouraged.
.PP
If you don't provide an import list at all, you will import \f(CW\*(C`compile\*(C'\fR
and \f(CW\*(C`compile_named\*(C'\fR:
.PP
.Vb 1
\& use Type::Params;
.Ve
.PP
This does the same:
.PP
.Vb 1
\&  use Type::Params \-v1;
.Ve
.PP
The following exports \f(CW\*(C`compile\*(C'\fR, \f(CW\*(C`compile_named\*(C'\fR, and \f(CW\*(C`compile_named_oo\*(C'\fR:
.PP
.Vb 1
\& use Type::Params \-compile;
.Ve
.PP
The following exports \f(CW\*(C`wrap_subs\*(C'\fR and \f(CW\*(C`wrap_methods\*(C'\fR:
.PP
.Vb 1
\& use Type::Params \-wrap;
.Ve
.ie n .SS """compile( @pos_params )"""
.el .SS "\f(CWcompile( @pos_params )\fP"
.IX Subsection "compile( @pos_params )"
Equivalent to \f(CW\*(C`signature( positional => \e@pos_params )\*(C'\fR.
.PP
\&\f(CW\*(C`compile( \e%spec, @pos_params )\*(C'\fR is equivalent to
\&\f(CW\*(C`signature( %spec, positional => \e@pos_params )\*(C'\fR.
.ie n .SS """compile_named( @named_params )"""
.el .SS "\f(CWcompile_named( @named_params )\fP"
.IX Subsection "compile_named( @named_params )"
Equivalent to \f(CW\*(C`signature( bless => 0, named => \e@named_params )\*(C'\fR.
.PP
\&\f(CW\*(C`compile_named( \e%spec, @named_params )\*(C'\fR is equivalent to
\&\f(CW\*(C`signature( bless => 0, %spec, named => \e@named_params )\*(C'\fR.
.ie n .SS """compile_named_oo( @named_params )"""
.el .SS "\f(CWcompile_named_oo( @named_params )\fP"
.IX Subsection "compile_named_oo( @named_params )"
Equivalent to \f(CW\*(C`signature( bless => 1, named => \e@named_params )\*(C'\fR.
.PP
\&\f(CW\*(C`compile_named_oo( \e%spec, @named_params )\*(C'\fR is equivalent to
\&\f(CW\*(C`signature( bless => 1, %spec, named => \e@named_params )\*(C'\fR.
.ie n .SS """validate( \e@args, @pos_params )"""
.el .SS "\f(CWvalidate( \e@args, @pos_params )\fP"
.IX Subsection "validate( @args, @pos_params )"
Equivalent to \f(CW\*(C`signature( positional => \e@pos_params )\->( @args )\*(C'\fR.
.PP
The \f(CW\*(C`validate\*(C'\fR function has \fInever\fR been recommended, and is not
exported unless requested by name.
.ie n .SS """validate_named( \e@args, @named_params )"""
.el .SS "\f(CWvalidate_named( \e@args, @named_params )\fP"
.IX Subsection "validate_named( @args, @named_params )"
Equivalent to \f(CW\*(C`signature( bless => 0, named => \e@named_params )\->( @args )\*(C'\fR.
.PP
The \f(CW\*(C`validate_named\*(C'\fR function has \fInever\fR been recommended, and is not
exported unless requested by name.
.ie n .SS """wrap_subs( func1 => \e@params1, func2 => \e@params2, ... )"""
.el .SS "\f(CWwrap_subs( func1 => \e@params1, func2 => \e@params2, ... )\fP"
.IX Subsection "wrap_subs( func1 => @params1, func2 => @params2, ... )"
Equivalent to:
.PP
.Vb 2
\& signature_for func1 => ( positional => \e@params1 );
\& signature_for func2 => ( positional => \e@params2 );
.Ve
.PP
One slight difference is that instead of arrayrefs, you can provide the
output of one of the \f(CW\*(C`compile\*(C'\fR functions:
.PP
.Vb 1
\& wrap_subs( func1 => compile_named( @params1 ) );
.Ve
.PP
\&\f(CW\*(C`wrap_subs\*(C'\fR is not exported unless requested by name.
.ie n .SS """wrap_methods( func1 => \e@params1, func2 => \e@params2, ... )"""
.el .SS "\f(CWwrap_methods( func1 => \e@params1, func2 => \e@params2, ... )\fP"
.IX Subsection "wrap_methods( func1 => @params1, func2 => @params2, ... )"
Equivalent to:
.PP
.Vb 2
\& signature_for func1 => ( method => 1, positional => \e@params1 );
\& signature_for func2 => ( method => 1, positional => \e@params2 );
.Ve
.PP
One slight difference is that instead of arrayrefs, you can provide the
output of one of the \f(CW\*(C`compile\*(C'\fR functions:
.PP
.Vb 1
\&  wrap_methods( func1 => compile_named( @params1 ) );
.Ve
.PP
\&\f(CW\*(C`wrap_methods\*(C'\fR is not exported unless requested by name.
.ie n .SS """multisig( @alternatives )"""
.el .SS "\f(CWmultisig( @alternatives )\fP"
.IX Subsection "multisig( @alternatives )"
Equivalent to:
.PP
.Vb 1
\&  signature( multiple => \e@alternatives )
.Ve
.PP
\&\f(CW\*(C`multisig( \e%spec, @alternatives )\*(C'\fR is equivalent to
\&\f(CW\*(C`signature( %spec, multiple => \e@alternatives )\*(C'\fR.
.SH "TYPE CONSTRAINTS"
.IX Header "TYPE CONSTRAINTS"
Although Type::Params is not a real type library, it exports two type
constraints. Their use is no longer recommended.
.SS "\fBInvocant\fP"
.IX Subsection "Invocant"
Type::Params exports a type \fBInvocant\fR on request. This gives you a type
constraint which accepts classnames \fIand\fR blessed objects.
.PP
.Vb 1
\& use Type::Params qw( compile Invocant );
\& 
\& sub my_method {
\&   state $check = signature(
\&     method     => Invocant,
\&     positional => [ ArrayRef, Int ],
\&   );
\&   my ($self_or_class, $arr, $ix) = $check\->(@_);
\&   
\&   return $arr\->[ $ix ];
\& }
.Ve
.PP
\&\f(CW\*(C`Invocant\*(C'\fR is not exported unless requested by name.
.PP
Recommendation: use \fBDefined\fR from Types::Standard instead.
.SS "\fBArgsObject\fP"
.IX Subsection "ArgsObject"
Type::Params exports a parameterizable type constraint \fBArgsObject\fR.
It accepts the kinds of objects returned by signature checks for named
parameters.
.PP
.Vb 3
\&  package Foo {
\&    use Moo;
\&    use Type::Params \*(AqArgsObject\*(Aq;
\&    
\&    has args => (
\&      is  => \*(Aqro\*(Aq,
\&      isa => ArgsObject[\*(AqBar::bar\*(Aq],
\&    );
\&  }
\&  
\&  package Bar {
\&    use Types::Standard \-types;
\&    use Type::Params \*(Aqsignature\*(Aq;
\&    
\&    sub bar {
\&      state $check = signature(
\&        named => [
\&          xxx => Int,
\&          yyy => ArrayRef,
\&        ],
\&      );
\&      my ( $got ) = $check\->( @_ );
\&      
\&      return \*(AqFoo\*(Aq\->new( args => $got );
\&    }
\&  }
\&  
\&  Bar::bar( xxx => 42, yyy => [] );
.Ve
.PP
The parameter \*(L"Bar::bar\*(R" refers to the caller when the check is compiled,
rather than when the parameters are checked.
.PP
\&\f(CW\*(C`ArgsObject\*(C'\fR is not exported unless requested by name.
.PP
Recommendation: use \fBObject\fR from Types::Standard instead.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.ie n .IP """PERL_TYPE_PARAMS_XS""" 4
.el .IP "\f(CWPERL_TYPE_PARAMS_XS\fR" 4
.IX Item "PERL_TYPE_PARAMS_XS"
Affects the building of accessors for \f(CW$arg\fR objects. If set to true,
will use Class::XSAccessor. If set to false, will use pure Perl. If this
environment variable does not exist, will use Class::XSAccessor.
.Sp
If Class::XSAccessor is not installed or is too old, pure Perl will always
be used as a fallback.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<https://github.com/tobyink/p5\-type\-tiny/issues>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The Type::Tiny homepage <https://typetiny.toby.ink/>.
.PP
Type::Tiny, Type::Coercion, Types::Standard.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014, 2017\-2022 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
