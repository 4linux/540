.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Template::Modules 3"
.TH Template::Modules 3 "2022-07-26" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Modules \- Template Toolkit Modules
.SH "Template Toolkit Modules"
.IX Header "Template Toolkit Modules"
This documentation provides an overview of the different modules that
comprise the Template Toolkit.
.SS "Template"
.IX Subsection "Template"
The Template module is the front-end to the Template Toolkit for
Perl programmers.
.PP
.Vb 3
\&    use Template;
\&    my $tt = Template\->new();
\&    $tt\->process(\*(Aqhello.html\*(Aq, message => \*(AqHello World\*(Aq);
.Ve
.SS "Template::Base"
.IX Subsection "Template::Base"
The Template::Base module implements a base class from which the other
Template Toolkit modules are derived.  It implements common functionality
for creating objects, error reporting, debugging, and so on.
.SS "Template::Config"
.IX Subsection "Template::Config"
The Template::Config module defines the configuration of the Template
Toolkit for your system. It is an example of a \fIfactory module\fR which is
responsible for instantiating the various other modules used in the Template
Toolkit.
.PP
For example, the Template::Config module defines the \f(CW$STASH\fR package
variable which indicates which version of the Template::Stash you are
using by default.  If you elected to use the faster \s-1XS\s0
stash when you installed the Template Toolkit, then this will be set as:
.PP
.Vb 1
\&    $STASH = \*(AqTemplate::Stash::XS\*(Aq;
.Ve
.PP
Otherwise you'll get the regular Perl stash:
.PP
.Vb 1
\&    $STASH = \*(AqTemplate::Stash\*(Aq;
.Ve
.PP
This approach means that other parts of the Template Toolkit don't have to
worry about which stash you're using.  They just ask the Template::Config
module to create a stash of the right kind.
.SS "Template::Constants"
.IX Subsection "Template::Constants"
The Template::Constants defines a number of constants that are used by
the Template Toolkit.
.PP
For example, the \f(CW\*(C`:chomp\*(C'\fR tagset defines the \f(CW\*(C`CHOMP_???\*(C'\fR constants that
can be used with the \f(CW\*(C`PRE_CHOMP\*(C'\fR and \f(CW\*(C`POST_CHOMP\*(C'\fR configuration options.
.PP
.Vb 4
\&    use Template::Constants \*(Aq:chomp\*(Aq;
\&    my $tt = Template\->new({
\&        PRE_CHOMP => CHOMP_COLLAPSE,
\&    });
.Ve
.SS "Template::Context"
.IX Subsection "Template::Context"
The Template::Context module defines a runtime context in which templates
are processed. A context keeps track of all the templates, variables, plugins,
and other resources that are available (either directly or through delegate
objects) and provides methods to fetch, store, and perform various operations
on them.
.SS "Template::Document"
.IX Subsection "Template::Document"
The Template::Document module implements a compiled template document
object.  This is generated by the Template::Parser module.
.SS "Template::Exception"
.IX Subsection "Template::Exception"
The Template::Exception module implements an exception object which
is used for runtime error reporting.
.SS "Template::Filters"
.IX Subsection "Template::Filters"
The Template::Filters module implements a filter provider.  It includes
the core collection of filters that can be used via the \f(CW\*(C`FILTER\*(C'\fR directive.
.SS "Template::Iterator"
.IX Subsection "Template::Iterator"
The Template::Iterator module implements a data iterator which steps
through each item in a list in turn.  It is used by the \f(CW\*(C`FOREACH\*(C'\fR directive.
Within a \f(CW\*(C`FOREACH\*(C'\fR block, the \f(CW\*(C`loop\*(C'\fR variable always references the
current iterator object.
.PP
.Vb 10
\&    [%  FOREACH item IN list;
\&          IF loop.first;
\&             # first item in loop
\&          ELSIF loop.last;
\&             # last item in loop
\&          ELSE;
\&             # any other item in loop
\&          END;
\&        END
\&    %]
.Ve
.SS "Template::Namespace::Constants"
.IX Subsection "Template::Namespace::Constants"
The Template::Namespace::Constants module is used internally to represent
constants. These can be resolved immediately at the point that a template is
compiled.
.SS "Template::Parser"
.IX Subsection "Template::Parser"
The Template::Parser module is used to parse a source template and turn it
into Perl code which can be executed.
.SS "Template::Plugin"
.IX Subsection "Template::Plugin"
The Template::Plugin module is a base class for Template Toolkit plugins
that can be loaded on demand from within a template using the \f(CW\*(C`USE\*(C'\fR directive.
.SS "Template::Plugins"
.IX Subsection "Template::Plugins"
The Template::Plugins module is the plugins provider.  It loads and prepares
plugins as and when they are requested from within a template.
.SS "Template::Provider"
.IX Subsection "Template::Provider"
The Template::Provider module is responsible for loading, compiling and
caching templates.
.SS "Template::Service"
.IX Subsection "Template::Service"
The Template::Service module implements a service layer that sits just
behind the Template module, and just in front of a Template::Context. It
handles each request to process a template (forwarded from the Template
module). It adds any headers and/or footers (specified via the \f(CW\*(C`PRE_PROCESS\*(C'\fR
and \f(CW\*(C`POST_PROCESS\*(C'\fR options), applies any wrapper (the \f(CW\*(C`WRAPPER\*(C'\fR option) and
catches any errors returned (the \f(CW\*(C`ERRORS\*(C'\fR option).
.SS "Template::Stash"
.IX Subsection "Template::Stash"
The Template::Stash module is used to fetch and store template variables.
It implements all of the magic associated with the dot operator.
.SS "Template::Stash::XS"
.IX Subsection "Template::Stash::XS"
The Template::Stash::XS module is a high-speed implementation of
Template::Stash written in C.
.SS "Template::Test"
.IX Subsection "Template::Test"
The Template::Test module is used to automate the Template Toolkit
test scripts.
