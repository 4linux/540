.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Ref::Util 3"
.TH Ref::Util 3 "2018-04-19" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Ref::Util \- Utility functions for checking references
.SH "VERSION"
.IX Header "VERSION"
version 0.204
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Ref::Util qw( is_plain_arrayref is_plain_hashref );
\&
\&    if ( is_plain_arrayref( $something ) ) {
\&        print for @{ $something };
\&    } elsif ( is_plain_hashref( $something ) ) {
\&        print for sort values %{ $something };
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Ref::Util introduces several functions to help identify references in a
\&\fBsmarter\fR (and usually faster) way. In short:
.PP
.Vb 1
\&    # conventional approach             # with Ref::Util
\&
\&    ref( $foo ) eq \*(AqARRAY\*(Aq              is_plain_arrayref( $foo )
\&
\&    use Scalar::Util qw( reftype );
\&    reftype( $foo ) eq \*(AqARRAY\*(Aq          is_arrayref( $foo )
.Ve
.PP
The difference:
.IP "\(bu" 4
No comparison against a string constant
.Sp
When you call \f(CW\*(C`ref\*(C'\fR, you stringify the reference and then compare it
to some string constant (like \f(CW\*(C`ARRAY\*(C'\fR or \f(CW\*(C`HASH\*(C'\fR). Not just awkward,
it's brittle since you can mispell the string.
.Sp
If you use Scalar::Util's \f(CW\*(C`reftype\*(C'\fR, you still compare it as a
string:
.Sp
.Vb 1
\&    if ( reftype($foo) eq \*(AqARRAY\*(Aq ) { ... }
.Ve
.IP "\(bu" 4
Supports blessed variables
.Sp
\&\fBNote:\fR In future versions, the idea is to make the default functions
use the \fBplain\fR variation, which means explicitly non-blessed references.
.Sp
If you want to explicitly check for \fBblessed\fR references, you should use
the \f(CW\*(C`is_blessed_*\*(C'\fR functions. There will be an \f(CW\*(C`is_any_*\*(C'\fR variation
which will act like the current main functions \- not caring whether it's
blessed or not.
.Sp
When calling \f(CW\*(C`ref\*(C'\fR, you receive either the reference type (\fB\s-1SCALAR\s0\fR,
\&\fB\s-1ARRAY\s0\fR, \fB\s-1HASH\s0\fR, etc.) or the package it's blessed into.
.Sp
When calling \f(CW\*(C`is_arrayref\*(C'\fR (et. al.), you check the variable flags,
so even if it's blessed, you know what type of variable is blessed.
.Sp
.Vb 2
\&    my $foo = bless {}, \*(AqPKG\*(Aq;
\&    ref($foo) eq \*(AqHASH\*(Aq; # fails
\&
\&    use Ref::Util \*(Aqis_hashref\*(Aq;
\&    my $foo = bless {}, \*(AqPKG\*(Aq;
\&    is_hashref($foo); # works
.Ve
.Sp
On the other hand, in some situations it might be better to specifically
exclude blessed references. The rationale for that might be that merely
because some object happens to be implemented using a hash doesn't mean it's
necessarily correct to treat it as a hash. For these situations, you can use
\&\f(CW\*(C`is_plain_hashref\*(C'\fR and friends, which have the same performance benefits as
\&\f(CW\*(C`is_hashref\*(C'\fR.
.Sp
There is also a family of functions with names like \f(CW\*(C`is_blessed_hashref\*(C'\fR;
these return true for blessed object instances that are implemented using
the relevant underlying type.
.IP "\(bu" 4
Supports tied variables and magic
.Sp
Tied variables (used in Readonly, for example) are supported.
.Sp
.Vb 2
\&    use Ref::Util qw<is_plain_hashref>;
\&    use Readonly;
\&
\&    Readonly::Scalar my $rh2 => { a => { b => 2 } };
\&    is_plain_hashref($rh2); # success
.Ve
.Sp
Ref::Util added support for this in 0.100. Prior to this version
the test would fail.
.IP "\(bu" 4
Ignores overloading
.Sp
These functions ignore overloaded operators and simply check the
variable type. Overloading will likely not ever be supported, since I
deem it problematic and confusing.
.Sp
Overloading makes your variables opaque containers and hides away
\&\fBwhat\fR they are and instead require you to figure out \fBhow\fR to use
them. This leads to code that has to test different abilities (in
\&\f(CW\*(C`eval\*(C'\fR, so it doesn't crash) and to interfaces that get around what
a person thought you would do with a variable. This would have been
alright, except there is no clear way of introspecting it.
.IP "\(bu" 4
Ignores subtle types:
.Sp
The following types, provided by Scalar::Util's \f(CW\*(C`reftype\*(C'\fR, are
not supported:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`VSTRING\*(C'\fR
.Sp
This is a \f(CW\*(C`PVMG\*(C'\fR (\*(L"normal\*(R" variable) with a flag set for VSTRINGs.
Since this is not a reference, it is not supported.
.IP "\(bu" 4
\&\f(CW\*(C`LVALUE\*(C'\fR
.Sp
A variable that delegates to another scalar. Since this is not a
reference, it is not supported.
.IP "\(bu" 4
\&\f(CW\*(C`INVLIST\*(C'\fR
.Sp
I couldn't find documentation for this type.
.RE
.RS 4
.Sp
Support might be added, if a good reason arises.
.RE
.IP "\(bu" 4
Usually fast
.Sp
When possible, Ref::Util uses Ref::Util::XS as its implementation. (If
you don't have a C compiler available, it uses a pure Perl fallback that has
all the other advantages of Ref::Util, but isn't as fast.)
.Sp
In fact, Ref::Util::XS has two alternative implementations available
internally, depending on the features supported by the version of Perl
you're using. For Perls that supports custom OPs, we actually add an \s-1OP\s0
(which is faster); for other Perls, the implementation that simply calls an
\&\s-1XS\s0 function (which is still faster than the pure-Perl equivalent).
.Sp
See below for benchmark results.
.SH "EXPORT"
.IX Header "EXPORT"
Nothing is exported by default. You can ask for specific subroutines
(described below) or ask for all subroutines at once:
.PP
.Vb 1
\&    use Ref::Util qw<is_scalarref is_arrayref is_hashref ...>;
\&
\&    # or
\&
\&    use Ref::Util \*(Aq:all\*(Aq;
.Ve
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "is_ref($ref)"
.IX Subsection "is_ref($ref)"
Check for a reference to anything.
.PP
.Vb 1
\&    is_ref([]);
.Ve
.SS "is_scalarref($ref)"
.IX Subsection "is_scalarref($ref)"
Check for a scalar reference.
.PP
.Vb 3
\&    is_scalarref(\e"hello");
\&    is_scalarref(\e30);
\&    is_scalarref(\e$value);
.Ve
.PP
Note that, even though a reference is itself a type of scalar value, a
reference to another reference is not treated as a scalar reference:
.PP
.Vb 1
\&    !is_scalarref(\e\e1);
.Ve
.PP
The rationale for this is two-fold. First, callers that want to decide how
to handle inputs based on their reference type will usually want to treat a
ref-ref and a scalar-ref differently. Secondly, this more closely matches
the behavior of the \f(CW\*(C`ref\*(C'\fR built-in and of \*(L"reftype\*(R" in Scalar::Util, which
report a ref-ref as \f(CW\*(C`REF\*(C'\fR rather than \f(CW\*(C`SCALAR\*(C'\fR.
.SS "is_arrayref($ref)"
.IX Subsection "is_arrayref($ref)"
Check for an array reference.
.PP
.Vb 1
\&    is_arrayref([]);
.Ve
.SS "is_hashref($ref)"
.IX Subsection "is_hashref($ref)"
Check for a hash reference.
.PP
.Vb 1
\&    is_hashref({});
.Ve
.SS "is_coderef($ref)"
.IX Subsection "is_coderef($ref)"
Check for a code reference.
.PP
.Vb 1
\&    is_coderef( sub {} );
.Ve
.SS "is_regexpref($ref)"
.IX Subsection "is_regexpref($ref)"
Check for a regular expression (regex, regexp) reference.
.PP
.Vb 1
\&    is_regexpref( qr// );
.Ve
.SS "is_globref($ref)"
.IX Subsection "is_globref($ref)"
Check for a glob reference.
.PP
.Vb 1
\&    is_globref( \e*STDIN );
.Ve
.SS "is_formatref($ref)"
.IX Subsection "is_formatref($ref)"
Check for a format reference.
.PP
.Vb 3
\&    # set up format in STDOUT
\&    format STDOUT =
\&    .
\&
\&    # now we can test it
\&    is_formatref( *main::STDOUT{\*(AqFORMAT\*(Aq} );
.Ve
.PP
This function is not available in Perl 5.6 and will trigger a
\&\f(CW\*(C`croak()\*(C'\fR.
.SS "is_ioref($ref)"
.IX Subsection "is_ioref($ref)"
Check for an \s-1IO\s0 reference.
.PP
.Vb 1
\&    is_ioref( *STDOUT{IO} );
.Ve
.SS "is_refref($ref)"
.IX Subsection "is_refref($ref)"
Check for a reference to a reference.
.PP
.Vb 1
\&    is_refref( \e[] ); # reference to array reference
.Ve
.SS "is_plain_scalarref($ref)"
.IX Subsection "is_plain_scalarref($ref)"
Check for an unblessed scalar reference.
.PP
.Vb 3
\&    is_plain_scalarref(\e"hello");
\&    is_plain_scalarref(\e30);
\&    is_plain_scalarref(\e$value);
.Ve
.SS "is_plain_ref($ref)"
.IX Subsection "is_plain_ref($ref)"
Check for an unblessed reference to anything.
.PP
.Vb 1
\&    is_plain_ref([]);
.Ve
.SS "is_plain_arrayref($ref)"
.IX Subsection "is_plain_arrayref($ref)"
Check for an unblessed array reference.
.PP
.Vb 1
\&    is_plain_arrayref([]);
.Ve
.SS "is_plain_hashref($ref)"
.IX Subsection "is_plain_hashref($ref)"
Check for an unblessed hash reference.
.PP
.Vb 1
\&    is_plain_hashref({});
.Ve
.SS "is_plain_coderef($ref)"
.IX Subsection "is_plain_coderef($ref)"
Check for an unblessed code reference.
.PP
.Vb 1
\&    is_plain_coderef( sub {} );
.Ve
.SS "is_plain_globref($ref)"
.IX Subsection "is_plain_globref($ref)"
Check for an unblessed glob reference.
.PP
.Vb 1
\&    is_plain_globref( \e*STDIN );
.Ve
.SS "is_plain_formatref($ref)"
.IX Subsection "is_plain_formatref($ref)"
Check for an unblessed format reference.
.PP
.Vb 3
\&    # set up format in STDOUT
\&    format STDOUT =
\&    .
\&
\&    # now we can test it
\&    is_plain_formatref(bless *main::STDOUT{\*(AqFORMAT\*(Aq} );
.Ve
.SS "is_plain_refref($ref)"
.IX Subsection "is_plain_refref($ref)"
Check for an unblessed reference to a reference.
.PP
.Vb 1
\&    is_plain_refref( \e[] ); # reference to array reference
.Ve
.SS "is_blessed_scalarref($ref)"
.IX Subsection "is_blessed_scalarref($ref)"
Check for a blessed scalar reference.
.PP
.Vb 1
\&    is_blessed_scalarref(bless \e$value);
.Ve
.SS "is_blessed_ref($ref)"
.IX Subsection "is_blessed_ref($ref)"
Check for a blessed reference to anything.
.PP
.Vb 1
\&    is_blessed_ref(bless [], $class);
.Ve
.SS "is_blessed_arrayref($ref)"
.IX Subsection "is_blessed_arrayref($ref)"
Check for a blessed array reference.
.PP
.Vb 1
\&    is_blessed_arrayref(bless [], $class);
.Ve
.SS "is_blessed_hashref($ref)"
.IX Subsection "is_blessed_hashref($ref)"
Check for a blessed hash reference.
.PP
.Vb 1
\&    is_blessed_hashref(bless {}, $class);
.Ve
.SS "is_blessed_coderef($ref)"
.IX Subsection "is_blessed_coderef($ref)"
Check for a blessed code reference.
.PP
.Vb 1
\&    is_blessed_coderef( bless sub {}, $class );
.Ve
.SS "is_blessed_globref($ref)"
.IX Subsection "is_blessed_globref($ref)"
Check for a blessed glob reference.
.PP
.Vb 1
\&    is_blessed_globref( bless \e*STDIN, $class );
.Ve
.SS "is_blessed_formatref($ref)"
.IX Subsection "is_blessed_formatref($ref)"
Check for a blessed format reference.
.PP
.Vb 3
\&    # set up format for FH
\&    format FH =
\&    .
\&
\&    # now we can test it
\&    is_blessed_formatref(bless *FH{\*(AqFORMAT\*(Aq}, $class );
.Ve
.SS "is_blessed_refref($ref)"
.IX Subsection "is_blessed_refref($ref)"
Check for a blessed reference to a reference.
.PP
.Vb 1
\&    is_blessed_refref( bless \e[], $class ); # reference to array reference
.Ve
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
Here is a benchmark comparing similar checks.
.PP
.Vb 4
\&    my $bench = Dumbbench\->new(
\&        target_rel_precision => 0.005,
\&        initial_runs         => 20,
\&    );
\&
\&    my $amount = 1e7;
\&    my $ref    = [];
\&    $bench\->add_instances(
\&        Dumbbench::Instance::PerlSub\->new(
\&            name => \*(AqRef::Util::is_plain_arrayref (CustomOP)\*(Aq,
\&            code => sub {
\&                Ref::Util::is_plain_arrayref($ref) for ( 1 .. $amount )
\&            },
\&        ),
\&
\&        Dumbbench::Instance::PerlSub\->new(
\&            name => \*(Aqref(), reftype(), !blessed()\*(Aq,
\&            code => sub {
\&                ref $ref
\&                    && Scalar::Util::reftype($ref) eq \*(AqARRAY\*(Aq
\&                    && !Scalar::Util::blessed($ref)
\&                    for ( 1 .. $amount );
\&            },
\&        ),
\&
\&        Dumbbench::Instance::PerlSub\->new(
\&            name => \*(Aqref()\*(Aq,
\&            code => sub { ref($ref) eq \*(AqARRAY\*(Aq for ( 1 .. $amount ) },
\&        ),
\&
\&        Dumbbench::Instance::PerlSub\->new(
\&            name => \*(AqData::Util::is_array_ref\*(Aq,
\&            code => sub { is_array_ref($ref) for ( 1 .. $amount ) },
\&        ),
\&
\&    );
.Ve
.PP
The results:
.PP
.Vb 4
\&    ref():                                   5.335e+00 +/\- 1.8e\-02 (0.3%)
\&    ref(), reftype(), !blessed():            1.5545e+01 +/\- 3.1e\-02 (0.2%)
\&    Ref::Util::is_plain_arrayref (CustomOP): 2.7951e+00 +/\- 6.2e\-03 (0.2%)
\&    Data::Util::is_array_ref:                5.9074e+00 +/\- 7.5e\-03 (0.1%)
.Ve
.PP
(Rounded run time per iteration)
.PP
A benchmark against Data::Util:
.PP
.Vb 2
\&    Ref::Util::is_plain_arrayref: 3.47157e\-01 +/\- 6.8e\-05 (0.0%)
\&    Data::Util::is_array_ref:     6.7562e\-01 +/\- 7.5e\-04 (0.1%)
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Params::Classify
.IP "\(bu" 4
Scalar::Util
.IP "\(bu" 4
Data::Util
.SH "THANKS"
.IX Header "THANKS"
The following people have been invaluable in their feedback and support.
.IP "\(bu" 4
Yves Orton
.IP "\(bu" 4
Steffen Müller
.IP "\(bu" 4
Jarkko Hietaniemi
.IP "\(bu" 4
Mattia Barbon
.IP "\(bu" 4
Zefram
.IP "\(bu" 4
Tony Cook
.IP "\(bu" 4
Sergey Aleynikov
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Aaron Crane
.IP "\(bu" 4
Vikentiy Fesunov
.IP "\(bu" 4
Sawyer X
.IP "\(bu" 4
Gonzalo Diethelm
.IP "\(bu" 4
p5pclub
.SH "LICENSE"
.IX Header "LICENSE"
This software is made available under the \s-1MIT\s0 Licence as stated in the
accompanying \s-1LICENSE\s0 file.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Sawyer X <xsawyerx@cpan.org>
.IP "\(bu" 4
Aaron Crane <arc@cpan.org>
.IP "\(bu" 4
Vikenty Fesunov <vyf@cpan.org>
.IP "\(bu" 4
Gonzalo Diethelm <gonzus@cpan.org>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2017 by Sawyer X.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
