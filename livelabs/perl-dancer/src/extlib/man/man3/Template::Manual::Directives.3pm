.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Template::Manual::Directives 3"
.TH Template::Manual::Directives 3 "2022-07-26" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Manual::Directives \- Template directives
.SH "Accessing and Updating Template Variables"
.IX Header "Accessing and Updating Template Variables"
.SS "\s-1GET\s0"
.IX Subsection "GET"
The \f(CW\*(C`GET\*(C'\fR directive retrieves and outputs the value of the named variable.
.PP
.Vb 1
\&    [% GET foo %]
.Ve
.PP
The \f(CW\*(C`GET\*(C'\fR keyword is optional.  A variable can be specified in a directive
tag by itself.
.PP
.Vb 1
\&    [% foo %]
.Ve
.PP
The variable can have an unlimited number of elements, each separated by a
dot. Each element can have arguments specified within parentheses.
.PP
.Vb 4
\&    [% foo %]
\&    [% bar.baz %]
\&    [% biz.baz(10) %]
\&    ...etc...
.Ve
.PP
See Template::Manual::Variables for a full discussion on template
variables.
.PP
You can also specify expressions using the logical (\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`not\*(C'\fR, \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`:\*(C'\fR) and
mathematic operators (\f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`/\*(C'\fR, \f(CW\*(C`%\*(C'\fR, \f(CW\*(C`mod\*(C'\fR, \f(CW\*(C`div\*(C'\fR).
.PP
.Vb 1
\&    [% template.title or default.title %]
\&
\&    [% score * 100 %]
\&
\&    [% order.nitems ? checkout(order.total) : \*(Aqno items\*(Aq %]
.Ve
.PP
The \f(CW\*(C`div\*(C'\fR operator returns the integer result of division.  Both \f(CW\*(C`%\*(C'\fR and
\&\f(CW\*(C`mod\*(C'\fR return the modulus (i.e. remainder) of division.
.PP
.Vb 3
\&    [% 15 / 6 %]            # 2.5
\&    [% 15 div 6 %]          # 2
\&    [% 15 mod 6 %]          # 3
.Ve
.SS "\s-1CALL\s0"
.IX Subsection "CALL"
The \f(CW\*(C`CALL\*(C'\fR directive is similar to \f(CW\*(C`GET\*(C'\fR in evaluating the variable named,
but doesn't print the result returned.  This can be useful when a
variable is bound to a sub-routine or object method which you want to
call but aren't interested in the value returned.
.PP
.Vb 1
\&    [% CALL dbi.disconnect %]
\&
\&    [% CALL inc_page_counter(page_count) %]
.Ve
.SS "\s-1SET\s0"
.IX Subsection "SET"
The \f(CW\*(C`SET\*(C'\fR directive allows you to assign new values to existing variables
or create new temporary variables.
.PP
.Vb 1
\&    [% SET title = \*(AqHello World\*(Aq %]
.Ve
.PP
The \f(CW\*(C`SET\*(C'\fR keyword is also optional.
.PP
.Vb 1
\&    [% title = \*(AqHello World\*(Aq %]
.Ve
.PP
Variables may be assigned the values of other variables, unquoted
numbers (2.718), literal text ('single quotes') or quoted text
(\*(L"double quotes\*(R").  In the latter case, any variable references within
the text will be interpolated when the string is evaluated.  Variables
should be prefixed by \f(CW\*(C`$\*(C'\fR, using curly braces to explicitly scope
the variable name where necessary.
.PP
.Vb 4
\&    [% foo  = \*(AqFoo\*(Aq  %]               # literal value \*(AqFoo\*(Aq
\&    [% bar  =  foo   %]               # value of variable \*(Aqfoo\*(Aq
\&    [% cost = \*(Aq$100\*(Aq %]               # literal value \*(Aq$100\*(Aq
\&    [% item = "$bar: ${cost}.00" %]   # value "Foo: $100.00"
.Ve
.PP
Multiple variables may be assigned in the same directive and are
evaluated in the order specified.  Thus, the above could have been
written:
.PP
.Vb 5
\&    [% foo  = \*(AqFoo\*(Aq
\&       bar  = foo
\&       cost = \*(Aq$100\*(Aq
\&       item = "$bar: ${cost}.00"
\&    %]
.Ve
.PP
Simple expressions can also be used, as per \f(CW\*(C`GET\*(C'\fR.
.PP
.Vb 7
\&    [% ten    = 10
\&       twenty = 20
\&       thirty = twenty + ten
\&       forty  = 2 * twenty
\&       fifty  = 100 div 2
\&       six    = twenty mod 7
\&    %]
.Ve
.PP
You can concatenate strings together using the \f(CW\*(Aq_\*(Aq\fR underscore operator.  In Perl 5,
the \f(CW\*(C`.\*(C'\fR dot is used for string concatenation, but in Perl 6, as in the Template
Toolkit, the \f(CW\*(C`.\*(C'\fR dot will be used as the method calling operator and \f(CW\*(Aq_\*(Aq\fR underscore will
be used for string concatenation.  Note that the operator must be
specified with surrounding whitespace which, as Larry says, is construed as
a feature:
.PP
.Vb 1
\&    [% copyright = \*(Aq(C) Copyright\*(Aq _ year _ \*(Aq \*(Aq _ author %]
.Ve
.PP
You can, of course, achieve a similar effect with double quoted string
interpolation.
.PP
.Vb 1
\&    [% copyright = "(C) Copyright $year $author" %]
.Ve
.SS "\s-1DEFAULT\s0"
.IX Subsection "DEFAULT"
The \f(CW\*(C`DEFAULT\*(C'\fR directive is similar to \f(CW\*(C`SET\*(C'\fR but only updates variables
that are currently undefined or have no \*(L"true\*(R" value (in the Perl
sense).
.PP
.Vb 4
\&    [% DEFAULT
\&        name = \*(AqJohn Doe\*(Aq
\&        id   = \*(Aqjdoe\*(Aq
\&    %]
.Ve
.PP
This can be particularly useful in common template components to
ensure that some sensible default are provided for otherwise
undefined variables.
.PP
.Vb 10
\&    [% DEFAULT
\&       title = \*(AqHello World\*(Aq
\&       bgcol = \*(Aq#ffffff\*(Aq
\&    %]
\&    <html>
\&      <head>
\&        <title>[% title %]</title>
\&      </head>
\&      <body bgcolor="[% bgcol %]">
\&        ...etc...
.Ve
.SH "Processing Template Files and Blocks"
.IX Header "Processing Template Files and Blocks"
.SS "\s-1INSERT\s0"
.IX Subsection "INSERT"
The \f(CW\*(C`INSERT\*(C'\fR directive is used to insert the contents of an external file
at the current position.
.PP
.Vb 1
\&    [% INSERT myfile %]
.Ve
.PP
No attempt to parse or process the file is made.  The contents,
possibly including any embedded template directives, are inserted
intact.
.PP
The filename specified should be relative to one of the \f(CW\*(C`INCLUDE_PATH\*(C'\fR
directories.  Absolute (i.e. starting with \f(CW\*(C`/\*(C'\fR) and relative
(i.e. starting with \f(CW\*(C`.\*(C'\fR) filenames may be used if the \f(CW\*(C`ABSOLUTE\*(C'\fR and
\&\f(CW\*(C`RELATIVE\*(C'\fR options are set, respectively.  Both these options are
disabled by default.
.PP
.Vb 3
\&    my $template = Template\->new({
\&        INCLUDE_PATH => \*(Aq/here:/there\*(Aq,
\&    });
\&
\&    $template\->process(\*(Aqmyfile\*(Aq);
.Ve
.PP
\&\fImyfile\fR:
.PP
.Vb 3
\&    [% INSERT foo %]            # looks for /here/foo then /there/foo
\&    [% INSERT /etc/passwd %]    # file error: ABSOLUTE not set
\&    [% INSERT ../secret %]      # file error: RELATIVE not set
.Ve
.PP
For convenience, the filename does not need to be quoted as long as it
contains only alphanumeric characters, underscores, dots or forward
slashes.  Names containing any other characters should be quoted.
.PP
.Vb 2
\&    [% INSERT misc/legalese.txt            %]
\&    [% INSERT \*(Aqdos98/Program Files/stupid\*(Aq %]
.Ve
.PP
To evaluate a variable to specify a filename, you should explicitly
prefix it with a \f(CW\*(C`$\*(C'\fR or use double-quoted string interpolation.
.PP
.Vb 3
\&    [% language = \*(Aqen\*(Aq
\&       legalese = \*(Aqmisc/legalese.txt\*(Aq
\&    %]
\&
\&    [% INSERT $legalese %]              # misc/legalese.txt
\&    [% INSERT "$language/$legalese" %]  # en/misc/legalese.txt
.Ve
.PP
Multiple files can be specified using \f(CW\*(C`+\*(C'\fR as a delimiter.  All files
should be unquoted names or quoted strings.  Any variables should be
interpolated into double-quoted strings.
.PP
.Vb 2
\&    [% INSERT legalese.txt + warning.txt %]
\&    [% INSERT  "$legalese" + warning.txt %]  # requires quoting
.Ve
.SS "\s-1INCLUDE\s0"
.IX Subsection "INCLUDE"
The \f(CW\*(C`INCLUDE\*(C'\fR directive is used to process and include the output of
another template file or block.
.PP
.Vb 1
\&    [% INCLUDE header %]
.Ve
.PP
If a \f(CW\*(C`BLOCK\*(C'\fR of the specified name is defined in the same file, or in a file
from which the current template has been called (i.e. a parent template) then
it will be used in preference to any file of the same name.
.PP
.Vb 1
\&    [% INCLUDE table %]     # uses BLOCK defined below
\&
\&    [% BLOCK table %]
\&       <table>
\&         ...
\&       </table>
\&    [% END %]
.Ve
.PP
If a \f(CW\*(C`BLOCK\*(C'\fR definition is not currently visible then the template name
should be a file relative to one of the \f(CW\*(C`INCLUDE_PATH\*(C'\fR directories, or
an absolute or relative file name if the \f(CW\*(C`ABSOLUTE\*(C'\fR/\f(CW\*(C`RELATIVE\*(C'\fR options are
appropriately enabled.  The \f(CW\*(C`INCLUDE\*(C'\fR directive automatically quotes the
filename specified, as per \f(CW\*(C`INSERT\*(C'\fR described above.  When a variable
contains the name of the template for the \f(CW\*(C`INCLUDE\*(C'\fR directive, it should
be explicitly prefixed by \f(CW\*(C`$\*(C'\fR or double-quoted
.PP
.Vb 4
\&    [% myheader = \*(Aqmy/misc/header\*(Aq %]
\&    [% INCLUDE   myheader  %]           # \*(Aqmyheader\*(Aq
\&    [% INCLUDE  $myheader  %]           # \*(Aqmy/misc/header\*(Aq
\&    [% INCLUDE "$myheader" %]           # \*(Aqmy/misc/header\*(Aq
.Ve
.PP
Any template directives embedded within the file will be processed
accordingly.  All variables currently defined will be visible and
accessible from within the included template.
.PP
.Vb 4
\&    [% title = \*(AqHello World\*(Aq %]
\&    [% INCLUDE header %]
\&    <body>
\&    ...
.Ve
.PP
\&\fIheader\fR:
.PP
.Vb 2
\&    <html>
\&    <title>[% title %]</title>
.Ve
.PP
output:
.PP
.Vb 4
\&    <html>
\&    <title>Hello World</title>
\&    <body>
\&    ...
.Ve
.PP
Local variable definitions may be specified after the template name,
temporarily masking any existing variables.  Insignificant whitespace
is ignored within directives so you can add variable definitions on the
same line, the next line or split across several line with comments
interspersed, if you prefer.
.PP
.Vb 1
\&    [% INCLUDE table %]
\&
\&    [% INCLUDE table title="Active Projects" %]
\&
\&    [% INCLUDE table
\&         title   = "Active Projects"
\&         bgcolor = "#80ff00"    # chartreuse
\&         border  = 2
\&    %]
.Ve
.PP
The \f(CW\*(C`INCLUDE\*(C'\fR directive localises (i.e. copies) all variables before
processing the template.  Any changes made within the included
template will not affect variables in the including template.
.PP
.Vb 1
\&    [% foo = 10 %]
\&
\&    foo is originally [% foo %]
\&    [% INCLUDE bar %]
\&    foo is still [% foo %]
\&
\&    [% BLOCK bar %]
\&       foo was [% foo %]
\&       [% foo = 20 %]
\&       foo is now [% foo %]
\&    [% END %]
.Ve
.PP
output:
.PP
.Vb 4
\&    foo is originally 10
\&       foo was 10
\&       foo is now 20
\&    foo is still 10
.Ve
.PP
Technical Note: the localisation of the stash (that is, the process by
which variables are copied before an \f(CW\*(C`INCLUDE\*(C'\fR to prevent being
overwritten) is only skin deep.  The top-level variable namespace
(hash) is copied, but no attempt is made to perform a deep-copy of
other structures (hashes, arrays, objects, etc.)  Therefore, a \f(CW\*(C`foo\*(C'\fR
variable referencing a hash will be copied to create a new \f(CW\*(C`foo\*(C'\fR
variable but which points to the same hash array.  Thus, if you update
compound variables (e.g. \f(CW\*(C`foo.bar\*(C'\fR) then you will change the original
copy, regardless of any stash localisation.  If you're not worried
about preserving variable values, or you trust the templates you're
including then you might prefer to use the \f(CW\*(C`PROCESS\*(C'\fR directive which is
faster by virtue of not performing any localisation.
.PP
You can specify dotted variables as \*(L"local\*(R" variables to an \f(CW\*(C`INCLUDE\*(C'\fR directive.
However, be aware that because of the localisation issues explained above (if
you skipped the previous Technical Note above then you might want to go back
and read it or skip this section too), the variables might not actually be
\&\*(L"local\*(R". If the first element of the variable name already references a hash
array then the variable update will affect the original variable.
.PP
.Vb 4
\&    [% foo = {
\&           bar = \*(AqBaz\*(Aq
\&       }
\&    %]
\&
\&    [% INCLUDE somefile foo.bar=\*(AqBoz\*(Aq %]
\&
\&    [% foo.bar %]           # Boz
.Ve
.PP
This behaviour can be a little unpredictable (and may well be improved
upon in a future version).  If you know what you're doing with it and
you're sure that the variables in question are defined (nor not) as you
expect them to be, then you can rely on this feature to implement some
powerful \*(L"global\*(R" data sharing techniques.  Otherwise, you might prefer
to steer well clear and always pass simple (undotted) variables as
parameters to \f(CW\*(C`INCLUDE\*(C'\fR and other similar directives.
.PP
If you want to process several templates in one go then you can
specify each of their names (quoted or unquoted names only, no unquoted
\&\f(CW$variables\fR) joined together by \f(CW\*(C`+\*(C'\fR.  The \f(CW\*(C`INCLUDE\*(C'\fR directive
will then process them in order.
.PP
.Vb 3
\&    [% INCLUDE html/header + "site/$header" + site/menu
\&         title = "My Groovy Web Site"
\&    %]
.Ve
.PP
The variable stash is localised once and then the templates specified
are processed in order, all within that same variable context.  This
makes it slightly faster than specifying several separate \f(CW\*(C`INCLUDE\*(C'\fR
directives (because you only clone the variable stash once instead of
n times), but not quite as \*(L"safe\*(R" because any variable changes in the
first file will be visible in the second, third and so on.  This
might be what you want, of course, but then again, it might not.
.SS "\s-1PROCESS\s0"
.IX Subsection "PROCESS"
The \s-1PROCESS\s0 directive is similar to \f(CW\*(C`INCLUDE\*(C'\fR but does not perform any
localisation of variables before processing the template.  Any changes
made to variables within the included template will be visible in the
including template.
.PP
.Vb 1
\&    [% foo = 10 %]
\&
\&    foo is [% foo %]
\&    [% PROCESS bar %]
\&    foo is [% foo %]
\&
\&    [% BLOCK bar %]
\&       [% foo = 20 %]
\&       changed foo to [% foo %]
\&    [% END %]
.Ve
.PP
output:
.PP
.Vb 3
\&    foo is 10
\&       changed foo to 20
\&    foo is 20
.Ve
.PP
Parameters may be specified in the \f(CW\*(C`PROCESS\*(C'\fR directive, but these too will
become visible changes to current variable values.
.PP
.Vb 6
\&    [% foo = 10 %]
\&    foo is [% foo %]
\&    [% PROCESS bar
\&       foo = 20
\&    %]
\&    foo is [% foo %]
\&
\&    [% BLOCK bar %]
\&       this is bar, foo is [% foo %]
\&    [% END %]
.Ve
.PP
output:
.PP
.Vb 3
\&    foo is 10
\&       this is bar, foo is 20
\&    foo is 20
.Ve
.PP
The \f(CW\*(C`PROCESS\*(C'\fR directive is slightly faster than \f(CW\*(C`INCLUDE\*(C'\fR because it
avoids the need to localise (i.e. copy) the variable stash before
processing the template.  As with \f(CW\*(C`INSERT\*(C'\fR and \f(CW\*(C`INCLUDE\*(C'\fR, the first
parameter does not need to be quoted as long as it contains only
alphanumeric characters, underscores, periods or forward slashes.
A \f(CW\*(C`$\*(C'\fR prefix can be used to explicitly indicate a variable which
should be interpolated to provide the template name:
.PP
.Vb 3
\&    [% myheader = \*(Aqmy/misc/header\*(Aq %]
\&    [% PROCESS  myheader %]              # \*(Aqmyheader\*(Aq
\&    [% PROCESS $myheader %]              # \*(Aqmy/misc/header\*(Aq
.Ve
.PP
As with \f(CW\*(C`INCLUDE\*(C'\fR, multiple templates can be specified, delimited by
\&\f(CW\*(C`+\*(C'\fR, and are processed in order.
.PP
.Vb 1
\&    [% PROCESS html/header + my/header %]
.Ve
.SS "\s-1WRAPPER\s0"
.IX Subsection "WRAPPER"
It's not unusual to find yourself adding common headers and footers to
pages or sub-sections within a page.  Something like this:
.PP
.Vb 6
\&    [% INCLUDE section/header
\&       title = \*(AqQuantum Mechanics\*(Aq
\&    %]
\&       Quantum mechanics is a very interesting subject wish
\&       should prove easy for the layman to fully comprehend.
\&    [% INCLUDE section/footer %]
\&
\&    [% INCLUDE section/header
\&       title = \*(AqDesktop Nuclear Fusion for under $50\*(Aq
\&    %]
\&       This describes a simple device which generates significant
\&       sustainable electrical power from common tap water by process
\&       of nuclear fusion.
\&    [% INCLUDE section/footer %]
.Ve
.PP
The individual template components being included might look like these:
.PP
section/header:
.PP
.Vb 2
\&    <p>
\&    <h2>[% title %]</h2>
.Ve
.PP
section/footer:
.PP
.Vb 1
\&    </p>
.Ve
.PP
The \f(CW\*(C`WRAPPER\*(C'\fR directive provides a way of simplifying this a little. It
encloses a block up to a matching \f(CW\*(C`END\*(C'\fR directive, which is first processed
to generate some output. This is then passed to the named template file or
\&\f(CW\*(C`BLOCK\*(C'\fR as the \f(CW\*(C`content\*(C'\fR variable.
.PP
.Vb 6
\&    [% WRAPPER section
\&       title = \*(AqQuantum Mechanics\*(Aq
\&    %]
\&       Quantum mechanics is a very interesting subject wish
\&       should prove easy for the layman to fully comprehend.
\&    [% END %]
\&
\&    [% WRAPPER section
\&       title = \*(AqDesktop Nuclear Fusion for under $50\*(Aq
\&    %]
\&       This describes a simple device which generates significant
\&       sustainable electrical power from common tap water by process
\&       of nuclear fusion.
\&    [% END %]
.Ve
.PP
The single 'section' template can then be defined as:
.PP
.Vb 4
\&    <h2>[% title %]</h2>
\&    <p>
\&      [% content %]
\&    </p>
.Ve
.PP
Like other block directives, it can be used in side-effect notation:
.PP
.Vb 1
\&    [% INSERT legalese.txt WRAPPER big_bold_table %]
.Ve
.PP
It's also possible to specify multiple templates to a \f(CW\*(C`WRAPPER\*(C'\fR directive.
The specification order indicates outermost to innermost wrapper templates.
For example, given the following template block definitions:
.PP
.Vb 2
\&    [% BLOCK bold   %]<b>[% content %]</b>[% END %]
\&    [% BLOCK italic %]<i>[% content %]</i>[% END %]
.Ve
.PP
the directive
.PP
.Vb 1
\&    [% WRAPPER bold+italic %]Hello World[% END %]
.Ve
.PP
would generate the following output:
.PP
.Vb 1
\&    <b><i>Hello World</i></b>
.Ve
.SS "\s-1BLOCK\s0"
.IX Subsection "BLOCK"
The \f(CW\*(C`BLOCK\*(C'\fR...\f(CW\*(C`END\*(C'\fR construct can be used to define template component
blocks which can be processed with the \f(CW\*(C`INCLUDE\*(C'\fR, \f(CW\*(C`PROCESS\*(C'\fR and \f(CW\*(C`WRAPPER\*(C'\fR
directives.
.PP
.Vb 6
\&    [% BLOCK tabrow %]
\&    <tr>
\&      <td>[% name %]<td>
\&      <td>[% email %]</td>
\&    </tr>
\&    [% END %]
\&
\&    <table>
\&      [% PROCESS tabrow  name=\*(AqFred\*(Aq  email=\*(Aqfred@nowhere.com\*(Aq %]
\&      [% PROCESS tabrow  name=\*(AqAlan\*(Aq  email=\*(Aqalan@nowhere.com\*(Aq %]
\&    </table>
.Ve
.PP
A \f(CW\*(C`BLOCK\*(C'\fR definition can be used before it is defined, as long as the
definition resides in the same file.  The block definition itself does
not generate any output.
.PP
.Vb 1
\&    [% PROCESS tmpblk %]
\&
\&    [% BLOCK tmpblk %] This is OK [% END %]
.Ve
.PP
You can use an anonymous \f(CW\*(C`BLOCK\*(C'\fR to capture the output of a template
fragment.
.PP
.Vb 8
\&    [% julius = BLOCK %]
\&       And Caesar\*(Aqs spirit, ranging for revenge,
\&       With Ate by his side come hot from hell,
\&       Shall in these confines with a monarch\*(Aqs voice
\&       Cry  \*(AqHavoc\*(Aq, and let slip the dogs of war;
\&       That this foul deed shall smell above the earth
\&       With carrion men, groaning for burial.
\&    [% END %]
.Ve
.PP
Like a named block, it can contain any other template directives which
are processed when the block is defined.  The output generated by the
block is then assigned to the variable \f(CW\*(C`julius\*(C'\fR.
.PP
Anonymous \f(CW\*(C`BLOCK\*(C'\fRs can also be used to define block macros.  The
enclosing block is processed each time the macro is called.
.PP
.Vb 3
\&    [% MACRO locate BLOCK %]
\&       The [% animal %] sat on the [% place %].
\&    [% END %]
\&
\&    [% locate(animal=\*(Aqcat\*(Aq, place=\*(Aqmat\*(Aq) %]    # The cat sat on the mat
\&    [% locate(animal=\*(Aqdog\*(Aq, place=\*(Aqlog\*(Aq) %]    # The dog sat on the log
.Ve
.SH "Conditional Processing"
.IX Header "Conditional Processing"
.SS "\s-1IF / UNLESS / ELSIF / ELSE\s0"
.IX Subsection "IF / UNLESS / ELSIF / ELSE"
The \f(CW\*(C`IF\*(C'\fR and \f(CW\*(C`UNLESS\*(C'\fR directives can be used to process or ignore a
block based on some run-time condition.
.PP
.Vb 3
\&    [% IF frames %]
\&       [% INCLUDE frameset %]
\&    [% END %]
\&
\&    [% UNLESS text_mode %]
\&       [% INCLUDE biglogo %]
\&    [% END %]
.Ve
.PP
Multiple conditions may be joined with \f(CW\*(C`ELSIF\*(C'\fR and/or \f(CW\*(C`ELSE\*(C'\fR blocks.
.PP
.Vb 9
\&    [% IF age < 10 %]
\&       Hello [% name %], does your mother know you\*(Aqre
\&       using her AOL account?
\&    [% ELSIF age < 18 %]
\&       Sorry, you\*(Aqre not old enough to enter
\&       (and too dumb to lie about your age)
\&    [% ELSE %]
\&       Welcome [% name %].
\&    [% END %]
.Ve
.PP
The following conditional and boolean operators may be used:
.PP
.Vb 1
\&    == != < <= > >= && || ! and or not
.Ve
.PP
Conditions may be arbitrarily complex and are evaluated with the same
precedence as in Perl.  Parenthesis may be used to explicitly
determine evaluation order.
.PP
.Vb 6
\&    # ridiculously contrived complex example
\&    [% IF (name == \*(Aqadmin\*(Aq || uid <= 0) && mode == \*(Aqdebug\*(Aq %]
\&       I\*(Aqm confused.
\&    [% ELSIF more > less %]
\&       That\*(Aqs more or less correct.
\&    [% END %]
.Ve
.PP
The \f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR and \f(CW\*(C`not\*(C'\fR operator are provided as aliases for
\&\f(CW\*(C`&&\*(C'\fR, \f(CW\*(C`||\*(C'\fR and \f(CW\*(C`!\*(C'\fR, respectively.  Unlike Perl, which treats
\&\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR and \f(CW\*(C`not\*(C'\fR as separate, lower-precedence versions of the
other operators, the Template Toolkit performs a straightforward substitution
of \f(CW\*(C`and\*(C'\fR for \f(CW\*(C`&&\*(C'\fR, and so on.  That means that \f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR and \f(CW\*(C`not\*(C'\fR
have the same operator precedence as \f(CW\*(C`&&\*(C'\fR, \f(CW\*(C`||\*(C'\fR and \f(CW\*(C`!\*(C'\fR.
.SS "\s-1SWITCH / CASE\s0"
.IX Subsection "SWITCH / CASE"
The \f(CW\*(C`SWITCH\*(C'\fR / \f(CW\*(C`CASE\*(C'\fR construct can be used to perform a multi-way
conditional test.  The \f(CW\*(C`SWITCH\*(C'\fR directive expects an expression which is
first evaluated and then compared against each \s-1CASE\s0 statement in turn.
Each \f(CW\*(C`CASE\*(C'\fR directive should contain a single value or a list of values
which should match.  \f(CW\*(C`CASE\*(C'\fR may also be left blank or written as
\&\f(CW\*(C`[% CASE DEFAULT %]\*(C'\fR to specify a default match.  Only one \f(CW\*(C`CASE\*(C'\fR matches,
there is no drop-through between \f(CW\*(C`CASE\*(C'\fR statements.
.PP
.Vb 10
\&    [% SWITCH myvar %]
\&    [%   CASE \*(Aqvalue1\*(Aq %]
\&           ...
\&    [%   CASE [\*(Aqvalue2\*(Aq, \*(Aqvalue3\*(Aq] %]   # multiple values
\&           ...
\&    [%   CASE myhash.keys %]            # ditto
\&           ...
\&    [%   CASE %]                        # default
\&           ...
\&    [% END %]
.Ve
.SH "Loop Processing"
.IX Header "Loop Processing"
.SS "\s-1FOREACH\s0"
.IX Subsection "FOREACH"
The \f(CW\*(C`FOREACH\*(C'\fR directive will iterate through the items in a list, processing
the enclosed block for each one.
.PP
.Vb 3
\&    [% foo   = \*(AqFoo\*(Aq
\&       items = [ \*(Aqone\*(Aq, \*(Aqtwo\*(Aq, \*(Aqthree\*(Aq ]
\&    %]
\&
\&    Things:
\&    [% FOREACH thing IN [ foo \*(AqBar\*(Aq "$foo Baz" ] %]
\&       * [% thing %]
\&    [% END %]
\&
\&    Items:
\&    [% FOREACH i IN items %]
\&       * [% i %]
\&    [% END %]
\&
\&    Stuff:
\&    [% stuff = [ foo "$foo Bar" ] %]
\&    [% FOREACH s IN stuff %]
\&       * [% s %]
\&    [% END %]
.Ve
.PP
output:
.PP
.Vb 4
\&    Things:
\&      * Foo
\&      * Bar
\&      * Foo Baz
\&
\&    Items:
\&      * one
\&      * two
\&      * three
\&
\&    Stuff:
\&      * Foo
\&      * Foo Bar
.Ve
.PP
You can use also use \f(CW\*(C`=\*(C'\fR instead of \f(CW\*(C`IN\*(C'\fR if you prefer.
.PP
.Vb 1
\&    [% FOREACH i = items %]
.Ve
.PP
When the \f(CW\*(C`FOREACH\*(C'\fR directive is used without specifying a target variable,
any iterated values which are hash references will be automatically
imported.
.PP
.Vb 6
\&    [% userlist = [
\&        { id => \*(Aqtom\*(Aq,   name => \*(AqThomas\*(Aq  },
\&        { id => \*(Aqdick\*(Aq,  name => \*(AqRichard\*(Aq  },
\&        { id => \*(Aqlarry\*(Aq, name => \*(AqLawrence\*(Aq },
\&       ]
\&    %]
\&
\&    [% FOREACH user IN userlist %]
\&       [% user.id %] [% user.name %]
\&    [% END %]
.Ve
.PP
short form:
.PP
.Vb 3
\&    [% FOREACH userlist %]
\&       [% id %] [% name %]
\&    [% END %]
.Ve
.PP
Note that this particular usage creates a localised variable context
to prevent the imported hash keys from overwriting any existing
variables.  The imported definitions and any other variables defined
in such a \f(CW\*(C`FOREACH\*(C'\fR loop will be lost at the end of the loop, when the
previous context and variable values are restored.
.PP
However, under normal operation, the loop variable remains in scope
after the \f(CW\*(C`FOREACH\*(C'\fR loop has ended (caveat: overwriting any variable
previously in scope). This is useful as the loop variable is secretly
an iterator object (see below) and can be used to analyse the last
entry processed by the loop.
.PP
The \f(CW\*(C`FOREACH\*(C'\fR directive can also be used to iterate through the entries
in a hash array.  Each entry in the hash is returned in sorted order
(based on the key) as a hash array containing 'key' and 'value' items.
.PP
.Vb 6
\&    [% users = {
\&         tom   => \*(AqThomas\*(Aq,
\&         dick  => \*(AqRichard\*(Aq,
\&         larry => \*(AqLawrence\*(Aq,
\&       }
\&    %]
\&
\&    [% FOREACH u IN users %]
\&       * [% u.key %] : [% u.value %]
\&    [% END %]
.Ve
.PP
Output:
.PP
.Vb 3
\&       * dick : Richard
\&       * larry : Lawrence
\&       * tom : Thomas
.Ve
.PP
The \f(CW\*(C`NEXT\*(C'\fR directive starts the next iteration in the \f(CW\*(C`FOREACH\*(C'\fR loop.
.PP
.Vb 4
\&    [% FOREACH user IN userlist %]
\&       [% NEXT IF user.isguest %]
\&       Name: [% user.name %]    Email: [% user.email %]
\&    [% END %]
.Ve
.PP
The \f(CW\*(C`LAST\*(C'\fR directive can be used to prematurely exit the loop.  \f(CW\*(C`BREAK\*(C'\fR is
also provided as an alias for \f(CW\*(C`LAST\*(C'\fR.
.PP
.Vb 4
\&    [% FOREACH match IN results.nsort(\*(Aqscore\*(Aq).reverse %]
\&       [% LAST IF match.score < 50 %]
\&       [% match.score %] : [% match.url %]
\&    [% END %]
.Ve
.PP
The \f(CW\*(C`FOREACH\*(C'\fR directive is implemented using the Template::Iterator
module.  A reference to the iterator object for a \f(CW\*(C`FOREACH\*(C'\fR directive is
implicitly available in the \f(CW\*(C`loop\*(C'\fR variable.  The following methods
can be called on the \f(CW\*(C`loop\*(C'\fR iterator.
.PP
.Vb 8
\&    size()      number of elements in the list
\&    max()       index number of last element (size \- 1)
\&    index()     index of current iteration from 0 to max()
\&    count()     iteration counter from 1 to size() (i.e. index() + 1)
\&    first()     true if the current iteration is the first
\&    last()      true if the current iteration is the last
\&    prev()      return the previous item in the list
\&    next()      return the next item in the list
.Ve
.PP
See Template::Iterator for further details.
.PP
Example:
.PP
.Vb 5
\&    [% FOREACH item IN [ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq ] \-%]
\&       [%\- "<ul>\en" IF loop.first %]
\&       <li>[% loop.count %]/[% loop.size %]: [% item %]
\&       [%\- "</ul>\en" IF loop.last %]
\&    [% END %]
.Ve
.PP
Output:
.PP
.Vb 5
\&    <ul>
\&    <li>1/3: foo
\&    <li>2/3: bar
\&    <li>3/3: baz
\&    </ul>
.Ve
.PP
Nested loops will work as expected, with the \f(CW\*(C`loop\*(C'\fR variable correctly
referencing the innermost loop and being restored to any previous
value (i.e. an outer loop) at the end of the loop.
.PP
.Vb 3
\&    [% FOREACH group IN grouplist;
\&         # loop => group iterator
\&         "Groups:\en" IF loop.first;
\&
\&         FOREACH user IN group.userlist;
\&            # loop => user iterator
\&            "$loop.count: $user.name\en";
\&         END;
\&
\&         # loop => group iterator
\&         "End of Groups\en" IF loop.last;
\&       END
\&    %]
.Ve
.PP
The \f(CW\*(C`iterator\*(C'\fR plugin can also be used to explicitly create an
iterator object.  This can be useful within nested loops where you
need to keep a reference to the outer iterator within the inner loop.
The iterator plugin effectively allows you to create an iterator by a
name other than \f(CW\*(C`loop\*(C'\fR.  See Template::Plugin::Iterator for further
details.
.PP
.Vb 1
\&    [% USE giter = iterator(grouplist) %]
\&
\&    [% FOREACH group IN giter %]
\&       [% FOREACH user IN group.userlist %]
\&             user #[% loop.count %] in
\&             group [% giter.count %] is
\&             named [% user.name %]
\&       [% END %]
\&    [% END %]
.Ve
.SS "\s-1WHILE\s0"
.IX Subsection "WHILE"
The \f(CW\*(C`WHILE\*(C'\fR directive can be used to repeatedly process a template block
while a conditional expression evaluates true.  The expression may
be arbitrarily complex as per \f(CW\*(C`IF\*(C'\fR / \f(CW\*(C`UNLESS\*(C'\fR.
.PP
.Vb 4
\&    [% WHILE total < 100 %]
\&       ...
\&       [% total = calculate_new_total %]
\&    [% END %]
.Ve
.PP
An assignment can be enclosed in parenthesis to evaluate the assigned
value.
.PP
.Vb 3
\&    [% WHILE (user = get_next_user_record) %]
\&       [% user.name %]
\&    [% END %]
.Ve
.PP
The \f(CW\*(C`NEXT\*(C'\fR directive can be used to start the next iteration of a
\&\f(CW\*(C`WHILE\*(C'\fR loop and \f(CW\*(C`BREAK\*(C'\fR can be used to exit the loop, both as per \f(CW\*(C`FOREACH\*(C'\fR.
.PP
The Template Toolkit uses a failsafe counter to prevent runaway \f(CW\*(C`WHILE\*(C'\fR
loops which would otherwise never terminate.  If the loop exceeds 1000
iterations then an \f(CW\*(C`undef\*(C'\fR exception will be thrown, reporting the
error:
.PP
.Vb 1
\&    WHILE loop terminated (> 1000 iterations)
.Ve
.PP
The \f(CW$Template::Directive::WHILE_MAX\fR variable controls this behaviour
and can be set to a higher value if necessary.
.SH "Filters, Plugins, Macros and Perl"
.IX Header "Filters, Plugins, Macros and Perl"
.SS "\s-1FILTER\s0"
.IX Subsection "FILTER"
The \f(CW\*(C`FILTER\*(C'\fR directive can be used to post-process the output of a
block.  A number of standard filters are provided with the Template
Toolkit.  The \f(CW\*(C`html\*(C'\fR filter, for example, escapes the '<', '>'
and '&' characters to prevent them from being interpreted as \s-1HTML\s0 tags
or entity reference markers.
.PP
.Vb 4
\&    [% FILTER html %]
\&       HTML text may have < and > characters embedded
\&       which you want converted to the correct HTML entities.
\&    [% END %]
.Ve
.PP
output:
.PP
.Vb 2
\&       HTML text may have &lt; and &gt; characters embedded
\&       which you want converted to the correct HTML entities.
.Ve
.PP
The \f(CW\*(C`FILTER\*(C'\fR directive can also follow various other non-block directives.
For example:
.PP
.Vb 1
\&    [% INCLUDE mytext FILTER html %]
.Ve
.PP
The \f(CW\*(C`|\*(C'\fR character can also be used as an alias for \f(CW\*(C`FILTER\*(C'\fR.
.PP
.Vb 1
\&    [% INCLUDE mytext | html %]
.Ve
.PP
Multiple filters can be chained together and will be called in sequence.
.PP
.Vb 1
\&    [% INCLUDE mytext FILTER html FILTER html_para %]
.Ve
.PP
or
.PP
.Vb 1
\&    [% INCLUDE mytext | html | html_para %]
.Ve
.PP
Filters come in two flavours, known as 'static' or 'dynamic'.  A
static filter is a simple subroutine which accepts a text string as
the only argument and returns the modified text.  The \f(CW\*(C`html\*(C'\fR filter is
an example of a static filter, implemented as:
.PP
.Vb 9
\&    sub html_filter {
\&        my $text = shift;
\&        for ($text) {
\&            s/&/&amp;/g;
\&            s/</&lt;/g;
\&            s/>/&gt;/g;
\&        }
\&        return $text;
\&    }
.Ve
.PP
Dynamic filters can accept arguments which are specified when the filter
is called from a template.  The \f(CW\*(C`repeat\*(C'\fR filter is such an example,
accepting a numerical argument which specifies the number of times
that the input text should be repeated.
.PP
.Vb 1
\&    [% FILTER repeat(3) %]blah [% END %]
.Ve
.PP
output:
.PP
.Vb 1
\&    blah blah blah
.Ve
.PP
These are implemented as filter 'factories'.  The factory subroutine
is passed a reference to the current Template::Context object along
with any additional arguments specified.  It should then return a
subroutine reference (e.g. a closure) which implements the filter.
The \f(CW\*(C`repeat\*(C'\fR filter factory is implemented like this:
.PP
.Vb 3
\&    sub repeat_filter_factory {
\&        my ($context, $iter) = @_;
\&        $iter = 1 unless defined $iter;
\&
\&        return sub {
\&            my $text = shift;
\&            $text = \*(Aq\*(Aq unless defined $text;
\&            return join(\*(Aq\en\*(Aq, $text) x $iter;
\&        }
\&    }
.Ve
.PP
The \f(CW\*(C`FILTERS\*(C'\fR option, described in Template::Manual::Config, allows custom
filters to be defined when a Template object is instantiated. The
\&\fBdefine_filter()\fR method allows further
filters to be defined at any time.
.PP
When using a filter, it is possible to assign an alias to it for
further use.  This is most useful for dynamic filters that you want
to re-use with the same configuration.
.PP
.Vb 3
\&    [% FILTER echo = repeat(2) %]
\&    Is there anybody out there?
\&    [% END %]
\&
\&    [% FILTER echo %]
\&    Mother, should I build a wall?
\&    [% END %]
.Ve
.PP
Output:
.PP
.Vb 2
\&    Is there anybody out there?
\&    Is there anybody out there?
\&
\&    Mother, should I build a wall?
\&    Mother, should I build a wall?
.Ve
.PP
The \f(CW\*(C`FILTER\*(C'\fR directive automatically quotes the name of the filter.  As
with \f(CW\*(C`INCLUDE\*(C'\fR et al, you can use a variable to provide the name of the
filter, prefixed by \f(CW\*(C`$\*(C'\fR.
.PP
.Vb 4
\&    [% myfilter = \*(Aqhtml\*(Aq %]
\&    [% FILTER $myfilter %]      # same as [% FILTER html %]
\&       ...
\&    [% END %]
.Ve
.PP
A template variable can also be used to define a static filter
subroutine.  However, the Template Toolkit will automatically call any
subroutine bound to a variable and use the value returned.  Thus, the
above example could be implemented as:
.PP
.Vb 3
\&    my $vars = {
\&        myfilter => sub { return \*(Aqhtml\*(Aq },
\&    };
.Ve
.PP
template:
.PP
.Vb 3
\&    [% FILTER $myfilter %]      # same as [% FILTER html %]
\&       ...
\&    [% END %]
.Ve
.PP
To define a template variable that evaluates to a subroutine reference
that can be used by the \f(CW\*(C`FILTER\*(C'\fR directive, you should create a
subroutine that, when called automatically by the Template Toolkit,
returns another subroutine reference which can then be used to perform
the filter operation.  Note that only static filters can be
implemented in this way.
.PP
.Vb 3
\&    my $vars = {
\&        myfilter => sub { \e&my_filter_sub },
\&    };
\&
\&    sub my_filter_sub {
\&        my $text = shift;
\&        # do something
\&        return $text;
\&    }
.Ve
.PP
template:
.PP
.Vb 3
\&    [% FILTER $myfilter %]
\&       ...
\&    [% END %]
.Ve
.PP
Alternately, you can bless a subroutine reference into a class (any
class will do) to fool the Template Toolkit into thinking it's an
object rather than a subroutine.  This will then bypass the automatic
\&\*(L"call-a-subroutine-to-return-a-value\*(R" magic.
.PP
.Vb 3
\&    my $vars = {
\&        myfilter => bless(\e&my_filter_sub, \*(Aqanything_you_like\*(Aq),
\&    };
.Ve
.PP
template:
.PP
.Vb 3
\&    [% FILTER $myfilter %]
\&       ...
\&    [% END %]
.Ve
.PP
Filters bound to template variables remain local to the variable context in
which they are defined. That is, if you define a filter in a \f(CW\*(C`PERL\*(C'\fR block
within a template that is loaded via \f(CW\*(C`INCLUDE\*(C'\fR, then the filter definition
will only exist until the end of that template when the stash is delocalised,
restoring the previous variable state. If you want to define a filter which
persists for the lifetime of the processor, or define additional dynamic
filter factories, then you can call the
\&\fBdefine_filter()\fR method on the current
Template::Context object.
.PP
See Template::Manual::Filters for a complete list of available filters,
their descriptions and examples of use.
.SS "\s-1USE\s0"
.IX Subsection "USE"
The \f(CW\*(C`USE\*(C'\fR directive can be used to load and initialise \*(L"plugin\*(R"
extension modules.
.PP
.Vb 1
\&    [% USE myplugin %]
.Ve
.PP
A plugin is a regular Perl module that conforms to a particular
object-oriented interface, allowing it to be loaded into and used
automatically by the Template Toolkit.  For details of this interface
and information on writing plugins, consult Template::Plugin.
.PP
A number of standard plugins are included with the Template Toolkit
(see below and Template::Manual::Plugins).  The names of these
standard plugins are case insensitive.
.PP
.Vb 3
\&    [% USE CGI   %]        # => Template::Plugin::CGI
\&    [% USE Cgi   %]        # => Template::Plugin::CGI
\&    [% USE cgi   %]        # => Template::Plugin::CGI
.Ve
.PP
You can also define further plugins using the \f(CW\*(C`PLUGINS\*(C'\fR option.
.PP
.Vb 6
\&    my $tt = Template\->new({
\&        PLUGINS => {
\&            foo => \*(AqMy::Plugin::Foo\*(Aq,
\&            bar => \*(AqMy::Plugin::Bar\*(Aq,
\&        },
\&    });
.Ve
.PP
The recommended convention is to specify these plugin names in lower
case.  The Template Toolkit first looks for an exact case-sensitive
match and then tries the lower case conversion of the name specified.
.PP
.Vb 1
\&    [% USE Foo %]      # look for \*(AqFoo\*(Aq then \*(Aqfoo\*(Aq
.Ve
.PP
If you define all your \f(CW\*(C`PLUGINS\*(C'\fR with lower case names then they will be
located regardless of how the user specifies the name in the \f(CW\*(C`USE\*(C'\fR
directive.  If, on the other hand, you define your \f(CW\*(C`PLUGINS\*(C'\fR with upper
or mixed case names then the name specified in the \f(CW\*(C`USE\*(C'\fR directive must
match the case exactly.
.PP
If the plugin isn't defined in either the standard plugins
(\f(CW$Template::Plugins::STD_PLUGINS\fR) or via the \f(CW\*(C`PLUGINS\*(C'\fR option, then
the \f(CW\*(C`PLUGIN_BASE\*(C'\fR is searched.
.PP
In this case the plugin name \fIis\fR case-sensitive.  It is appended to
each of the \f(CW\*(C`PLUGIN_BASE\*(C'\fR module namespaces in turn (default:
\&\f(CW\*(C`Template::Plugin\*(C'\fR) to construct a full module name which it attempts
to locate and load.  Any periods, '\f(CW\*(C`.\*(C'\fR', in the name will be converted
to '\f(CW\*(C`::\*(C'\fR'.
.PP
.Vb 2
\&    [% USE MyPlugin %]     #  => Template::Plugin::MyPlugin
\&    [% USE Foo.Bar  %]     #  => Template::Plugin::Foo::Bar
.Ve
.PP
The \f(CW\*(C`LOAD_PERL\*(C'\fR option (disabled by default) provides a further way by
which external Perl modules may be loaded.  If a regular Perl module
(i.e. not a \f(CW\*(C`Template::Plugin::*\*(C'\fR or other module relative to some
\&\f(CW\*(C`PLUGIN_BASE\*(C'\fR) supports an object-oriented interface and a \f(CW\*(C`new()\*(C'\fR
constructor then it can be loaded and instantiated automatically.  The
following trivial example shows how the IO::File module might be used.
.PP
.Vb 1
\&    [% USE file = IO.File(\*(Aq/tmp/mydata\*(Aq) %]
\&
\&    [% WHILE (line = file.getline) %]
\&       <!\-\- [% line %] \-\->
\&    [% END %]
.Ve
.PP
Any additional parameters supplied in parenthesis after the plugin
name will be also be passed to the \f(CW\*(C`new()\*(C'\fR constructor.  A reference to
the current Template::Context object is passed as the first
parameter.
.PP
.Vb 1
\&    [% USE MyPlugin(\*(Aqfoo\*(Aq, 123) %]
.Ve
.PP
equivalent to:
.PP
.Vb 1
\&    Template::Plugin::MyPlugin\->new($context, \*(Aqfoo\*(Aq, 123);
.Ve
.PP
The only exception to this is when a module is loaded via the
\&\f(CW\*(C`LOAD_PERL\*(C'\fR option.  In this case the \f(CW$context\fR reference is \fInot\fR
passed to the \f(CW\*(C`new()\*(C'\fR constructor.  This is based on the assumption that
the module is a regular Perl module rather than a Template Toolkit
plugin so isn't expecting a context reference and wouldn't know what
to do with it anyway.
.PP
Named parameters may also be specified.  These are collated into a
hash which is passed by reference as the last parameter to the
constructor, as per the general code calling interface.
.PP
.Vb 1
\&    [% USE url(\*(Aq/cgi\-bin/foo\*(Aq, mode=\*(Aqsubmit\*(Aq, debug=1) %]
.Ve
.PP
equivalent to:
.PP
.Vb 5
\&    Template::Plugin::URL\->new(
\&        $context,
\&        \*(Aq/cgi\-bin/foo\*(Aq
\&        { mode => \*(Aqsubmit\*(Aq, debug => 1 }
\&    );
.Ve
.PP
The plugin may represent any data type; a simple variable, hash, list or
code reference, but in the general case it will be an object reference.
Methods can be called on the object (or the relevant members of the
specific data type) in the usual way:
.PP
.Vb 1
\&    [% USE table(mydata, rows=3) %]
\&
\&    [% FOREACH row IN table.rows %]
\&       <tr>
\&       [% FOREACH item IN row %]
\&        <td>[% item %]</td>
\&       [% END %]
\&       </tr>
\&    [% END %]
.Ve
.PP
An alternative name may be provided for the plugin by which it can be
referenced:
.PP
.Vb 1
\&    [% USE scores = table(myscores, cols=5) %]
\&
\&    [% FOREACH row IN scores.rows %]
\&       ...
\&    [% END %]
.Ve
.PP
You can use this approach to create multiple plugin objects with
different configurations.  This example shows how the
format plugin is used to create
sub-routines bound to variables for formatting text as per \f(CW\*(C`printf()\*(C'\fR.
.PP
.Vb 4
\&    [% USE bold = format(\*(Aq<b>%s</b>\*(Aq) %]
\&    [% USE ital = format(\*(Aq<i>%s</i>\*(Aq) %]
\&    [% bold(\*(AqThis is bold\*(Aq)   %]
\&    [% ital(\*(AqThis is italic\*(Aq) %]
.Ve
.PP
Output:
.PP
.Vb 2
\&    <b>This is bold</b>
\&    <i>This is italic</i>
.Ve
.PP
This next example shows how the \s-1URL\s0 plugin can be
used to build dynamic URLs from a base part and optional query parameters.
.PP
.Vb 3
\&    [% USE mycgi = URL(\*(Aq/cgi\-bin/foo.pl\*(Aq, debug=1) %]
\&    <a href="[% mycgi %]">...
\&    <a href="[% mycgi(mode=\*(Aqsubmit\*(Aq) %]"...
.Ve
.PP
Output:
.PP
.Vb 2
\&    <a href="/cgi\-bin/foo.pl?debug=1">...
\&    <a href="/cgi\-bin/foo.pl?mode=submit&debug=1">...
.Ve
.PP
The \s-1CGI\s0 plugin is an example of one which delegates
to another Perl module. In this case, to Lincoln Stein's \f(CW\*(C`CGI\*(C'\fR module.
All of the methods provided by the \f(CW\*(C`CGI\*(C'\fR module are available via the plugin.
.PP
.Vb 8
\&    [% USE CGI;
\&       CGI.start_form;
\&       CGI.checkbox_group( name   = \*(Aqcolours\*(Aq,
\&                           values = [ \*(Aqred\*(Aq \*(Aqgreen\*(Aq \*(Aqblue\*(Aq ] );
\&       CGI.popup_menu( name   = \*(Aqitems\*(Aq,
\&                       values = [ \*(Aqfoo\*(Aq \*(Aqbar\*(Aq \*(Aqbaz\*(Aq ] );
\&       CGI.end_form
\&    %]
.Ve
.PP
See Template::Manual::Plugins for more information on the plugins
distributed with the toolkit or available from \s-1CPAN.\s0
.SS "\s-1MACRO\s0"
.IX Subsection "MACRO"
The \f(CW\*(C`MACRO\*(C'\fR directive allows you to define a directive or directive block
which is then evaluated each time the macro is called.
.PP
.Vb 1
\&    [% MACRO header INCLUDE header %]
.Ve
.PP
Calling the macro as:
.PP
.Vb 1
\&    [% header %]
.Ve
.PP
is then equivalent to:
.PP
.Vb 1
\&    [% INCLUDE header %]
.Ve
.PP
Macros can be passed named parameters when called.  These values remain
local to the macro.
.PP
.Vb 1
\&    [% header(title=\*(AqHello World\*(Aq) %]
.Ve
.PP
equivalent to:
.PP
.Vb 1
\&    [% INCLUDE header title=\*(AqHello World\*(Aq %]
.Ve
.PP
A \f(CW\*(C`MACRO\*(C'\fR definition may include parameter names.  Values passed to the
macros are then mapped to these local variables.  Other named parameters
may follow these.
.PP
.Vb 3
\&    [% MACRO header(title) INCLUDE header %]
\&    [% header(\*(AqHello World\*(Aq) %]
\&    [% header(\*(AqHello World\*(Aq, bgcol=\*(Aq#123456\*(Aq) %]
.Ve
.PP
equivalent to:
.PP
.Vb 2
\&    [% INCLUDE header title=\*(AqHello World\*(Aq %]
\&    [% INCLUDE header title=\*(AqHello World\*(Aq bgcol=\*(Aq#123456\*(Aq %]
.Ve
.PP
Here's another example, defining a macro for display numbers
in comma-delimited groups of 3, using the chunk and join virtual
method.
.PP
.Vb 2
\&    [% MACRO number(n) GET n.chunk(\-3).join(\*(Aq,\*(Aq) %]
\&    [% number(1234567) %]    # 1,234,567
.Ve
.PP
A \f(CW\*(C`MACRO\*(C'\fR may precede any directive and must conform to the structure
of the directive.
.PP
.Vb 5
\&    [% MACRO header IF frames %]
\&       [% INCLUDE frames/header %]
\&    [% ELSE %]
\&       [% INCLUDE header %]
\&    [% END %]
\&
\&    [% header %]
.Ve
.PP
A \f(CW\*(C`MACRO\*(C'\fR may also be defined as an anonymous \f(CW\*(C`BLOCK\*(C'\fR.  The block will be
evaluated each time the macro is called.
.PP
.Vb 3
\&    [% MACRO header BLOCK %]
\&       ...content...
\&    [% END %]
\&
\&    [% header %]
.Ve
.PP
If you've got the \f(CW\*(C`EVAL_PERL\*(C'\fR option set, then you can even define a
\&\f(CW\*(C`MACRO\*(C'\fR as a \f(CW\*(C`PERL\*(C'\fR block (see below):
.PP
.Vb 4
\&    [% MACRO triple(n) PERL %]
\&         my $n = $stash\->get(\*(Aqn\*(Aq);
\&         print $n * 3;
\&    [% END \-%]
.Ve
.SS "\s-1PERL\s0"
.IX Subsection "PERL"
(for the advanced reader)
.PP
The \f(CW\*(C`PERL\*(C'\fR directive is used to mark the start of a block which contains
Perl code for evaluation.  The \f(CW\*(C`EVAL_PERL\*(C'\fR option must be enabled for Perl
code to be evaluated or a \f(CW\*(C`perl\*(C'\fR exception will be thrown with the
message '\f(CW\*(C`EVAL_PERL not set\*(C'\fR'.
.PP
Perl code is evaluated in the \f(CW\*(C`Template::Perl\*(C'\fR package.  The \f(CW$context\fR
package variable contains a reference to the current Template::Context
object.  This can be used to access the functionality of the Template
Toolkit to process other templates, load plugins, filters, etc.
See Template::Context for further details.
.PP
.Vb 3
\&    [% PERL %]
\&       print $context\->include(\*(Aqmyfile\*(Aq);
\&    [% END %]
.Ve
.PP
The \f(CW$stash\fR variable contains a reference to the top-level stash object
which manages template variables.  Through this, variable values can
be retrieved and updated.  See Template::Stash for further details.
.PP
.Vb 4
\&    [% PERL %]
\&       $stash\->set(foo => \*(Aqbar\*(Aq);
\&       print "foo value: ", $stash\->get(\*(Aqfoo\*(Aq);
\&    [% END %]
.Ve
.PP
Output:
.PP
.Vb 1
\&    foo value: bar
.Ve
.PP
Output is generated from the \f(CW\*(C`PERL\*(C'\fR block by calling \f(CW\*(C`print()\*(C'\fR.  Note that
the \f(CW\*(C`Template::Perl::PERLOUT\*(C'\fR handle is selected (tied to an output
buffer) instead of \f(CW\*(C`STDOUT\*(C'\fR.
.PP
.Vb 6
\&    [% PERL %]
\&       print "foo\en";                           # OK
\&       print PERLOUT "bar\en";                   # OK, same as above
\&       print Template::Perl::PERLOUT "baz\en";   # OK, same as above
\&       print STDOUT "qux\en";                    # WRONG!
\&    [% END %]
.Ve
.PP
The \f(CW\*(C`PERL\*(C'\fR block may contain other template directives.  These are
processed before the Perl code is evaluated.
.PP
.Vb 1
\&    [% name = \*(AqFred Smith\*(Aq %]
\&
\&    [% PERL %]
\&       print "[% name %]\en";
\&    [% END %]
.Ve
.PP
Thus, the Perl code in the above example is evaluated as:
.PP
.Vb 1
\&    print "Fred Smith\en";
.Ve
.PP
Exceptions may be thrown from within \f(CW\*(C`PERL\*(C'\fR blocks using \f(CW\*(C`die()\*(C'\fR.
They will be correctly caught by enclosing \f(CW\*(C`TRY\*(C'\fR blocks.
.PP
.Vb 7
\&    [% TRY %]
\&       [% PERL %]
\&          die "nothing to live for\en";
\&       [% END %]
\&    [% CATCH %]
\&       error: [% error.info %]
\&    [% END %]
.Ve
.PP
output:
       error: nothing to live for
.SS "\s-1RAWPERL\s0"
.IX Subsection "RAWPERL"
(for the very advanced reader)
.PP
The Template Toolkit parser reads a source template and generates the
text of a Perl subroutine as output.  It then uses \f(CW\*(C`eval()\*(C'\fR to evaluate
it into a subroutine reference.  This subroutine is then called to
process the template, passing a reference to the current
Template::Context object through which the functionality of the
Template Toolkit can be accessed.  The subroutine reference can be
cached, allowing the template to be processed repeatedly without
requiring any further parsing.
.PP
For example, a template such as:
.PP
.Vb 3
\&    [% PROCESS header %]
\&    The [% animal %] sat on the [% location %]
\&    [% PROCESS footer %]
.Ve
.PP
is converted into the following Perl subroutine definition:
.PP
.Vb 5
\&    sub {
\&        my $context = shift;
\&        my $stash   = $context\->stash;
\&        my $output  = \*(Aq\*(Aq;
\&        my $error;
\&
\&        eval { BLOCK: {
\&            $output .=  $context\->process(\*(Aqheader\*(Aq);
\&            $output .=  "The ";
\&            $output .=  $stash\->get(\*(Aqanimal\*(Aq);
\&            $output .=  " sat on the ";
\&            $output .=  $stash\->get(\*(Aqlocation\*(Aq);
\&            $output .=  $context\->process(\*(Aqfooter\*(Aq);
\&            $output .=  "\en";
\&        } };
\&        if ($@) {
\&            $error = $context\->catch($@, \e$output);
\&            die $error unless $error\->type eq \*(Aqreturn\*(Aq;
\&        }
\&
\&        return $output;
\&    }
.Ve
.PP
To examine the Perl code generated, such as in the above example, set
the \f(CW$Template::Parser::DEBUG\fR package variable to any true value.  You
can also set the \f(CW$Template::Directive::PRETTY\fR variable true to have
the code formatted in a readable manner for human consumption.  The
source code for each generated template subroutine will be printed to
\&\f(CW\*(C`STDERR\*(C'\fR on compilation (i.e. the first time a template is used).
.PP
.Vb 2
\&    $Template::Parser::DEBUG = 1;
\&    $Template::Directive::PRETTY = 1;
\&
\&    $template\->process($file, $vars)
\&        || die $template\->error(), "\en";
.Ve
.PP
The \f(CW\*(C`PERL\*(C'\fR ... \f(CW\*(C`END\*(C'\fR construct allows Perl code to be embedded into a
template when the \f(CW\*(C`EVAL_PERL\*(C'\fR option is set.  It is evaluated at
\&\*(L"runtime\*(R" using \f(CW\*(C`eval()\*(C'\fR each time the template subroutine is called.
This is inherently flexible, but not as efficient as it could be,
especially in a persistent server environment where a template may be
processed many times.
.PP
The \f(CW\*(C`RAWPERL\*(C'\fR directive allows you to write Perl code that is integrated
directly into the generated Perl subroutine text.  It is evaluated
once at compile time and is stored in cached form as part of the
compiled template subroutine.  This makes \f(CW\*(C`RAWPERL\*(C'\fR blocks more
efficient than \f(CW\*(C`PERL\*(C'\fR blocks.
.PP
The downside is that you must code much closer to the metal. For example, in a
\&\f(CW\*(C`PERL\*(C'\fR block you can call \fBprint()\fR to generate some output. \f(CW\*(C`RAWPERL\*(C'\fR
blocks don't afford such luxury. The code is inserted directly into the
generated subroutine text and should conform to the convention of appending to
the \f(CW$output\fR variable.
.PP
.Vb 1
\&    [% PROCESS  header %]
\&
\&    [% RAWPERL %]
\&       $output .= "Some output\en";
\&       ...
\&       $output .= "Some more output\en";
\&    [% END %]
.Ve
.PP
The critical section of the generated subroutine for this example would
then look something like:
.PP
.Vb 10
\&    ...
\&    eval { BLOCK: {
\&        $output .=  $context\->process(\*(Aqheader\*(Aq);
\&        $output .=  "\en";
\&        $output .= "Some output\en";
\&        ...
\&        $output .= "Some more output\en";
\&        $output .=  "\en";
\&    } };
\&    ...
.Ve
.PP
As with \f(CW\*(C`PERL\*(C'\fR blocks, the \f(CW$context\fR and
\&\f(CW$stash\fR references are pre-defined and available for use
within \f(CW\*(C`RAWPERL\*(C'\fR code.
.SH "Exception Handling and Flow Control"
.IX Header "Exception Handling and Flow Control"
.SS "\s-1TRY / THROW / CATCH / FINAL\s0"
.IX Subsection "TRY / THROW / CATCH / FINAL"
(more advanced material)
.PP
The Template Toolkit supports fully functional, nested exception
handling.  The \f(CW\*(C`TRY\*(C'\fR directive introduces an exception handling scope
which continues until the matching \f(CW\*(C`END\*(C'\fR directive.  Any errors that
occur within that block will be caught and can be handled by one
of the \f(CW\*(C`CATCH\*(C'\fR blocks defined.
.PP
.Vb 9
\&    [% TRY %]
\&       ...blah...blah...
\&       [% CALL somecode %]
\&       ...etc...
\&       [% INCLUDE someblock %]
\&       ...and so on...
\&    [% CATCH %]
\&       An error occurred!
\&    [% END %]
.Ve
.PP
Errors are raised as exceptions (objects of the Template::Exception class)
which contain two fields: \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`info\*(C'\fR. The exception \f(CW\*(C`type\*(C'\fR is used
to indicate the kind of error that occurred. It is a simple text string which
can contain letters, numbers, '\f(CW\*(C`_\*(C'\fR' or '\f(CW\*(C`.\*(C'\fR'. The \f(CW\*(C`info\*(C'\fR field contains an
error message indicating what actually went wrong. Within a catch block, the
exception object is aliased to the \f(CW\*(C`error\*(C'\fR variable. You can access the \f(CW\*(C`type\*(C'\fR
and \f(CW\*(C`info\*(C'\fR fields directly.
.PP
.Vb 2
\&    [% mydsn = \*(Aqdbi:MySQL:foobar\*(Aq %]
\&    ...
\&
\&    [% TRY %]
\&       [% USE DBI(mydsn) %]
\&    [% CATCH %]
\&       ERROR! Type: [% error.type %]
\&              Info: [% error.info %]
\&    [% END %]
.Ve
.PP
output (assuming a non-existent database called '\f(CW\*(C`foobar\*(C'\fR'):
.PP
.Vb 2
\&    ERROR!  Type: DBI
\&            Info: Unknown database "foobar"
.Ve
.PP
The \f(CW\*(C`error\*(C'\fR variable can also be specified by itself and will return a
string of the form "\f(CW\*(C`$type error \- $info\*(C'\fR".
.PP
.Vb 4
\&    ...
\&    [% CATCH %]
\&    ERROR: [% error %]
\&    [% END %]
.Ve
.PP
Output:
.PP
.Vb 1
\&    ERROR: DBI error \- Unknown database "foobar"
.Ve
.PP
Each \f(CW\*(C`CATCH\*(C'\fR block may be specified with a particular exception type
denoting the kind of error that it should catch.  Multiple \f(CW\*(C`CATCH\*(C'\fR
blocks can be provided to handle different types of exception that may
be thrown in the \f(CW\*(C`TRY\*(C'\fR block.  A \f(CW\*(C`CATCH\*(C'\fR block specified without any type,
as in the previous example, is a default handler which will catch any
otherwise uncaught exceptions.  This can also be specified as
\&\f(CW\*(C`[% CATCH DEFAULT %]\*(C'\fR.
.PP
.Vb 11
\&    [% TRY %]
\&       [% INCLUDE myfile %]
\&       [% USE DBI(mydsn) %]
\&       [% CALL somecode %]
\&    [% CATCH file %]
\&       File Error! [% error.info %]
\&    [% CATCH DBI %]
\&       [% INCLUDE database/error.html %]
\&    [% CATCH %]
\&       [% error %]
\&    [% END %]
.Ve
.PP
Remember that you can specify multiple directives within a single tag,
each delimited by '\f(CW\*(C`;\*(C'\fR'.  So the above example can be written more
concisely as:
.PP
.Vb 12
\&    [% TRY;
\&           INCLUDE myfile;
\&           USE DBI(mydsn);
\&           CALL somecode;
\&       CATCH file;
\&           "File Error! $error.info";
\&       CATCH DBI;
\&           INCLUDE database/error.html;
\&       CATCH;
\&           error;
\&       END
\&    %]
.Ve
.PP
The \f(CW\*(C`DBI\*(C'\fR plugin throws exceptions of the \f(CW\*(C`DBI\*(C'\fR type (in case that
wasn't already obvious).  The other specific exception caught here is
of the \f(CW\*(C`file\*(C'\fR type.
.PP
A \f(CW\*(C`file\*(C'\fR exception is automatically thrown by the Template Toolkit when it
can't find a file, or fails to load, parse or process a file that has been
requested by an \f(CW\*(C`INCLUDE\*(C'\fR, \f(CW\*(C`PROCESS\*(C'\fR, \f(CW\*(C`INSERT\*(C'\fR or \f(CW\*(C`WRAPPER\*(C'\fR directive.
If \f(CW\*(C`myfile\*(C'\fR can't be found in the example above, the \f(CW\*(C`[% INCLUDE myfile %]\*(C'\fR
directive will raise a \f(CW\*(C`file\*(C'\fR exception which is then caught by the
\&\f(CW\*(C`[% CATCH file %]\*(C'\fR block.  The output generated would be:
.PP
.Vb 1
\&    File Error! myfile: not found
.Ve
.PP
Note that the \f(CW\*(C`DEFAULT\*(C'\fR option (disabled by default) allows you to specify a
default file to be used any time a template file can't be found. This will
prevent file exceptions from ever being raised when a non-existent file is
requested (unless, of course, the \f(CW\*(C`DEFAULT\*(C'\fR file your specify doesn't exist).
Errors encountered once the file has been found (i.e. read error, parse error)
will be raised as file exceptions as per usual.
.PP
Uncaught exceptions (i.e. if the \f(CW\*(C`TRY\*(C'\fR block doesn't have a type specific or
default \f(CW\*(C`CATCH\*(C'\fR handler) may be caught by enclosing \f(CW\*(C`TRY\*(C'\fR blocks which can
be nested indefinitely across multiple templates. If the error isn't caught at
any level then processing will stop and the Template
\&\fBprocess()\fR method will return a false value to the
caller. The relevant Template::Exception object can be retrieved by calling
the \fBerror()\fR method.
.PP
.Vb 11
\&    [% TRY %]
\&       ...
\&       [% TRY %]
\&          [% INCLUDE $user.header %]
\&       [% CATCH file %]
\&          [% INCLUDE header %]
\&       [% END %]
\&       ...
\&    [% CATCH DBI %]
\&       [% INCLUDE database/error.html %]
\&    [% END %]
.Ve
.PP
In this example, the inner \f(CW\*(C`TRY\*(C'\fR block is used to ensure that the first
\&\f(CW\*(C`INCLUDE\*(C'\fR directive works as expected.  We're using a variable to
provide the name of the template we want to include, \f(CW\*(C`user.header\*(C'\fR, and
it's possible this contains the name of a non-existent template, or
perhaps one containing invalid template directives.  If the \f(CW\*(C`INCLUDE\*(C'\fR fails
with a \f(CW\*(C`file\*(C'\fR error then we \f(CW\*(C`CATCH\*(C'\fR it in the inner block and \f(CW\*(C`INCLUDE\*(C'\fR
the default \f(CW\*(C`header\*(C'\fR file instead.  Any \f(CW\*(C`DBI\*(C'\fR errors that occur within
the scope of the outer \f(CW\*(C`TRY\*(C'\fR block will be caught in the relevant \f(CW\*(C`CATCH\*(C'\fR
block, causing the \f(CW\*(C`database/error.html\*(C'\fR template to be processed.
Note that included templates inherit all currently defined template
variable so these error files can quite happily access the <error>
variable to retrieve information about the currently caught exception.
For example, the \f(CW\*(C`database/error.html\*(C'\fR template might look like this:
.PP
.Vb 2
\&    <h2>Database Error</h2>
\&    A database error has occurred: [% error.info %]
.Ve
.PP
You can also specify a \f(CW\*(C`FINAL\*(C'\fR block.  This is always processed
regardless of the outcome of the \f(CW\*(C`TRY\*(C'\fR and/or \f(CW\*(C`CATCH\*(C'\fR blocks.  If an
exception is uncaught then the \f(CW\*(C`FINAL\*(C'\fR block is processed before jumping
to the enclosing block or returning to the caller.
.PP
.Vb 9
\&    [% TRY %]
\&       ...
\&    [% CATCH this %]
\&       ...
\&    [% CATCH that %]
\&       ...
\&    [% FINAL %]
\&       All done!
\&    [% END %]
.Ve
.PP
The output from the \f(CW\*(C`TRY\*(C'\fR block is left intact up to the point where an
exception occurs.  For example, this template:
.PP
.Vb 7
\&    [% TRY %]
\&       This gets printed
\&       [% THROW food \*(Aqcarrots\*(Aq %]
\&       This doesn\*(Aqt
\&    [% CATCH food %]
\&       culinary delights: [% error.info %]
\&    [% END %]
.Ve
.PP
generates the following output:
.PP
.Vb 2
\&    This gets printed
\&    culinary delights: carrots
.Ve
.PP
The \f(CW\*(C`CLEAR\*(C'\fR directive can be used in a \f(CW\*(C`CATCH\*(C'\fR or \f(CW\*(C`FINAL\*(C'\fR block to clear
any output created in the \f(CW\*(C`TRY\*(C'\fR block.
.PP
.Vb 8
\&    [% TRY %]
\&       This gets printed
\&       [% THROW food \*(Aqcarrots\*(Aq %]
\&       This doesn\*(Aqt
\&    [% CATCH food %]
\&       [% CLEAR %]
\&       culinary delights: [% error.info %]
\&    [% END %]
.Ve
.PP
Output:
.PP
.Vb 1
\&    culinary delights: carrots
.Ve
.PP
Exception types are hierarchical, with each level being separated by
the familiar dot operator.  A \f(CW\*(C`DBI.connect\*(C'\fR exception is a more
specific kind of \f(CW\*(C`DBI\*(C'\fR error.  Similarly, an \f(CW\*(C`example.error.barf\*(C'\fR is a
more specific kind of \f(CW\*(C`example.error\*(C'\fR type which itself is also a
\&\f(CW\*(C`example\*(C'\fR error.
.PP
A \f(CW\*(C`CATCH\*(C'\fR handler that specifies a general exception
type (such as \f(CW\*(C`DBI\*(C'\fR or \f(CW\*(C`example.error\*(C'\fR) will also catch more specific
types that have the same prefix as long as a more specific handler
isn't defined.  Note that the order in which \f(CW\*(C`CATCH\*(C'\fR handlers are
defined is irrelevant; a more specific handler will always catch an
exception in preference to a more generic or default one.
.PP
.Vb 10
\&    [% TRY %]
\&       ...
\&    [% CATCH DBI ;
\&         INCLUDE database/error.html ;
\&       CATCH DBI.connect ;
\&         INCLUDE database/connect.html ;
\&       CATCH ;
\&         INCLUDE error.html ;
\&       END
\&    %]
.Ve
.PP
In this example, a \f(CW\*(C`DBI.connect\*(C'\fR error has it's own handler, a more general
\&\f(CW\*(C`DBI\*(C'\fR block is used for all other \f(CW\*(C`DBI\*(C'\fR or \f(CW\*(C`DBI.*\*(C'\fR errors and a default
handler catches everything else.
.PP
Exceptions can be raised in a template using the \f(CW\*(C`THROW\*(C'\fR directive.  The
first parameter is the exception type which doesn't need to be quoted
(but can be, it's the same as \f(CW\*(C`INCLUDE\*(C'\fR) followed by the relevant error
message which can be any regular value such as a quoted string,
variable, etc.
.PP
.Vb 3
\&    [% THROW food "Missing ingredients: $recipe.error" %]
\&    [% THROW user.login \*(Aqno user id: please login\*(Aq %]
\&    [% THROW $myerror.type "My Error: $myerror.info" %]
.Ve
.PP
It's also possible to specify additional positional or named
parameters to the \f(CW\*(C`THROW\*(C'\fR directive if you want to pass more than
just a simple message back as the error info field.
.PP
.Vb 1
\&    [% THROW food \*(Aqeggs\*(Aq \*(Aqflour\*(Aq msg=\*(AqMissing Ingredients\*(Aq %]
.Ve
.PP
In this case, the error \f(CW\*(C`info\*(C'\fR field will be a hash array containing the
named arguments and an \f(CW\*(C`args\*(C'\fR item which contains a list of the positional
arguments.
.PP
.Vb 5
\&    type => \*(Aqfood\*(Aq,
\&    info => {
\&        msg  => \*(AqMissing Ingredients\*(Aq,
\&        args => [\*(Aqeggs\*(Aq, \*(Aqflour\*(Aq],
\&    }
.Ve
.PP
In addition to specifying individual positional arguments as
\&\f(CW\*(C`[% error.info.args.n %]\*(C'\fR, the \f(CW\*(C`info\*(C'\fR hash contains keys directly
pointing to the positional arguments, as a convenient shortcut.
.PP
.Vb 1
\&    [% error.info.0 %]   # same as [% error.info.args.0 %]
.Ve
.PP
Exceptions can also be thrown from Perl code which you've bound to
template variables, or defined as a plugin or other extension.  To
raise an exception, call \f(CW\*(C`die()\*(C'\fR passing a reference to a
Template::Exception object as the argument.  This will then be caught
by any enclosing \f(CW\*(C`TRY\*(C'\fR blocks from where the code was called.
.PP
.Vb 9
\&    use Template::Exception;
\&    ...
\&    my $vars = {
\&        foo => sub {
\&            # ... do something ...
\&            die Template::Exception\->new(\*(Aqmyerr.naughty\*(Aq,
\&                                         \*(AqBad, bad error\*(Aq);
\&        },
\&    };
.Ve
.PP
Template:
.PP
.Vb 6
\&    [% TRY %]
\&       [% foo %]
\&    [% CATCH myerr ;
\&         "Error: $error" ;
\&       END
\&    %]
.Ve
.PP
Output:
.PP
.Vb 1
\&    Error: myerr.naughty error \- Bad, bad error
.Ve
.PP
The \f(CW\*(C`info\*(C'\fR field can also be a reference to another object or data
structure, if required.
.PP
.Vb 4
\&    die Template::Exception\->new(\*(Aqmyerror\*(Aq, {
\&        module => \*(Aqfoo.pl\*(Aq,
\&        errors => [ \*(Aqbad permissions\*(Aq, \*(Aqnaughty boy\*(Aq ],
\&    });
.Ve
.PP
Later, in a template:
.PP
.Vb 8
\&    [% TRY %]
\&       ...
\&    [% CATCH myerror %]
\&       [% error.info.errors.size or \*(Aqno\*(Aq;
\&          error.info.errors.size == 1 ? \*(Aq error\*(Aq : \*(Aq errors\*(Aq %]
\&       in [% error.info.module %]:
\&          [% error.info.errors.join(\*(Aq, \*(Aq) %].
\&    [% END %]
.Ve
.PP
Generating the output:
.PP
.Vb 2
\&       2 errors in foo.pl:
\&          bad permissions, naughty boy.
.Ve
.PP
You can also call \f(CW\*(C`die()\*(C'\fR with a single string, as is common in much
existing Perl code.  This will automatically be converted to an
exception of the '\f(CW\*(C`undef\*(C'\fR' type (that's the literal string '\f(CW\*(C`undef\*(C'\fR',
not the undefined value).  If the string isn't terminated with a
newline then Perl will append the familiar \f(CW" at $file line $line"\fR
message.
.PP
.Vb 4
\&    sub foo {
\&        # ... do something ...
\&        die "I\*(Aqm sorry, Dave, I can\*(Aqt do that\en";
\&    }
.Ve
.PP
If you're writing a plugin, or some extension code that has the current
Template::Context in scope (you can safely skip this section if this means
nothing to you) then you can also raise an exception by calling the context
\&\fBthrow()\fR method. You can pass it an
Template::Exception object reference, a pair of \f(CW\*(C`($type, $info)\*(C'\fR
parameters or just an \f(CW$info\fR string to create an exception of '\f(CW\*(C`undef\*(C'\fR' type.
.PP
.Vb 3
\&    $context\->throw($e);            # exception object
\&    $context\->throw(\*(AqDenied\*(Aq);      # \*(Aqundef\*(Aq type
\&    $context\->throw(\*(Aquser.passwd\*(Aq, \*(AqBad Password\*(Aq);
.Ve
.SS "\s-1NEXT\s0"
.IX Subsection "NEXT"
The \f(CW\*(C`NEXT\*(C'\fR directive can be used to start the next iteration of a \f(CW\*(C`FOREACH\*(C'\fR
or \f(CW\*(C`WHILE\*(C'\fR loop.
.PP
.Vb 4
\&    [% FOREACH user IN users %]
\&       [% NEXT IF user.isguest %]
\&       Name: [% user.name %]    Email: [% user.email %]
\&    [% END %]
.Ve
.SS "\s-1LAST\s0"
.IX Subsection "LAST"
The \f(CW\*(C`LAST\*(C'\fR directive can be used to prematurely exit a \f(CW\*(C`FOREACH\*(C'\fR or \f(CW\*(C`WHILE\*(C'\fR
loop.
.PP
.Vb 4
\&    [% FOREACH user IN users %]
\&       Name: [% user.name %]    Email: [% user.email %]
\&       [% LAST IF some.condition %]
\&    [% END %]
.Ve
.PP
\&\f(CW\*(C`BREAK\*(C'\fR can also be used as an alias for \f(CW\*(C`LAST\*(C'\fR.
.SS "\s-1RETURN\s0"
.IX Subsection "RETURN"
The \f(CW\*(C`RETURN\*(C'\fR directive can be used to stop processing the current template
and return to the template from which it was called, resuming processing at
the point immediately after the \f(CW\*(C`INCLUDE\*(C'\fR, \f(CW\*(C`PROCESS\*(C'\fR or \f(CW\*(C`WRAPPER\*(C'\fR
directive. If there is no enclosing template then the Template
\&\fBprocess()\fR method will return to the calling code with a
true value.
.PP
.Vb 3
\&    Before
\&    [% INCLUDE half_wit %]
\&    After
\&
\&    [% BLOCK half_wit %]
\&    This is just half...
\&    [% RETURN %]
\&    ...a complete block
\&    [% END %]
.Ve
.PP
Output:
.PP
.Vb 3
\&    Before
\&    This is just half...
\&    After
.Ve
.SS "\s-1STOP\s0"
.IX Subsection "STOP"
The \f(CW\*(C`STOP\*(C'\fR directive can be used to indicate that the processor should stop
gracefully without processing any more of the template document. This is a
planned stop and the Template \fBprocess()\fR method will
return a \fBtrue\fR value to the caller. This indicates that the template was
processed successfully according to the directives within it.
.PP
.Vb 4
\&    [% IF something.terrible.happened %]
\&       [% INCLUDE fatal/error.html %]
\&       [% STOP %]
\&    [% END %]
\&
\&    [% TRY %]
\&       [% USE DBI(mydsn) %]
\&       ...
\&    [% CATCH DBI.connect %]
\&       <h1>Cannot connect to the database: [% error.info %]</h1>
\&       <p>
\&         We apologise for the inconvenience.
\&       </p>
\&       [% INCLUDE footer %]
\&       [% STOP %]
\&    [% END %]
.Ve
.SS "\s-1CLEAR\s0"
.IX Subsection "CLEAR"
The \f(CW\*(C`CLEAR\*(C'\fR directive can be used to clear the output buffer for the current
enclosing block.   It is most commonly used to clear the output generated
from a \f(CW\*(C`TRY\*(C'\fR block up to the point where the error occurred.
.PP
.Vb 8
\&    [% TRY %]
\&       blah blah blah            # this is normally left intact
\&       [% THROW some \*(Aqerror\*(Aq %]  # up to the point of error
\&       ...
\&    [% CATCH %]
\&       [% CLEAR %]               # clear the TRY output
\&       [% error %]               # print error string
\&    [% END %]
.Ve
.SH "Miscellaneous"
.IX Header "Miscellaneous"
.SS "\s-1META\s0"
.IX Subsection "META"
The \f(CW\*(C`META\*(C'\fR directive allows simple metadata items to be defined within a
template. These are evaluated when the template is parsed and as such may only
contain simple values (e.g. it's not possible to interpolate other variables
values into \f(CW\*(C`META\*(C'\fR variables).
.PP
.Vb 5
\&    [% META
\&       title   = \*(AqThe Cat in the Hat\*(Aq
\&       author  = \*(AqDr. Seuss\*(Aq
\&       version = 1.23
\&    %]
.Ve
.PP
The \f(CW\*(C`template\*(C'\fR variable contains a reference to the main template
being processed.  These metadata items may be retrieved as attributes
of the template.
.PP
.Vb 2
\&    <h1>[% template.title %]</h1>
\&    <h2>[% template.author %]</h2>
.Ve
.PP
The \f(CW\*(C`name\*(C'\fR and \f(CW\*(C`modtime\*(C'\fR metadata items are automatically defined for each
template to contain its name and modification time in seconds since the epoch.
.PP
.Vb 4
\&    [% USE date %]              # use Date plugin to format time
\&    ...
\&    [% template.name %] last modified
\&    at [% date.format(template.modtime) %]
.Ve
.PP
The \f(CW\*(C`PRE_PROCESS\*(C'\fR and \f(CW\*(C`POST_PROCESS\*(C'\fR options allow common headers and
footers to be added to all templates.  The \f(CW\*(C`template\*(C'\fR reference is
correctly defined when these templates are processed, allowing headers
and footers to reference metadata items from the main template.
.PP
.Vb 4
\&    $template = Template\->new({
\&        PRE_PROCESS  => \*(Aqheader\*(Aq,
\&        POST_PROCESS => \*(Aqfooter\*(Aq,
\&    });
\&
\&    $template\->process(\*(Aqcat_in_hat\*(Aq);
.Ve
.PP
header:
.PP
.Vb 5
\&    <html>
\&      <head>
\&        <title>[% template.title %]</title>
\&      </head>
\&      <body>
.Ve
.PP
cat_in_hat:
.PP
.Vb 6
\&    [% META
\&         title   = \*(AqThe Cat in the Hat\*(Aq
\&         author  = \*(AqDr. Seuss\*(Aq
\&         version = 1.23
\&         year    = 2000
\&    %]
\&
\&        The cat in the hat sat on the mat.
.Ve
.PP
footer:
.PP
.Vb 4
\&        <hr>
\&        &copy; [% template.year %] [% template.author %]
\&      </body>
\&    </html>
.Ve
.PP
The output generated from the above example is:
.PP
.Vb 10
\&    <html>
\&      <head>
\&        <title>The Cat in the Hat</title>
\&      </head>
\&      <body>
\&        The cat in the hat sat on the mat.
\&        <hr>
\&        &copy; 2000 Dr. Seuss
\&      </body>
\&    </html>
.Ve
.SS "\s-1TAGS\s0"
.IX Subsection "TAGS"
The \f(CW\*(C`TAGS\*(C'\fR directive can be used to set the \f(CW\*(C`START_TAG\*(C'\fR and \f(CW\*(C`END_TAG\*(C'\fR values
on a per-template file basis.
.PP
.Vb 1
\&    [% TAGS <+ +> %]
\&
\&    <+ INCLUDE header +>
.Ve
.PP
The \s-1TAGS\s0 directive may also be used to set a named \f(CW\*(C`TAG_STYLE\*(C'\fR
.PP
.Vb 2
\&    [% TAGS html %]
\&    <!\-\- INCLUDE header \-\->
.Ve
.PP
See the \s-1TAGS\s0 and \s-1TAG_STYLE\s0
configuration options for further details.
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
The \f(CW\*(C`DEBUG\*(C'\fR directive can be used to enable or disable directive debug
messages within a template.  The \f(CW\*(C`DEBUG\*(C'\fR configuration option must be
set to include \f(CW\*(C`DEBUG_DIRS\*(C'\fR for the \f(CW\*(C`DEBUG\*(C'\fR directives to have any effect.
If \f(CW\*(C`DEBUG_DIRS\*(C'\fR is not set then the parser will automatically ignore and
remove any \f(CW\*(C`DEBUG\*(C'\fR directives.
.PP
The \f(CW\*(C`DEBUG\*(C'\fR directive can be used with an \f(CW\*(C`on\*(C'\fR or \f(CW\*(C`off\*(C'\fR parameter to
enable or disable directive debugging messages from that point
forward.  When enabled, the output of each directive in the generated
output will be prefixed by a comment indicate the file, line and
original directive text.
.PP
.Vb 4
\&    [% DEBUG on %]
\&    directive debugging is on (assuming DEBUG option is set true)
\&    [% DEBUG off %]
\&    directive debugging is off
.Ve
.PP
The \f(CW\*(C`format\*(C'\fR parameter can be used to change the format of the debugging
message.
.PP
.Vb 1
\&    [% DEBUG format \*(Aq<!\-\- $file line $line : [% $text %] \-\->\*(Aq %]
.Ve
