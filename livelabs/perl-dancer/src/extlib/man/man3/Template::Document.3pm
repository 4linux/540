.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Template::Document 3"
.TH Template::Document 3 "2022-07-26" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Template::Document \- Compiled template document object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Template::Document;
\&
\&    $doc = Template::Document\->new({
\&        BLOCK => sub { # some perl code; return $some_text },
\&        DEFBLOCKS => {
\&            header => sub { # more perl code; return $some_text },
\&            footer => sub { # blah blah blah; return $some_text },
\&        },
\&        METADATA => {
\&            author  => \*(AqAndy Wardley\*(Aq,
\&            version => 3.14,
\&        }
\&    }) || die $Template::Document::ERROR;
\&
\&    print $doc\->process($context);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines an object class whose instances represent compiled
template documents.  The Template::Parser module creates a
\&\f(CW\*(C`Template::Document\*(C'\fR instance to encapsulate a template as it is compiled
into Perl code.
.PP
The constructor method, \fBnew()\fR, expects a reference to a hash array
containing the \f(CW\*(C`BLOCK\*(C'\fR, \f(CW\*(C`DEFBLOCKS\*(C'\fR and \f(CW\*(C`METADATA\*(C'\fR items.
.PP
The \f(CW\*(C`BLOCK\*(C'\fR item should contain a reference to a Perl subroutine or a textual
representation of Perl code, as generated by the Template::Parser module.
This is then evaluated into a subroutine reference using \f(CW\*(C`eval()\*(C'\fR.
.PP
The \f(CW\*(C`DEFBLOCKS\*(C'\fR item should reference a hash array containing further named
\&\f(CW\*(C`BLOCK\*(C'\fRs which may be defined in the template. The keys represent \f(CW\*(C`BLOCK\*(C'\fR
names and the values should be subroutine references or text strings of Perl
code as per the main \f(CW\*(C`BLOCK\*(C'\fR item.
.PP
The \f(CW\*(C`METADATA\*(C'\fR item should reference a hash array of metadata items relevant
to the document.
.PP
The \fBprocess()\fR method can then be called on the instantiated
\&\f(CW\*(C`Template::Document\*(C'\fR object, passing a reference to a Template::Context
object as the first parameter. This will install any locally defined blocks
(\f(CW\*(C`DEFBLOCKS\*(C'\fR) in the \f(CW\*(C`BLOCKS\*(C'\fR cache in the context (via a call to
\&\fBvisit()\fR) so that they may be subsequently
resolved by the context. The main \f(CW\*(C`BLOCK\*(C'\fR subroutine is then executed,
passing the context reference on as a parameter. The text returned from the
template subroutine is then returned by the \fBprocess()\fR method, after calling
the context \fBleave()\fR method to permit cleanup and
de-registration of named \f(CW\*(C`BLOCKS\*(C'\fR previously installed.
.PP
An \f(CW\*(C`AUTOLOAD\*(C'\fR method provides access to the \f(CW\*(C`METADATA\*(C'\fR items for the
document. The Template::Service module installs a reference to the main
\&\f(CW\*(C`Template::Document\*(C'\fR object in the stash as the \f(CW\*(C`template\*(C'\fR variable. This allows
metadata items to be accessed from within templates, including \f(CW\*(C`PRE_PROCESS\*(C'\fR
templates.
.PP
header:
.PP
.Vb 5
\&    <html>
\&    <head>
\&    <title>[% template.title %]
\&    </head>
\&    ...
.Ve
.PP
\&\f(CW\*(C`Template::Document\*(C'\fR objects are usually created by the Template::Parser
but can be manually instantiated or sub-classed to provide custom
template components.
.SH "METHODS"
.IX Header "METHODS"
.SS "new(\e%config)"
.IX Subsection "new(%config)"
Constructor method which accept a reference to a hash array containing the
structure as shown in this example:
.PP
.Vb 11
\&    $doc = Template::Document\->new({
\&        BLOCK => sub { # some perl code; return $some_text },
\&        DEFBLOCKS => {
\&            header => sub { # more perl code; return $some_text },
\&            footer => sub { # blah blah blah; return $some_text },
\&        },
\&        METADATA => {
\&            author  => \*(AqAndy Wardley\*(Aq,
\&            version => 3.14,
\&        }
\&    }) || die $Template::Document::ERROR;
.Ve
.PP
\&\f(CW\*(C`BLOCK\*(C'\fR and \f(CW\*(C`DEFBLOCKS\*(C'\fR items may be expressed as references to Perl subroutines
or as text strings containing Perl subroutine definitions, as is generated
by the Template::Parser module.  These are evaluated into subroutine references
using \f(CW\*(C`eval()\*(C'\fR.
.PP
Returns a new \f(CW\*(C`Template::Document\*(C'\fR object or \f(CW\*(C`undef\*(C'\fR on error. The
\&\fBerror()\fR class method can be called, or the \f(CW$ERROR\fR
package variable inspected to retrieve the relevant error message.
.SS "process($context)"
.IX Subsection "process($context)"
Main processing routine for the compiled template document. A reference to a
Template::Context object should be passed as the first parameter. The
method installs any locally defined blocks via a call to the context
\&\fBvisit()\fR method, processes its own template,
(passing the context reference as a parameter) and then calls
\&\fBleave()\fR in the context to allow cleanup.
.PP
.Vb 1
\&    print $doc\->process($context);
.Ve
.PP
Returns a text string representing the generated output for the template.
Errors are thrown via \f(CW\*(C`die()\*(C'\fR.
.SS "\fBblock()\fP"
.IX Subsection "block()"
Returns a reference to the main \f(CW\*(C`BLOCK\*(C'\fR subroutine.
.SS "\fBblocks()\fP"
.IX Subsection "blocks()"
Returns a reference to the hash array of named \f(CW\*(C`DEFBLOCKS\*(C'\fR subroutines.
.SS "\fBvariables()\fP"
.IX Subsection "variables()"
Returns a reference to a hash of variables used in the template.
This requires the \s-1TRACE_VARS\s0
option to be enabled.
.SS "\fBmeta()\fP"
.IX Subsection "meta()"
Return a reference to a hash of any \s-1META\s0 items defined in the template.
.SS "\s-1AUTOLOAD\s0"
.IX Subsection "AUTOLOAD"
An autoload method returns \f(CW\*(C`METADATA\*(C'\fR items.
.PP
.Vb 1
\&    print $doc\->author();
.Ve
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
These methods are used internally.
.SS "as_perl($content)"
.IX Subsection "as_perl($content)"
This method generate a Perl representation of the template.
.PP
.Vb 10
\&    my $perl = Template::Document\->as_perl({
\&        BLOCK     => $main_block,
\&        DEFBLOCKS => {
\&            foo   => $foo_block,
\&            bar   => $bar_block,
\&        },
\&        METADATA  => {
\&            name  => \*(Aqmy_template\*(Aq,
\&        }
\&    });
.Ve
.SS "write_perl_file(\e%config)"
.IX Subsection "write_perl_file(%config)"
This method is used to write compiled Perl templates to disk.  If the
\&\f(CW\*(C`COMPILE_EXT\*(C'\fR option (to indicate a file extension for saving compiled
templates) then the Template::Parser module calls this subroutine before
calling the \fBnew()\fR constructor.  At this stage, the parser has a
representation of the template as text strings containing Perl code.  We can
write that to a file, enclosed in a small wrapper which will allow us to
subsequently \f(CW\*(C`require()\*(C'\fR the file and have Perl parse and compile it into a
\&\f(CW\*(C`Template::Document\*(C'\fR.  Thus we have persistence of compiled templates.
.SH "INTERNAL FUNCTIONS"
.IX Header "INTERNAL FUNCTIONS"
.SS "\fBcatch_warnings()\fP"
.IX Subsection "catch_warnings()"
This is a simple handler used to catch any errors that arise when the
compiled Perl template is first evaluated (that is, evaluated by Perl to
create a template subroutine at compile, rather than the template being
processed at runtime).
.SS "\fBis_utf8()\fP"
.IX Subsection "is_utf8()"
This is mapped to \f(CW\*(C`utf8::is_utf8\*(C'\fR for versions of Perl that have it (> 5.008)
or to \f(CW\*(C`Encode::is_utf8\*(C'\fR for Perl 5.008.  Earlier versions of Perl are not
supported.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Wardley <abw@wardley.org> <http://wardley.org/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1996\-2013 Andy Wardley.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Template, Template::Parser
