.\" Automatically generated by Pod::Man 4.12 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Plack 3"
.TH Plack 3 "2022-09-05" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Plack \- Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Plack is a set of tools for using the \s-1PSGI\s0 stack. It contains
middleware components, a reference server and utilities for Web
application frameworks. Plack is like Ruby's Rack or Python's Paste
for \s-1WSGI.\s0
.PP
See \s-1PSGI\s0 for the \s-1PSGI\s0 specification and \s-1PSGI::FAQ\s0 to know what
\&\s-1PSGI\s0 and Plack are and why we need them.
.SH "MODULES AND UTILITIES"
.IX Header "MODULES AND UTILITIES"
.SS "Plack::Handler"
.IX Subsection "Plack::Handler"
Plack::Handler and its subclasses contains adapters for web
servers. We have adapters for the built-in standalone web server
HTTP::Server::PSGI, \s-1CGI\s0,
\&\s-1FCGI\s0, Apache1,
Apache2 and
HTTP::Server::Simple included
in the core Plack distribution.
.PP
There are also many \s-1HTTP\s0 server implementations on \s-1CPAN\s0 that have Plack
handlers.
.PP
See Plack::Handler when writing your own adapters.
.SS "Plack::Loader"
.IX Subsection "Plack::Loader"
Plack::Loader is a loader to load one Plack::Handler adapter
and run a \s-1PSGI\s0 application code reference with it.
.SS "Plack::Util"
.IX Subsection "Plack::Util"
Plack::Util contains a lot of utility functions for server
implementors as well as middleware authors.
.SS ".psgi files"
.IX Subsection ".psgi files"
A \s-1PSGI\s0 application is a code reference but it's not easy to pass code
reference via the command line or configuration files, so Plack uses a
convention that you need a file named \f(CW\*(C`app.psgi\*(C'\fR or similar, which
would be loaded (via perl's core function \f(CW\*(C`do\*(C'\fR) to return the \s-1PSGI\s0
application code reference.
.PP
.Vb 6
\&  # Hello.psgi
\&  my $app = sub {
\&      my $env = shift;
\&      # ...
\&      return [ $status, $headers, $body ];
\&  };
.Ve
.PP
If you use a web framework, chances are that they provide a helper
utility to automatically generate these \f(CW\*(C`.psgi\*(C'\fR files for you, such
as:
.PP
.Vb 3
\&  # MyApp.psgi
\&  use MyApp;
\&  my $app = sub { MyApp\->run_psgi(@_) };
.Ve
.PP
It's important that the return value of \f(CW\*(C`.psgi\*(C'\fR file is the code
reference. See \f(CW\*(C`eg/dot\-psgi\*(C'\fR directory for more examples of \f(CW\*(C`.psgi\*(C'\fR
files.
.SS "plackup, Plack::Runner"
.IX Subsection "plackup, Plack::Runner"
plackup is a command line launcher to run \s-1PSGI\s0 applications from
command line using Plack::Loader to load \s-1PSGI\s0 backends. It can be
used to run standalone servers and FastCGI daemon processes. Other
server backends like Apache2 needs a separate configuration but
\&\f(CW\*(C`.psgi\*(C'\fR application file can still be the same.
.PP
If you want to write your own frontend that replaces, or adds
functionalities to plackup, take a look at the Plack::Runner module.
.SS "Plack::Middleware"
.IX Subsection "Plack::Middleware"
\&\s-1PSGI\s0 middleware is a \s-1PSGI\s0 application that wraps an existing \s-1PSGI\s0
application and plays both side of application and servers. From the
servers the wrapped code reference still looks like and behaves
exactly the same as \s-1PSGI\s0 applications.
.PP
Plack::Middleware gives you an easy way to wrap \s-1PSGI\s0 applications
with a clean \s-1API,\s0 and compatibility with Plack::Builder \s-1DSL.\s0
.SS "Plack::Builder"
.IX Subsection "Plack::Builder"
Plack::Builder gives you a \s-1DSL\s0 that you can enable Middleware in
\&\f(CW\*(C`.psgi\*(C'\fR files to wrap existent \s-1PSGI\s0 applications.
.SS "Plack::Request, Plack::Response"
.IX Subsection "Plack::Request, Plack::Response"
Plack::Request gives you a nice wrapper \s-1API\s0 around \s-1PSGI\s0 \f(CW$env\fR
hash to get headers, cookies and query parameters much like
Apache::Request in mod_perl.
.PP
Plack::Response does the same to construct the response array
reference.
.SS "Plack::Test"
.IX Subsection "Plack::Test"
Plack::Test is a unified interface to test your \s-1PSGI\s0 application
using standard HTTP::Request and HTTP::Response pair with simple
callbacks.
.SS "Plack::Test::Suite"
.IX Subsection "Plack::Test::Suite"
Plack::Test::Suite is a test suite to test a new \s-1PSGI\s0 server backend.
.SH "CONTRIBUTING"
.IX Header "CONTRIBUTING"
.SS "Patches and Bug Fixes"
.IX Subsection "Patches and Bug Fixes"
Small patches and bug fixes can be either submitted via nopaste on \s-1IRC\s0
<irc://irc.perl.org/#plack> or the github issue
tracker <http://github.com/plack/Plack/issues>.  Forking on
github <http://github.com/plack/Plack> is another good way if you
intend to make larger fixes.
.PP
See also <http://contributing.appspot.com/plack> when you think this
document is terribly outdated.
.SS "Module Namespaces"
.IX Subsection "Module Namespaces"
Modules added to the Plack:: sub-namespaces should be reasonably generic
components which are useful as building blocks and not just simply using
Plack.
.PP
Middleware authors are free to use the Plack::Middleware:: namespace for
their middleware components. Middleware must be written in the pipeline
style such that they can chained together with other middleware components.
The Plack::Middleware:: modules in the core distribution are good examples
of such modules. It is recommended that you inherit from Plack::Middleware
for these types of modules.
.PP
Not all middleware components are wrappers, but instead are more like
endpoints in a middleware chain. These types of components should use the
Plack::App:: namespace. Again, look in the core modules to see excellent
examples of these (Plack::App::File, Plack::App::Directory, etc.).
It is recommended that you inherit from Plack::Component for these
types of modules.
.PP
\&\fB\s-1DO NOT USE\s0\fR Plack:: namespace to build a new web application or a
framework. It's like naming your application under \s-1CGI::\s0 namespace if
it's supposed to run on \s-1CGI\s0 and that is a really bad choice and
would confuse people badly.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tatsuhiko Miyagawa
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The following copyright notice applies to all the files provided in
this distribution, including binary files, unless explicitly noted
otherwise.
.PP
Copyright 2009\-2013 Tatsuhiko Miyagawa
.SH "CORE DEVELOPERS"
.IX Header "CORE DEVELOPERS"
Tatsuhiko Miyagawa (miyagawa)
.PP
Tokuhiro Matsuno (tokuhirom)
.PP
Jesse Luehrs (doy)
.PP
Tomas Doran (bobtfish)
.PP
Graham Knop (haarg)
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Yuval Kogman (nothingmuch)
.PP
Kazuhiro Osawa (Yappo)
.PP
Kazuho Oku
.PP
Florian Ragwitz (rafl)
.PP
Chia-liang Kao (clkao)
.PP
Masahiro Honma (hiratara)
.PP
Daisuke Murase (typester)
.PP
John Beppu
.PP
Matt S Trout (mst)
.PP
Shawn M Moore (Sartak)
.PP
Stevan Little
.PP
Hans Dieter Pearcey (confound)
.PP
mala
.PP
Mark Stosberg
.PP
Aaron Trevena
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \s-1PSGI\s0 specification upon which Plack is based.
.PP
<http://plackperl.org/>
.PP
The Plack wiki: <https://github.com/plack/Plack/wiki>
.PP
The Plack \s-1FAQ:\s0 <https://github.com/plack/Plack/wiki/Faq>
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
